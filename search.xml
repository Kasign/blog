<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS底层探索系列--方法的本质</title>
    <url>/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97-%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有下面一份代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       </span><br><span class="line">        FLYPerson * person = [FLYPerson alloc];</span><br><span class="line">        [person walk];</span><br><span class="line">        [FLYPerson say];</span><br><span class="line">        <span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用clang编译之后，提取我们想要的部分</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_dq_mwrk2yjx1b18hws5lc3pb7g80000gn_T_main_11652b_mi_0, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        FLYPerson * person = ((FLYPerson *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"FLYPerson"</span>), sel_registerName(<span class="string">"alloc"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)person, sel_registerName(<span class="string">"walk"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"FLYPerson"</span>), sel_registerName(<span class="string">"say"</span>));</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="一、runtime"><a href="#一、runtime" class="headerlink" title="一、runtime"></a>一、runtime</h2><p>定义 : 一套由c、c++和汇编编写能够为oc提供运行时功能的api。<br>runtime有两个版本，分别是modern’ 和 ‘legacy’， legacy是老版本中的runtime，Objective-C 2.0 以及后续版本中用的都是modern版本的runtime（参考官方文档）。</p>
<p>使用方式可以归纳为三种：<br>1、Objective-C code @selector()<br>2、NSObject的方法    NSSelectorFromString()<br>3、sel_registerName 函数api</p>
<h2 id="一、objc-msgSend"><a href="#一、objc-msgSend" class="headerlink" title="一、objc_msgSend"></a>一、objc_msgSend</h2><p>首先，objc_msgSend是用汇编写的，那么为什么会选用汇编写呢？原因有如下两点</p>
<ul>
<li>1、因为在C语言中不可能通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。C语言没有足够做这件事的必要特性。</li>
<li>2、因为objc_msgSend执行的频率是想当非常之高，所以必须保证执行的足够快，这里汇编也就必然是首选。</li>
</ul>
<p>objc_msgSend可以分为快速路径，慢速路径，都是用C实现的。</p>
<p>作用流程：<br>1：ENTRY _objc_msgSend<br>2: 对消息接受者（id self, sel _cmd） 判断处理<br>3：taggedPointer判断处理<br>4：‘GetClassFromlsa_p16 isa’ 指针处理 - class<br>5：CacheLoopup 查找缓存<br>6：‘cache_t’ 处理 ’bucket’ 以及内存哈希处理<br>   6.1: 找不到递归下一个 ‘bucket’<br>   6.2: 找到了就返回 ‘{imp, sel} = *bucket -&gt; imp’<br>   6.3: 遇到意外就重试<br>   6.4: 找不到就 ‘JumpMiss’<br>7：__objc_msgSend_uncached 告诉找不到缓存 ‘imp’<br>8：‘STATIC_ENTRY __objc_msgSend_uncached’<br>9：‘MethodTableLookup’ 方法表查找<br>   9.1: ‘sava parameter registers’<br>   9.2: ‘self’ 以及 _cmd 准备<br>   9.3: ‘_class_lookupMethodAndLoadCache3’ 调用</p>
<p>下面展示两种用法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span><span class="operator"> * </span>argv<span class="literal">[]</span>) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       </span><br><span class="line">        FLYStudent<span class="operator"> * </span>person = <span class="literal">[FLYS<span class="identifier">tudent</span> <span class="identifier">alloc</span>]</span>;</span><br><span class="line"></span><br><span class="line">        objc<span class="constructor">_msgSend(<span class="params">person</span>, <span class="params">sel_registerName</span>(<span class="string">"walk"</span>)</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象方法</span></span><br><span class="line">        <span class="keyword">struct</span> objc_super flySuper;</span><br><span class="line">        flySuper.receiver    = person;</span><br><span class="line">        flySuper.super_class = <span class="literal">[<span class="identifier">person</span> <span class="identifier">class</span>]</span>;<span class="comment">//receiver的isa</span></span><br><span class="line">        objc<span class="constructor">_msgSendSuper(&amp;<span class="params">flySuper</span>, <span class="params">sel_registerName</span>(<span class="string">"walk"</span>)</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用类方法</span></span><br><span class="line">        <span class="keyword">struct</span> objc_super classSuper;</span><br><span class="line">        classSuper.receiver    = <span class="literal">[<span class="identifier">person</span> <span class="identifier">class</span>]</span>;</span><br><span class="line">        classSuper.super_class = object<span class="constructor">_getClass([<span class="params">person</span> <span class="params">class</span>])</span>;<span class="comment">//receiver的isa（或者为receiver的isa的superClass）</span></span><br><span class="line">        objc<span class="constructor">_msgSendSuper(&amp;<span class="params">classSuper</span>, <span class="params">sel_registerName</span>(<span class="string">"sayXiXi"</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>lookUpImpOrForward.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>The standard IMP lookup. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>initialize==NO tries to avoid +initialize (</span>but<span class="markdown"> sometimes fails)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>cache==NO skips optimistic unlocked lookup (</span>but<span class="markdown"> uses cache elsewhere)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Most callers </span>should<span class="markdown"> use initialize==YES and cache==YES.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>inst is </span>an<span class="markdown"> instance of cls or </span>a<span class="markdown"> subclass thereof, or nil if none is known. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>If cls is </span>an<span class="markdown"> un-initialized metaclass then </span>a<span class="markdown"> non-nil inst is faster.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>May return <span class="emphasis">_objc_</span>msgForward_impcache. IMPs destined for external use </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>must be converted to <span class="emphasis">_objc_</span>msgForward or <span class="emphasis">_objc_</span>msgForward_stret.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>If </span>you<span class="markdown"> </span>don't<span class="markdown"> want forwarding at all, use lookUpImpOrNil() instead.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       <span class="built_in">bool</span> initialize, <span class="built_in">bool</span> cache, <span class="built_in">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="built_in">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);<span class="comment">//检查是否是已知类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    如果没有初始化，去初始化该类</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    initialize该类</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    取缓存，以下为汇编源码，防止被hook，以及运行速度和性能</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    STATIC_ENTRY _cache_getImp</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    GetClassFromIsa_p16 p0</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    CacheLookup GETIMP</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    LGetImpMiss:</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    mov p0, #0</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    ret</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    END_ENTRY _cache_getImp</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) goto done;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    查找当前类里面方法列表</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    查找父类里面方法</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    消息转发机制</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    最终都没有找到，走_objc_msgForward_impcache方法，苹果留的最后的后门，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    汇编源码：</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    STATIC_ENTRY __objc_msgForward_impcache</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    // No stret specialization.</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    b   __objc_msgForward</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    END_ENTRY __objc_msgForward_impcache</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    ENTRY __objc_msgForward</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    adrp    x17, __objc_forward_handler@PAGE</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    ldr p17, [x17, __objc_forward_handler@PAGEOFF]</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    TailCallFunctionPointer x17</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    END_ENTRY __objc_msgForward</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    以上__objc_forward_handler是非汇编</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__attribute__((noreturn)) <span class="keyword">void</span> </span><br><span class="line">objc_defaultForwardHandler(<span class="keyword">id</span> <span class="keyword">self</span>, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">"%c[%s %s]: unrecognized selector sent to instance %p "</span></span><br><span class="line">                <span class="string">"(no message forward handler is installed)"</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(<span class="keyword">self</span>)) ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                object_getClassName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>

<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">void</span> _class_resolveMethod(Class cls, <span class="keyword">SEL </span><span class="keyword">sel, </span>id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:<span class="keyword">sel]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       _class_resolveInstanceMethod(cls, <span class="keyword">sel, </span>inst)<span class="comment">;</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">else</span> &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:<span class="keyword">sel]</span></span><br><span class="line"><span class="keyword"> </span>       // <span class="keyword">and </span>[cls resolveInstanceMethod:<span class="keyword">sel]</span></span><br><span class="line"><span class="keyword"> </span>       _class_resolveClassMethod(cls, <span class="keyword">sel, </span>inst)<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (!lookUpImpOrNil(cls, <span class="keyword">sel, </span>inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, <span class="keyword">sel, </span>inst)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS底层探索系列</category>
      </categories>
      <tags>
        <tag>方法的本质</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层探索系列--类的本质</title>
    <url>/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8.html</url>
    <content><![CDATA[<p>在讲这边文章之前，假设我们都已经掌握了c语言指针知识。并且已经编译好了苹果开源的objc4-756。<br>关于一些lldb的指令，请移步<a href="https://www.ericlife.top/Xcode%E8%B0%83%E8%AF%95LLDB.html" target="_blank" rel="noopener">Xcode调试LLDB</a><br>补充两点：</p>
<ul>
<li>p/x 以16进制打印当前地址</li>
<li>x/4xg 以16进制读取当前对象的首地址向后4位内存地址</li>
</ul>
<h2 id="一、查看cpp源码"><a href="#一、查看cpp源码" class="headerlink" title="一、查看cpp源码"></a>一、查看cpp源码</h2><p>首先我们创建一个工程，声明一个FLYPerson类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FLYPerson</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line">- (<span class="keyword">void</span>)sayByeBye;</span><br><span class="line">- (<span class="keyword">void</span>)sayGoGo;</span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FLYPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : Hello!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayByeBye &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : ByeBye!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayGoGo &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : GoGo!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : Happy!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在main函数中我们创建一个对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        FLYPerson * person = [[FLYPerson alloc] init];</span><br><span class="line">        Class pClass       = object_getClass(person);</span><br><span class="line">        [person sayHello];</span><br><span class="line">        [person sayByeBye];</span><br><span class="line">        [person sayGoGo];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ - %p"</span>, person, pClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用clang编译成cpp源码(先cd到当前文件的目录):</p>
<ul>
<li>clang -rewrite-objc main.m -o main.cpp</li>
<li>存在UIKit等其他动态引用库时：<br>clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 -isysroot/Application/Xcode.app/Comtents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.0.sdk main.m</li>
<li>xcrun xcode 命令<br>模拟器：xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp<br>真机：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp</li>
</ul>
<h2 id="二、在生成的-cpp源码中查看FLYPerson类"><a href="#二、在生成的-cpp源码中查看FLYPerson类" class="headerlink" title="二、在生成的.cpp源码中查看FLYPerson类"></a>二、在生成的.cpp源码中查看FLYPerson类</h2><p>既然我们探究的是类，那就是Class，我们在cpp文件中可以看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> * <span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>
<p>这说明，Class其实就是objc_class结构体的指针<br>继续查找，可以发现objc_clss的声明：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa <span class="constructor">__attribute__((<span class="params">deprecated</span>)</span>);</span><br><span class="line">&#125; <span class="constructor">__attribute__((<span class="params">unavailable</span>)</span>);</span><br></pre></td></tr></table></figure>
<p>已经注释已经废弃，没有办法了么？还记得我们已经准备好了756的源码，去源码中搜索objc_class，会发现几点重要信息：<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/objc_class_1.png" alt><br>上图中可以证实，class其实就是objc_class</p>
<p><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/objc_class_2.png" alt></p>
<h2 id="三、分析objc-class源码"><a href="#三、分析objc-class源码" class="headerlink" title="三、分析objc_class源码"></a>三、分析objc_class源码</h2><h3 id="1、先来了解一下主要的数据结构"><a href="#1、先来了解一下主要的数据结构" class="headerlink" title="1、先来了解一下主要的数据结构"></a>1、先来了解一下主要的数据结构</h3><p>看一下objc_class数据结构：<br>objc-runtime-new.h中struct objc_class : objc_object</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//此处省略了结构体内的函数方法，以上是全部属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下内部属性的各自数据结构，这里的// Class ISA; ISA被隐藏了，这是因为objc_class继承自objc_object</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：<br>这里isa用Class类型，应该是与oc的多态类似，isa和class的结构相同，或者isa就是按照class的结构来设计的。</p>
<p>cache_t：（对sel和imp做缓存，这里有一个3/4缓存机制）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 指针占用8字节</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;              <span class="comment">// uint32_t类型 32 / 8 = 4字节</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;          <span class="comment">// uint32_t类型 32 / 8 = 4字节</span></span><br><span class="line">    ... <span class="comment">//省略所有函数方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class_data_bits_t：（这里只有一个属性bits,其中具体的值要转换成data查看，即class_rw_t* data() ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="comment">// Set during realization or construction only. No locking needed.</span></span><br><span class="line">        <span class="comment">// Use a store-release fence because there may be concurrent</span></span><br><span class="line">        <span class="comment">// readers of data and data's contents.</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        atomic_thread_fence(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//以下函数省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class_rw_t的数据结构：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">uint32_t</span> <span class="built_in">set</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        OSAtomicOr32Barrier(<span class="built_in">set</span>, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearFlags</span><span class="params">(<span class="keyword">uint32_t</span> <span class="built_in">clear</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        OSAtomicXor32Barrier(<span class="built_in">clear</span>, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set and clear must not overlap</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlags</span><span class="params">(<span class="keyword">uint32_t</span> <span class="built_in">set</span>, <span class="keyword">uint32_t</span> <span class="built_in">clear</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert((<span class="built_in">set</span> &amp; <span class="built_in">clear</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | <span class="built_in">set</span>) &amp; ~<span class="built_in">clear</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>class_ro_t的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、计算objc-class中各属性占用的字节长度"><a href="#2、计算objc-class中各属性占用的字节长度" class="headerlink" title="2、计算objc_class中各属性占用的字节长度"></a>2、计算objc_class中各属性占用的字节长度</h3><p>提取出objc_class中的属性：<br>    Class ISA;                 // 8字节<br>    Class superclass;          // 8字节<br>    cache_t cache;             // 经过计算后为16字节<br>    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</p>
<h3 id="3、获取类中成员变量、属性和method"><a href="#3、获取类中成员变量、属性和method" class="headerlink" title="3、获取类中成员变量、属性和method"></a>3、获取类中成员变量、属性和method</h3><p>此时回到我们main函数:<br>利用lldb指令打印FLYperson对象指针地址：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx pClass</span><br><span class="line"><span class="number">0x1000021f8</span>: <span class="number">0x001d8001000021d1</span> <span class="number">0x0000000100b37140</span></span><br><span class="line"><span class="number">0x100002208</span>: <span class="number">0x00000001003da290</span> <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>0x1000021f8 偏移8个字节，刚好到superclass的首地址，打印出了superclass</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="number">0x100002200</span></span><br><span class="line">&lt;NSObject: <span class="number">0x100002200</span>&gt;</span><br></pre></td></tr></table></figure>
<p>利用内存地址偏移，0x100002208 较 0x1000021f8 刚好偏移16位，刚好指向objc_class中的cache的首地址</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="number">0x100002208</span></span><br><span class="line"><span class="number">4294976008</span></span><br></pre></td></tr></table></figure>
<p>打印cache的首地址，发现是一串数字，因为cache是结构体，内部有多个值，进行了内存对齐，所以打印出来的是多个值的组合，先过滤，最后进行摸索，由于cache是16位，从cache首地址偏移16位，就能到达bits首地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(lldb)</span> <span class="string">po</span> <span class="number">0x100002218</span></span><br><span class="line"><span class="string">objc[14430]:</span> <span class="string">Attempt</span> <span class="string">to</span> <span class="string">use</span> <span class="string">unknown</span> <span class="string">class</span> <span class="number">0x101e09dd0</span><span class="string">.</span></span><br><span class="line"><span class="number">4294976024</span></span><br><span class="line"></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="number">0x100002218</span></span><br><span class="line"><span class="string">(long)</span> <span class="string">$5</span> <span class="string">=</span> <span class="number">4294976024</span></span><br></pre></td></tr></table></figure>
<p>两种方式均报错了,尝试强转（因为已经不是oc中对象类型，以下都是用p来打印）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0x100002218</span></span><br><span class="line">(class_data_bits_t *) $<span class="number">7</span> = <span class="number">0x0000000100002218</span></span><br></pre></td></tr></table></figure>
<p>此时用到class_data_bits_t中的方法(此方法是通过掩码的方式，将数据获取出来，FAST_DATA_MASK是掩码)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">class_rw_t</span>* <span class="class"><span class="keyword">data</span>() &#123;</span></span><br><span class="line"><span class="class">    <span class="title">return</span> (<span class="title">class_rw_t</span> *)(<span class="title">bits</span> &amp; <span class="type">FAST_DATA_MASK</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>继续获取：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">7</span>-&gt;data()</span><br><span class="line">(class_rw_t *) $<span class="number">9</span> = <span class="number">0x0000000101e09dd0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取$9的值</span></span><br><span class="line">(lldb) p *$<span class="number">9</span></span><br><span class="line">(class_rw_t) $<span class="number">10</span> = &#123;</span><br><span class="line">  flags = <span class="number">2148139008</span></span><br><span class="line">  version = <span class="number">0</span></span><br><span class="line">  ro = <span class="number">0x0000000100002170</span></span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;method_t, method_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x00000001000020a8</span></span><br><span class="line">        <span class="built_in">array</span>AndFlag = <span class="number">4294975656</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;property_t, property_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000100002158</span></span><br><span class="line">        <span class="built_in">array</span>AndFlag = <span class="number">4294975832</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        <span class="built_in">array</span>AndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = NSUUID</span><br><span class="line">  demangledName = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">10.</span>ro</span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) $<span class="number">11</span> = <span class="number">0x0000000100002170</span></span><br><span class="line">(lldb) p *$<span class="number">11</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) $<span class="number">12</span> = &#123;</span><br><span class="line">  flags = <span class="number">388</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">24</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000100000f45</span> <span class="string">"\x02"</span></span><br><span class="line">  name = <span class="number">0x0000000100000f3b</span> <span class="string">"FLYPerson"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000020a8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000100002110</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100002158</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">12.</span>baseProperties</span><br><span class="line">(property_list_t *const) $<span class="number">13</span> = <span class="number">0x0000000100002158</span></span><br><span class="line">(lldb) p *$<span class="number">13</span></span><br><span class="line">(property_list_t) $<span class="number">14</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, <span class="number">0</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">16</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    first = (name = <span class="string">"nickName"</span>, attributes = <span class="string">"T@<span class="subst">\"</span>NSString<span class="subst">\"</span>,C,N,V_nickName"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">12.</span>ivars</span><br><span class="line">(const ivar_list_t *const) $<span class="number">15</span> = <span class="number">0x0000000100002110</span></span><br><span class="line">(lldb) p *$<span class="number">15</span></span><br><span class="line">(const ivar_list_t) $<span class="number">16</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, <span class="number">0</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">32</span></span><br><span class="line">    count = <span class="number">2</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      offset = <span class="number">0x00000001000021c0</span></span><br><span class="line">      name = <span class="number">0x0000000100000f7d</span> <span class="string">"hobby"</span></span><br><span class="line">      type = <span class="number">0x0000000100000fa8</span> <span class="string">"@<span class="subst">\"</span>NSString<span class="subst">\"</span>"</span></span><br><span class="line">      alignment_raw = <span class="number">3</span></span><br><span class="line">      size = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法列表：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) p $<span class="number">12.</span>baseMethodList</span><br><span class="line">(method_list_t *<span class="keyword">const</span>) $<span class="number">17</span> = <span class="number">0x00000001000020a8</span></span><br><span class="line">(lldb) p *$<span class="number">17</span></span><br><span class="line">(method_list_t) $<span class="number">18</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, <span class="number">3</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">26</span></span><br><span class="line">    count = <span class="number">4</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      name = <span class="string">"sayHello"</span></span><br><span class="line">      types = <span class="number">0x0000000100000f8d</span> <span class="string">"v16@0:8"</span></span><br><span class="line">      imp = <span class="number">0x0000000100000c90</span> (FLYTest`-[FLYPerson sayHello] at FLYPerson.m:<span class="number">12</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>count = 4 说明有4个方法，让我们一一打印(get是结构体中的函数，可去结构体中查看)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">(lldb) p <span class="meta">$18</span>.<span class="keyword">get</span>(<span class="number">0</span>)</span><br><span class="line">(method_t) <span class="meta">$19</span> = &#123;</span><br><span class="line">  <span class="type">name</span> = "sayHello"</span><br><span class="line">  <span class="keyword">types</span> = <span class="number">0x0000000100000f8d</span> "v16@0:8"</span><br><span class="line">  imp = <span class="number">0x0000000100000c90</span> (FLYTest`-[FLYPerson sayHello] at FLYPerson.m:<span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="meta">$18</span>.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">(method_t) <span class="meta">$20</span> = &#123;</span><br><span class="line">  <span class="type">name</span> = ".cxx_destruct"</span><br><span class="line">  <span class="keyword">types</span> = <span class="number">0x0000000100000f8d</span> "v16@0:8"</span><br><span class="line">  imp = <span class="number">0x0000000100000d60</span> (FLYTest`-[FLYPerson .cxx_destruct] at FLYPerson.m:<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="meta">$18</span>.<span class="keyword">get</span>(<span class="number">2</span>)</span><br><span class="line">(method_t) <span class="meta">$21</span> = &#123;</span><br><span class="line">  <span class="type">name</span> = "setNickName:"</span><br><span class="line">  <span class="keyword">types</span> = <span class="number">0x0000000100000f9d</span> "v24@0:8@16"</span><br><span class="line">  imp = <span class="number">0x0000000100000d20</span> (FLYTest`-[FLYPerson setNickName:] at FLYPerson.h:<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="meta">$18</span>.<span class="keyword">get</span>(<span class="number">3</span>)</span><br><span class="line">(method_t) <span class="meta">$22</span> = &#123;</span><br><span class="line">  <span class="type">name</span> = "nickName"</span><br><span class="line">  <span class="keyword">types</span> = <span class="number">0x0000000100000f95</span> "@16@0:8"</span><br><span class="line">  imp = <span class="number">0x0000000100000cf0</span> (FLYTest`-[FLYPerson nickName] at FLYPerson.h:<span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上并没有类方法，因为类方法是存放在元类中的,让我们来获取该类的ISA，即该类的元类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>xg pClass</span><br><span class="line"><span class="number">0x1000021f8</span>: <span class="number">0x001d8001000021d1</span> <span class="number">0x0000000100b37140</span></span><br><span class="line"><span class="number">0x100002208</span>: <span class="number">0x00000001003da290</span> <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">(lldb) po <span class="number">0x001d8001000021d1</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">FLYPerson</span><br><span class="line"></span><br><span class="line">(lldb) p/x <span class="number">0x001d8001000021d1</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(long) $<span class="number">3</span> = <span class="number">0x00000001000021d0</span></span><br><span class="line"></span><br><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x00000001000021d0</span></span><br><span class="line"><span class="number">0x1000021d0</span>: <span class="number">0x001d800100b370f1</span> <span class="number">0x0000000100b370f0</span></span><br><span class="line"><span class="number">0x1000021e0</span>: <span class="number">0x000000010112bcb0</span> <span class="number">0x0000000100000003</span></span><br><span class="line"></span><br><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0x1000021f0</span></span><br><span class="line">(class_data_bits_t *) $<span class="number">5</span> = <span class="number">0x00000001000021f0</span></span><br><span class="line"></span><br><span class="line">(lldb) p $<span class="number">5</span>-&gt;data()</span><br><span class="line">(class_rw_t *) $<span class="number">7</span> = <span class="number">0x0000000101111ac0</span></span><br><span class="line"></span><br><span class="line">(lldb) p $<span class="number">7</span>-&gt;ro</span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) $<span class="number">8</span> = <span class="number">0x0000000100002060</span></span><br><span class="line"></span><br><span class="line">(lldb) p *$<span class="number">8</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) $<span class="number">9</span> = &#123;</span><br><span class="line">  flags = <span class="number">389</span></span><br><span class="line">  instanceStart = <span class="number">40</span></span><br><span class="line">  instanceSize = <span class="number">40</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  name = <span class="number">0x0000000100000f3b</span> <span class="string">"FLYPerson"</span></span><br><span class="line">  baseMethodList = <span class="number">0x0000000100002040</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $<span class="number">9.</span>baseMethodList</span><br><span class="line">(method_list_t *<span class="keyword">const</span>) $<span class="number">11</span> = <span class="number">0x0000000100002040</span></span><br><span class="line"></span><br><span class="line">(lldb) p *$<span class="number">11</span></span><br><span class="line">(method_list_t) $<span class="number">12</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, <span class="number">3</span>&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = <span class="number">26</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    first = &#123;</span><br><span class="line">      name = <span class="string">"sayHappy"</span></span><br><span class="line">      types = <span class="number">0x0000000100000f8d</span> <span class="string">"v16@0:8"</span></span><br><span class="line">      imp = <span class="number">0x0000000100000cc0</span> (FLYTest`+[FLYPerson sayHappy] at FLYPerson.m:<span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过一顿操作之后，又回到了上述的地方（至于0x00007ffffffffff8怎么来的，会在另一篇文章中指出）</p>
<p>小结：<br>在获取成员变量、属性和方法的时候，objc_class -&gt; bits -&gt; class_rw_t * data() -&gt; class_ro_t * ro -&gt; 获取对应的属性。<br>此处需要注意的是：在class_rw_t中</p>
<ul>
<li>method_array_t methods;</li>
<li>property_array_t properties;</li>
<li>protocol_array_t protocols;</li>
</ul>
<p>还不清楚这三个属性的作用，有时间补充</p>
<h3 id="4、探索cache的原理"><a href="#4、探索cache的原理" class="headerlink" title="4、探索cache的原理"></a>4、探索cache的原理</h3><p>看一下cache_t完整的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">//实际存储区 </span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;     <span class="comment">// 当前容量</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">// 当前占据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">struct bucket_t *<span class="title">buckets</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">mask_t</span> mask();</span><br><span class="line">    <span class="keyword">mask_t</span> occupied();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementOccupied</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBucketsAndMask</span><span class="params">(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeToEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mask_t</span> capacity();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConstantEmptyCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeFreed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">bytesForCapacity</span><span class="params">(<span class="keyword">uint32_t</span> cap)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> struct bucket_t * <span class="title">endMarker</span><span class="params">(struct <span class="keyword">bucket_t</span> *b, <span class="keyword">uint32_t</span> cap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity)</span></span>;</span><br><span class="line">    <span class="function">struct bucket_t * <span class="title">find</span><span class="params">(<span class="keyword">cache_key_t</span> key, id receiver)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bad_cache</span><span class="params">(id receiver, SEL sel, Class isa)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bucket_t的结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> cache_key_t <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见，sel和imp都是存在bucket_t中。<br>跑一下项目，将断点打在[person sayGoGo]，利用lldb查看内存</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(lldb)</span> <span class="string">x</span> <span class="string">person</span></span><br><span class="line"><span class="attr">0x102100020:</span> <span class="string">4d</span> <span class="number">22</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">80</span> <span class="string">1d</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="string">M"..............</span></span><br><span class="line"><span class="attr">0x102100030:</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="string">................</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">(cache_t</span> <span class="string">*)0x102100030</span></span><br><span class="line"><span class="string">(cache_t</span> <span class="string">*)</span> <span class="string">$1</span> <span class="string">=</span> <span class="number">0x0000000102100030</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">*$1</span></span><br><span class="line"><span class="string">(cache_t)</span> <span class="string">$2</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">_buckets</span> <span class="string">=</span> <span class="number">0x0000000000000000</span></span><br><span class="line">  <span class="string">_mask</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">  <span class="string">_occupied</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">x</span> <span class="string">pClass</span></span><br><span class="line"><span class="attr">0x100002248:</span> <span class="number">21</span> <span class="number">22</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">80</span> <span class="string">1d</span> <span class="number">00</span> <span class="number">40</span> <span class="number">71</span> <span class="string">b3</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="string">!"......@q......</span></span><br><span class="line"><span class="attr">0x100002258:</span> <span class="number">80</span> <span class="number">01</span> <span class="number">10</span> <span class="number">02</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="string">................</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">(cache_t</span> <span class="string">*)0x100002258</span></span><br><span class="line"><span class="string">(cache_t</span> <span class="string">*)</span> <span class="string">$4</span> <span class="string">=</span> <span class="number">0x0000000100002258</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">*$4</span></span><br><span class="line"><span class="string">(cache_t)</span> <span class="string">$5</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">_buckets</span> <span class="string">=</span> <span class="number">0x0000000102100180</span></span><br><span class="line">  <span class="string">_mask</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line">  <span class="string">_occupied</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">$5._buckets</span></span><br><span class="line"><span class="string">(bucket_t</span> <span class="string">*)</span> <span class="string">$6</span> <span class="string">=</span> <span class="number">0x0000000102100180</span></span><br><span class="line"><span class="string">(lldb)</span> <span class="string">p</span> <span class="string">*$6</span></span><br><span class="line"><span class="string">(bucket_t)</span> <span class="string">$7</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">_key</span> <span class="string">=</span> <span class="number">4294971196</span></span><br><span class="line">  <span class="string">_imp</span> <span class="string">=</span> <span class="number">0x0000000100000ba0</span> <span class="string">(FLYTest`-[FLYPerson</span> <span class="string">sayHello]</span> <span class="string">at</span> <span class="string">FLYPerson.m:12)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们先获取person的cache_t,发现内部的值都是空值，又来获取其Class的cache_t,发现是有值的，得出结论，对象的方法列表缓存是存在其类对象中(其实就是对象的ISA中，因为对象的元类就是其Class)。<br>既然我们知道了方法是缓存在class中，那我们直接探索class中方法的缓存策略。</p>
<p>经过诸多尝试，我们发现，对象在调用方法的时候，执行的步骤大概如下：<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/cache_t.png" alt="cache_t大概流程"><br>重点来了，看一下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!cls-&gt;</span>isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="function"><span class="title">mask_t</span> newOccupied = cache-&gt;</span>occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">mask_t</span> capacity = cache-&gt;</span>capacity();</span><br><span class="line">    <span class="function"><span class="title">if</span> (cache-&gt;</span>isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="function"><span class="title">cache</span>-&gt;</span>reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        <span class="function"><span class="title">cache</span>-&gt;</span>expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="function"><span class="title">bucket_t</span> *bucket = cache-&gt;</span>find(key, receiver);</span><br><span class="line">    <span class="function"><span class="title">if</span> (bucket-&gt;</span><span class="function"><span class="title">key</span>() == 0) cache-&gt;</span>incrementOccupied();</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">cache_t *getCache(Class <span class="keyword">cls</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(<span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="keyword">cls</span>-&gt;cache<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cache_key_t <span class="keyword">getKey</span>(SEL sel) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(sel)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> (cache_key_t)sel<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个方法没什么好说的，一个获取cache，一个获取sel的key，这里是把（char类型）sel转成了unsigned long，因为数字比char容易处理，且速度快。<br>cache-&gt;capacity() 方法：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mask_t cache_t::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>capacity 获取新的容量，在原基础上+1。</p>
<p>cache-&gt;reallocate方法：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">void cache_t:<span class="type"></span>:reallocate(mask_t oldCapacity, mask_t <span class="keyword">new</span><span class="type">Capacity</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bool freeOld = canBeFreed();</span><br><span class="line"></span><br><span class="line">    bucket_t *oldBuckets = buckets();</span><br><span class="line">    bucket_t *<span class="keyword">new</span><span class="type">Buckets</span> = allocateBuckets(<span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache's old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    assert(<span class="keyword">new</span><span class="type">Capacity</span> &gt; <span class="number">0</span>);</span><br><span class="line">    assert((uintptr_t)(mask_t)(<span class="keyword">new</span><span class="type">Capacity</span>-<span class="number">1</span>) == <span class="keyword">new</span><span class="type">Capacity</span>-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(<span class="keyword">new</span><span class="type">Buckets</span>, <span class="keyword">new</span><span class="type">Capacity</span> - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reallocate方法，开辟新空间，会把原来的内存都释放掉，也就是会把原来缓存的内容全部清除掉。</p>
<p>cache-&gt;expand方法：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">void cache_t:<span class="type"></span>:expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    uint32_t <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity ? oldCapacity*<span class="number">2</span> : <span class="type">INIT_CACHE_SIZE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uint32_t)(mask_t)<span class="keyword">new</span><span class="type">Capacity</span> != <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>expand是扩容方法，从代码中可以得知，如果原来的容量是0，则创建为4的新容量，如果不是0，则扩展为原来的两倍。扩容的时候会在最后一位插入key为1，值根据不同设备存不同的值。容量设置为4-1或者两倍-1。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> * <span class="keyword">cache_t</span>::<span class="built_in">find</span>(<span class="keyword">cache_key_t</span> k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = mask();</span><br><span class="line">    <span class="keyword">mask_t</span> <span class="built_in">begin</span> = cache_hash(k, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != <span class="built_in">begin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find方法找到对应当前sel的bucket，如果找不到获取一个空的bucket，如果没有空的则报错。这里其实有一个算法，所以每次遍历并不是从0开始的，所以每次缓存方法的时候的位置不是依次存储的，而是根据该算法有关。</p>
<p>小结：<br>知道了每个方法的作用，不难看出cache的机制，进来之后先判断cache是否为空，如果为空，创建空间为4的容量的缓存区。如果非空，且当前占据小于等于总容量的3/4,直接进行缓存，如果大于总容量3/4则进行扩容，扩容过程中会把之前的缓存清掉，然后将当前要缓存的进行缓存。</p>
<h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>以上只是一个读取类的数据结构的思路，这里主要是经过了内存地址读取，内存偏移，分析结构体等等，重要的是思路和过程，当然结果也重要，毕竟可以吹一波了！</p>
]]></content>
      <categories>
        <category>iOS底层探索系列</category>
      </categories>
      <tags>
        <tag>类的本质</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层探索系列--创建对象过程</title>
    <url>/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="一、查看alloc流程"><a href="#一、查看alloc流程" class="headerlink" title="一、查看alloc流程"></a>一、查看alloc流程</h2><p>编译一份objc_756的源码工程，在当前工程中创建自定义类，FLYPerson，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FLYPerson</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FLYPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : Hello!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"FLYPerson say : Happy!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在main.m函数中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        FLYPerson * person = [FLYPerson alloc];</span><br><span class="line">        Class pClass       = object_getClass(person);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ - %p"</span>, person, pClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将断点设在[FLYPerson alloc]这一行，运行程序，等断点来到此处，依次在NSObjcet.mm以下几处添加断点<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/objc_1.png" alt="断点列表1"><br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/objc_2.png" alt="断点列表2"><br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/objc_3.png" alt="断点列表3"><br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/objc_4.png" alt="断点列表4"><br>此时点击下一步，会发现，代码走到<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/objc_5.png" alt="断点列表5"><br>注意这里的参数，true和false，会影响到后面的代码走向。（LLVM做的一个优化，验证方法等有时间另开一篇文章讲述）</p>
<p>继续下一步，来到了断点列表4图中的callAlloc</p>
<ul>
<li>cls-&gt;ISA()-&gt;hasCustomAWZ() (检测该class是否有allocWithZone方法)此时为true</li>
</ul>
<p>最后会来到断点列表4图中1759这一行代码，继续下一步会走到断点列表3中的方法，继续下一步，依次经过_objc_rootAlloc，又来到了callAlloc，此时参数为false和true；</p>
<ul>
<li>如果此时FLYPerson中重写了allocWithZone方法，会走到1758行[cls allocWithZone:nil]中</li>
<li>如果此时FLYPerson中未重写allocWithZone方法，会来到1740行if (fastpath(cls-&gt;canAllocFast()))</li>
</ul>
<p>注意：</p>
<ul>
<li>cls-&gt;canAllocFast() 永远为false，可以comm点击去查看，最后是根据宏定义FAST_ALLOC是否定义，如果未定义，则返回false，查看FAST_ALLOC定义除，为写死的1，永远不定义FAST_ALLOC</li>
</ul>
<p>最后来到了如下代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id obj = class_createInstance(<span class="name">cls</span>, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">if (<span class="name">slowpath</span>(!obj)) return callBadAllocHandler(<span class="name">cls</span>)<span class="comment">;</span></span><br><span class="line">return obj<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>继续，走进class_createInstance</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">id </span><br><span class="line"><span class="keyword">class</span><span class="constructor">_createInstance(Class <span class="params">cls</span>, <span class="params">size_t</span> <span class="params">extraBytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return <span class="constructor">_class_createInstanceFromZone(<span class="params">cls</span>, <span class="params">extraBytes</span>, <span class="params">nil</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续会走到calloc-&gt;initInstanceIsa,最后返回。<br>这里的calloc需要编译另一个工程区查看，initInstanceIsa是初始化一些参数。<br>最后附上一张整体流程图<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/iOS%E4%B8%ADalloc%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p>
<h2 id="二、内存对齐"><a href="#二、内存对齐" class="headerlink" title="二、内存对齐"></a>二、内存对齐</h2><p>三条原则：</p>
<ul>
<li>1、数据成员对其原则：<br>结构（struct）（或联合体（union））的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置都要从该成员大小或者成员的子成员中占位最大（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始（比如int为4个字节，则要从4的整数倍地址开始存储）。</li>
<li>2、结构体作为成员：<br>如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。（struct a里存有struct b,b里有char，int，double等元素，那b应该从8的整数倍开始存储）。</li>
<li>3、最后<br>结构体的总大小，也就是sizeof的结构，必须是其内部最大成员的整数倍，不足的要补齐。</li>
</ul>
<p><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E2%80%94%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F.png" alt="不同平台数据内存占用"></p>
<p>demo代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FLYTeacher</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span>            age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span>            height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span>   *   name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span>   *   hobby;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">char</span>           des1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">char</span>           des2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FLYPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FLYTeacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a;   <span class="comment">// 占8位 0 - 7</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 占1位 8 - 9</span></span><br><span class="line">    <span class="keyword">int</span> c;      <span class="comment">// 占4位 12 - 15</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 占1位 16 - 17  补齐 7位</span></span><br><span class="line">&#125; FLYStruct1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a;  <span class="comment">// 占8位 0 - 7</span></span><br><span class="line">    <span class="keyword">int</span> c;     <span class="comment">// 占4位 8 - 11</span></span><br><span class="line">    <span class="keyword">char</span> b;    <span class="comment">// 占1位 11 - 12</span></span><br><span class="line">    <span class="keyword">char</span> d;    <span class="comment">// 占1位 12 - 13 补齐 3位</span></span><br><span class="line">&#125; FLYStruct2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"%lu - %lu"</span>, <span class="keyword">sizeof</span>(FLYStruct1),  <span class="keyword">sizeof</span>(FLYStruct2));</span><br><span class="line">        </span><br><span class="line">        FLYTeacher * p = [FLYTeacher alloc];</span><br><span class="line">        <span class="comment">// ISA             // 占用8位</span></span><br><span class="line">        p.age = <span class="number">18</span>;        <span class="comment">// 占用4位</span></span><br><span class="line">        p.<span class="built_in">height</span> = <span class="number">188</span>;    <span class="comment">// 占用4位</span></span><br><span class="line">        p.name   = @<span class="string">"eirc"</span>;<span class="comment">// 占用8位</span></span><br><span class="line">        p.hobby  = @<span class="string">"girl"</span>;<span class="comment">// 占用8位</span></span><br><span class="line">        <span class="comment">//des1             // 占用1位</span></span><br><span class="line">        <span class="comment">//des2             // 占用1位</span></span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"%lu - %lu"</span>, class_getInstanceSize([p class]), malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(p)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//总和： 34 因为内存对齐，为8的整数倍，所以 class_getInstanceSize([p class]) = 40。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log:<br>2019-12-28 11:47:32.964555+0800 FLYTest[6129:619837] 24 - 16<br>2019-12-28 11:47:32.965017+0800 FLYTest[6129:619837] 40 - 48</p>
<p>小结：</p>
<ul>
<li>至于结构体的大小，利用上面的三原则，以及结构体后面的注释，很容易解释。</li>
<li>对于oc中的对象，系统已经自动为对象的属性进行了最小内存占用排序，以减少内存占用。class_getInstanceSize获取class的内存占用，malloc_size获取系统为对象开辟的空间大小，可以看到系统为对象开辟的大小比对象实际占用大小大，这样做是为了安全考虑。</li>
</ul>
<p>这里需要查看calloc流程，通过上述过程，可以看到在calloc的时候，参数分别为1，40；<br>此时需要另外搭建一个libmalloc工程,在main函数中用以上参数，调用calloc函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">40</span>);</span><br><span class="line">    NSLog(@<span class="string">"%lu"</span>,malloc_size(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处应该一直点击下一步，因为内部代码有一个递归，在递归过程中，zone-&gt;calloc重新进行了指向<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E5%85%A5%E5%8F%A3.png" alt="计算开辟空间大小入口"><br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F.png" alt="计算开辟空间大小"><br>上图中SHIFT_NANO_QUANTUM宏定义是4，可以看到其实就是16位对齐，得出malloc_size是16位对齐的方式开辟空间。</p>
<h2 id="三、ISA"><a href="#三、ISA" class="headerlink" title="三、ISA"></a>三、ISA</h2><p>isa中存储着对象的属性，方法，类信息和引用计数等信息，可以说是一个对象的灵魂所在。</p>
<p>看一下创建ISA的入口：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> void </span><br><span class="line">objc_object:<span class="type"></span>:initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t <span class="keyword">new</span><span class="type">isa</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// This write must be performed in a single store in some cases</span></span><br><span class="line">        <span class="comment">// (for example when realizing a class because other threads</span></span><br><span class="line">        <span class="comment">// may simultaneously try to use the class).</span></span><br><span class="line">        <span class="comment">// fixme use atomics here to guarantee single-store and to</span></span><br><span class="line">        <span class="comment">// guarantee memory order w.r.t. the class index table</span></span><br><span class="line">        <span class="comment">// ...but not too atomic because we don't want to hurt instantiation</span></span><br><span class="line">        isa = <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISA的结构：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="comment">#if defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="regexp">//</span> defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ISA_BITFIELD</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">if</span> __arm64__</span><br><span class="line">#   define ISA_MASK        <span class="number">0x0000000ffffffff8</span>ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  <span class="number">0x000003f000000001</span>ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE <span class="number">0x000001a000000001</span>ULL</span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t extra_rc          : <span class="number">19</span></span><br><span class="line">#   define RC_ONE   (<span class="number">1</span>ULL&lt;&lt;<span class="number">45</span>)</span><br><span class="line">#   define RC_HALF  (<span class="number">1</span>ULL&lt;&lt;<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        <span class="number">0x00007ffffffffff8</span>ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  <span class="number">0x001f800000000001</span>ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE <span class="number">0x001d800000000001</span>ULL</span><br><span class="line">#   define ISA_BITFIELD                                                        \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t extra_rc          : <span class="number">8</span></span><br><span class="line">#   define RC_ONE   (<span class="number">1</span>ULL&lt;&lt;<span class="number">56</span>)</span><br><span class="line">#   define RC_HALF  (<span class="number">1</span>ULL&lt;&lt;<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"># <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>可以看到arm64中，1 + 1 + 1 + 33 + 6 + 1 + 1 + 1 + 19 = 64，刚好8位，x86同理。</p>
<p>注释：</p>
<ul>
<li>nonpointer : 表示是否对isa指针开启指针优化，0：纯指针，1：不止是类对象地址，isa中包含了类信息，对象的引用计数等。</li>
<li>has_assoc  : 关联对象标志位，0：没有，1：存在</li>
<li>has_cxx_dtor : 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象</li>
<li>shiftcls : 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li>
<li>magic:用于调试器判断当前对象是真的对象还是没有初始化的空间。</li>
<li>weakly_referenced : 标志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。 </li>
<li>deallocating : 标志对象是否正在释放内存。</li>
<li>has_sidetable_rc : 当对象引用技术大于 10 时，则需要借用该变量存储进位。</li>
<li>extra_rc : 当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li>
</ul>
<p>总结：</p>
<ul>
<li>isa中重要的信息都存放在shiftcls中，怎么快速获取shiftcls，就是用上面提供的掩码ISA_MASK，用掩码与isa进行与运算，结果就是shiftcls。</li>
</ul>
<p>扩展：<br>这里用了位，比我们平常用的int和bool值快很多，因为位数少了很多，比如int占4个字节，arm64中就是4 * 8 = 32位，浪费了很多空间，同样效率也降低了。</p>
<p>最后放一张isa流程图：<br><img src="/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97--%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/isa%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="isa流程图"><br>总结：</p>
<ul>
<li>对象的isa是类（类对象在内存中只有一份），类的isa是其元类，该元类的isa是NSObject的元类。NSObject的元类的isa是其自身。</li>
<li>元类的父类是该类的父类的元类。NSObject的元类的父类是NSObject类。NSObject类的父类是nil。</li>
</ul>
]]></content>
      <categories>
        <category>iOS底层探索系列</category>
      </categories>
      <tags>
        <tag>创建对象过程</tag>
      </tags>
  </entry>
  <entry>
    <title>CGContextRef详解</title>
    <url>/CGContextRef%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<p>原文出处 <a href="http://blog.csdn.net/u014286994/article/details/51333118" target="_blank" rel="noopener">http://blog.csdn.net/u014286994/article/details/51333118</a></p>
<p>CoreGraphics - CGContext.h<br>Graphics state functions.<br>//为了让开发者在进行坐标变换时无须计算多次坐标变换后的累加结果，Quartz 2D还提供了如下两个方法来保存、恢复绘图状态</p>
<p>1、 保存CGContextRef当前的绘图状态，方便以后恢复该状态<br>void CGContextSaveGState(CGContextRef__nullable c)<br>需要说明的是，CGContextSaveGState()函数保存的绘图状态，不仅包括当前坐标系统的状态，也包括当前设置的填充风格、线条风格、阴影风格等各种绘图状态。但 CGContextSaveGState()函数不会保存当前绘制的图形</p>
<p>2、 把CGContextRef的状态恢复到最近一次保存时的状态<br>void CGContextRestoreGState(CGContextRef__nullable c)</p>
<p>3、 缩放坐标系统</p>
<p>该方法控制坐标系统水平方向上缩放 sx，垂直方向上缩放 sy。在缩放后的坐标系统上绘制图形时，所有点的 X 坐标都相当于乘以 sx 因子，所有点的 Y 坐标都相当于乘以 sy因子。<br>void CGContextScaleCTM(CGContextRef__nullable c, CGFloat sx, CGFloat sy)</p>
<p>4、 平移坐标系统</p>
<p> 该方法相当于把原来位于 (0, 0) 位置的坐标原点平移到 (tx, ty)点。在平移后的坐标系统上绘制图形时，所有坐标点的 X坐标都相当于增加了 tx，所有点的 Y坐标都相当于增加了 ty。</p>
<p>void CGContextTranslateCTM(CGContextRef__nullable c, CGFloat tx, CGFloat ty)</p>
<p>5、 旋转坐标系统</p>
<p> 该方法控制坐标系统旋转 angle 弧度。在缩放后的坐标系统上绘制图形时，所有坐标点的 X、Y坐标都相当于旋转了 angle弧度之后的坐标。</p>
<p>void CGContextRotateCTM(CGContextRef__nullable c, CGFloat angle)</p>
<p>6、使用 transform变换矩阵对 CGContextRef的坐标系统执行变换，通过使用坐标矩阵可以对坐标系统执行任意变换。</p>
<p>void CGContextConcatCTM(CGContextRef__nullable c, CGAffineTransform transform)</p>
<p>7、获取CGContextRef的坐标系统的变换矩阵</p>
<p>CGAffineTransform CGContextGetCTM(CGContextRef__nullable c)</p>
<p>8、设置绘制直线、边框时的线条宽度</p>
<p>void CGContextSetLineWidth(CGContextRef__nullable c, CGFloat width)</p>
<p>9、 设置线段端点的绘制形状。该属性支持如下三个值。</p>
<p>typedef CF_ENUM(int32_t, CGLineCap) {<br>    kCGLineCapButt, //该属性值指定不绘制端点，线条结尾处直接结束。这是默认值。<br>    kCGLineCapRound,//该属性值指定绘制圆形端点，线条结尾处绘制一个直径为线条宽度的半圆。<br>    kCGLineCapSquare//该属性值指定绘制方形端点。线条结尾处绘制半个边长为线条宽度的正方形。需要说明的是，这种形状的端点与“butt”形状的端点十分相似，只是采用这种形式的端点的线条略长一点而已<br>};</p>
<p>void CGContextSetLineCap(CGContextRef__nullable c, CGLineCap cap)</p>
<p>10、  设置线条连接点的风格，该属性支持三个值：<br>typedef CF_ENUM(int32_t, CGLineJoin) {</p>
<pre><code>kCGLineJoinMiter, // 这是默认的属性值。该方格的连接点形状如图1所示。

kCGLineJoinRound, // 稍微圆角, 该方格的连接点形状如图2所示。

kCGLineJoinBevel  // 斜角,该方格的连接点形状如图3所示。</code></pre><p>};</p>
<p>void CGContextSetLineJoin(CGContextRef__nullable c, CGLineJoin join)</p>
<p>11、 当把连接点风格设为meter风格时，该方法用于控制锐角箭头的长度</p>
<p>void CGContextSetMiterLimit(CGContextRef__nullable c, CGFloat limit)</p>
<p>12、 Linedash pattern(虚线模式)允许我们沿着描边绘制虚线。我们通过在CGContextSetLineDash结构体中指定虚线数组和虚线相位来控制虚线的大小及位置。</p>
<p>其中lengths属性指定了虚线段的长度，该值是在绘制片断与未绘制片断之间交替。phase属性指定虚线模式的起始点。图3-11显示了虚线模式：</p>
<p>void CGContextSetLineDash(CGContextRef__nullable c, CGFloat phase,const CGFloat *__nullable lengths, size_t count)</p>
<p>13、 设置弯曲的路径中的图形上下文的准确性。</p>
<p>void CGContextSetFlatness(CGContextRef__nullable c, CGFloat flatness)</p>
<p>14、 设置全局透明度</p>
<p>void CGContextSetAlpha(CGContextRef__nullable c, CGFloat alpha)</p>
<p>15、 设置CGContextRef的叠加模式。Quartz 2D支持多种叠加模</p>
<p>void CGContextSetBlendMode(CGContextRef __nullable c, CGBlendMode mode)</p>
<p>16、 开始创建路径. </p>
<p>void CGContextBeginPath(CGContextRef__nullable c)</p>
<p>17、 开始一个新的子路径点 </p>
<p>void CGContextMoveToPoint(CGContextRef__nullable c, CGFloat x, CGFloat y)</p>
<p>18、添加一条直线段从当前指向的(x,y)。 </p>
<p>void CGContextAddLineToPoint(CGContextRef__nullable c, CGFloat x, CGFloat y)</p>
<p>19、 从当前添加一个三次Bezier曲线</p>
<p>cp1x 控制点1 x坐标   cp1y 控制点1 y坐标<br>cp2x 控制点2 x坐标   cp2y 控制点2 y坐标<br>x    直线的终点 x坐标 y    直线的终点 y坐标</p>
<p>void CGContextAddCurveToPoint(CGContextRef__nullable c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)    </p>
<p>20、 从当前添加一个二次Bezier曲线<br>cpx 控制点 x坐标      cpy 控制点 y坐标<br>x   直线的终点 x坐标  y   直线的终点 y坐标<br>void CGContextAddQuadCurveToPoint(CGContextRef__nullable c, CGFloat cpx, CGFloat cpy,CGFloat x,CGFloat y)</p>
<p>21、 关闭当前上下文的子路径,且当前点和起点连接起来<br>void CGContextClosePath(CGContextRef__nullable c)</p>
<p>22、 添加一个矩形路径<br>void CGContextAddRect(CGContextRef__nullable c, CGRect rect)</p>
<p>23、 添加多个矩形路径 </p>
<p>void CGContextAddRects(CGContextRef__nullable c, const CGRect * __nullable rects, size_t count)</p>
<p>24、 添加多条直线路径</p>
<p>void CGContextAddLines(CGContextRef__nullable c, const CGPoint * __nullable points, size_t count)</p>
<p>25、 根据一个矩形,绘制椭圆（圆形 </p>
<p>void CGContextAddEllipseInRect(CGContextRef__nullable c, CGRect rect)</p>
<p>26、 添加弧形对象<br> x          中心点x坐标       y          中心点y坐标<br> radius     半径             startAngle 起始弧度<br> endAngle   终止弧度          clockwise  是否逆时针绘制，0则顺时针绘制</p>
<p>void CGContextAddArc(CGContextRef__nullable c, CGFloat x,CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle,int clockwise)</p>
<p>27、 这个函数使用一个序列的三次贝塞尔曲线创建一个弧<br> 原理:首先画两条线，这两条线分别是 current point to (x1,y1)和(x1,y1) to (x2,y2).这样就是出现一个以(x1,y1)为顶点的两条射线，然后定义半径长度，这个半径是垂直于两条射线的，这样就能决定一个圆了，如果当前点和第一个切点的弧(起点)是不平等的,那么会添加一条直线段从当前指向第一个切点。弧的终点成为新的当前点的路径。<br>void CGContextAddArcToPoint(CGContextRef__nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) </p>
<p>28、 添加路径到图形上下文<br>void CGContextAddPath(CGContextRef__nullable c, CGPathRef__nullable path)</p>
<p>29、 使用绘制当前路径时覆盖的区域作为当前CGContextRef中的新路径。举例来说，假如当前CGContextRef包含一个圆形路径且线宽为10，调用该方法后，当前CGContextRef将包含一个环宽为10的环形路径</p>
<p>void CGContextReplacePathWithStrokedPath(CGContextRef__nullable c)</p>
<p>30、表示目前的路径是否包含任何的子路径 </p>
<p>bool CGContextIsPathEmpty(CGContextRef__nullable c)</p>
<p>31、 返回一个非空的路径中的当前点。 </p>
<p>CGPoint CGContextGetPathCurrentPoint(CGContextRef__nullable c)</p>
<p>32、 返回包含当前路径的最小矩形。</p>
<p>CGRect CGContextGetPathBoundingBox(CGContextRef__nullable c)</p>
<p>33、 Return a copy of the path of <code>context&#39;. The returned path is specified in the current user space of</code>context’.<br>CGPathRef <strong>nullable CGContextCopyPath(CGContextRef</strong>nullable c)</p>
<p>34、 检查当前路径中是否包含指定的点。 </p>
<p>bool CGContextPathContainsPoint(CGContextRef__nullable c, CGPoint point, CGPathDrawingMode mode)</p>
<p>35、使用指定模式绘制当前CGContextRef中所包含的路径。CGPathDrawingMode 属性如上</p>
<p>typedef CF_ENUM (int32_t, CGPathDrawingMode) {</p>
<p>  kCGPathFill,//只有填充（非零缠绕数填充），不绘制边框  如图1</p>
<p>  kCGPathEOFill,//奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）如图2</p>
<p>  kCGPathStroke,        // 只有边框  如图3</p>
<p>  kCGPathFillStroke,    // 既有边框又有填充  如图4</p>
<p>  kCGPathEOFillStroke   // 奇偶填充并绘制边框  如图5</p>
<p>};</p>
<p>void CGContextDrawPath(CGContextRef__nullable c, CGPathDrawingMode mode)</p>
<p>36、 填充该路径包围的区域</p>
<p>void CGContextFillPath(CGContextRef__nullable c)</p>
<p>37、使用奇偶规则来填充该路径包围的区域。奇偶规则指：如果某个点被路径包围了奇数次，系统绘制该点；如果被路径包围了偶数次，系统不绘制</p>
<p>void CGContextEOFillPath(CGContextRef__nullable c)</p>
<p>38、使用当前 CGContextRef设置的线宽绘制路径</p>
<p>void CGContextStrokePath(CGContextRef__nullable c)</p>
<p>38、填充rect代表的矩形</p>
<p>void CGContextFillRect(CGContextRef__nullable c, CGRect rect)</p>
<p>39、填充多个矩形<br>void CGContextFillRects(CGContextRef__nullable c, const CGRect * __nullable rects, size_t count)</p>
<p>40、使用当前 CGContextRef设置的线宽绘制矩形框</p>
<p>void CGContextStrokeRect(CGContextRef__nullable c, CGRect rect)</p>
<p>41、使用指定线宽绘制矩形框</p>
<p>void CGContextStrokeRectWithWidth(CGContextRef__nullable c, CGRect rect, CGFloat width)</p>
<p>42、擦除指定矩形区域上绘制的图形</p>
<p>void CGContextClearRect(CGContextRef__nullable c, CGRect rect)</p>
<p>43、填充rect矩形的内切椭圆区域</p>
<p>void CGContextFillEllipseInRect(CGContextRef__nullable c, CGRect rect)</p>
<p>44、使用当前 CGContextRef设置的线宽绘制rect矩形的内切椭圆</p>
<p>void CGContextStrokeEllipseInRect(CGContextRef__nullable c, CGRect rect)</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     CGContextBeginPath(<span class="name">context</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">     for (<span class="name">k</span> = <span class="number">0</span><span class="comment">; k &lt; count; k += 2) &#123;</span></span><br><span class="line"></span><br><span class="line">       CGContextMoveToPoint(<span class="name">context</span>, s[k].x, s[k].y)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">       CGContextAddLineToPoint(<span class="name">context</span>, s[k+1].x, s[k+1].y)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     CGContextStrokePath(<span class="name">context</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>45、 使用当前 CGContextRef设置的线宽绘制多条线段。该方法需要传入2N个CGPoint组成的数组，其中1、2个点组成第一条线段，3、4个点组成第2条线段，以此类推<br>void CGContextStrokeLineSegments(CGContextRef__nullable c, const CGPoint * __nullable points, size_t count)</p>
<p>46、 修改当前剪贴路径，使用非零绕数规则。 </p>
<p>void CGContextClip(CGContextRef__nullable c)</p>
<p>47、 修改当前剪贴路径，使用奇偶规则。 </p>
<p>void CGContextEOClip(CGContextRef__nullable c)</p>
<p>48、  剪切遮罩处理(针对图片）</p>
<p>void CGContextClipToMask(CGContextRef__nullable c, CGRect rect, CGImageRef__nullable mask)</p>
<p>49、 获取到了需要绘制的图形上下文的位置与大小</p>
<p>CGRect CGContextGetClipBoundingBox(CGContextRef__nullable c)</p>
<p>50、 剪切指定矩形区域外的部分. </p>
<p>void CGContextClipToRect(CGContextRef__nullable c, CGRect rect)</p>
<p>51、 剪切指定多个矩形区域外的部分 </p>
<p>void CGContextClipToRects(CGContextRef__nullable c,const CGRect *  rects, size_t count)</p>
<p>/** Primitive color functions. */</p>
<p>52、使用指定颜色来设置该CGContextRef的填充颜色</p>
<p>void CGContextSetFillColorWithColor(CGContextRef__nullable c, CGColorRef __nullable color)</p>
<p>53、使用指定颜色来设置该CGContextRef的线条颜色</p>
<p>void CGContextSetStrokeColorWithColor(CGContextRef__nullable c, CGColorRef __nullable color)</p>
<p>/** Color space functions. *</p>
<p>54、 颜色空间填充 </p>
<p>void CGContextSetFillColorSpace(CGContextRef__nullable c, CGColorSpaceRef__nullable space)</p>
<p>55、 设置线框颜色空间 </p>
<p>void CGContextSetStrokeColorSpace(CGContextRef__nullable c, CGColorSpaceRef __nullable space)</p>
<p>/** Color functions. *</p>
<p>56、 设置填充颜色空间 CGFloat redColor[4] = {1.0,0,0,1.0};</p>
<p>void CGContextSetFillColor(CGContextRef__nullable c,const CGFloat *__nullable components(redColor))</p>
<p>57、 设置画笔颜色 CGFloat redColor[4] = {1.0,0,0,1.0};</p>
<p>void CGContextSetStrokeColor(CGContextRef__nullable c,const CGFloat *__nullable components(redColor))</p>
<p>/** Pattern functions. *</p>
<p>58、设置该CGContextRef使用位图填充</p>
<p>void CGContextSetFillPattern(CGContextRef__nullable c, CGPatternRef__nullable pattern,const CGFloat * __nullable components)</p>
<p>59、设置该CGContextRef使用位图绘制线条、边框</p>
<p>void CGContextSetStrokePattern(CGContextRef__nullable c, CGPatternRef__nullable pattern,const CGFloat * __nullable components)</p>
<p>60、设置该CGContextRef采用位图填充的相位</p>
<p>void CGContextSetPatternPhase(CGContextRef__nullable c, CGSize phase)</p>
<p>/** Color convenience functions. *</p>
<p>61、使用灰色来设置该CGContextRef的填充颜色</p>
<p>void CGContextSetGrayFillColor(CGContextRef__nullable c, CGFloat gray, CGFloat alpha)</p>
<p>62、使用灰色来设置该CGContextRef的线条颜色</p>
<p>void CGContextSetGrayStrokeColor(CGContextRef__nullable c, CGFloat gray, CGFloat alpha)</p>
<p>63、使用RGB颜色模式来设置该CGContextRef的填充颜色</p>
<p>void CGContextSetRGBFillColor(CGContextRef__nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)</p>
<p>64、 设置画笔颜色 </p>
<p>void CGContextSetRGBStrokeColor(CGContextRef__nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)</p>
<p>65、使用CMYK颜色模式来设置该CGContextRef的填充颜色</p>
<p>void CGContextSetCMYKFillColor(CGContextRef__nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)</p>
<p>66、 使用CMYK颜色模式来设置该CGContextRef的线条颜色</p>
<p>void CGContextSetCMYKStrokeColor(CGContextRef__nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)</p>
<p>/** Rendering intent. *</p>
<p>67、 在当前图形状态设置渲染意向 </p>
<p>void CGContextSetRenderingIntent(CGContextRef__nullable c, CGColorRenderingIntent intent)</p>
<p>/** Image functions. *</p>
<p>68、 绘制图像到图形上下文中 </p>
<p>void CGContextDrawImage(CGContextRef__nullable c, CGRect rect, CGImageRef __nullable image)</p>
<p>69、 重复绘制的图像，扩展到提供的矩形，填补当前剪辑区域。 </p>
<p>void CGContextDrawTiledImage(CGContextRef__nullable c, CGRect rect, CGImageRef __nullable image)</p>
<p>70、 获取当前CGContextRef在放大图片时的插值质量</p>
<p>CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef__nullable c)</p>
<p>71、设置图形上下文的插值质量水平。</p>
<p>void CGContextSetInterpolationQuality(CGContextRef__nullable c, CGInterpolationQuality quality)</p>
<p>/** Shadow support. *</p>
<p>72、设置阴影在X、Y方向上的偏移，以及模糊度和阴影的颜色</p>
<p>void CGContextSetShadowWithColor(CGContextRef__nullable c, CGSize offset, CGFloat blur, CGColorRef __nullable color)</p>
<p>73、设置阴影在X、Y方向上的偏移，以及模糊度（blur值越大，阴影越模糊）。该函数没有设置阴影颜色，默认使用1/3透明的黑色（即RGBA{0, 0, 0, 1.0/3.0}）作为阴影颜色</p>
<p>void CGContextSetShadow(CGContextRef__nullable c, CGSize offset, CGFloat blur)</p>
<p>/** Gradient and shading functions. *</p>
<p>74、 绘制一个渐变填充定义的出发点和落脚点沿线变化。</p>
<p>void CGContextDrawLinearGradient(CGContextRef__nullable c, CGGradientRef __nullable gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)</p>
<p>75、 绘制一个沿着由所提供的开始和结束的圆限定的区域变化的渐变填充。 </p>
<p>void CGContextDrawRadialGradient(CGContextRef__nullable c, CGGradientRef __nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options)</p>
<p>76、 使用指定的阴影的背景，填充剪切路径。<br>void CGContextDrawShading(CGContextRef __nullable c, __nullable CGShadingRef shading)</p>
<p>/** Text functions. *</p>
<p>77、 设置当前字符间距. </p>
<p>void CGContextSetCharacterSpacing(CGContextRef__nullable c, CGFloat spacing)</p>
<p>78、 设置要绘制文本的位置。 </p>
<p>void CGContextSetTextPosition(CGContextRef__nullable c, CGFloat x, CGFloat y)</p>
<p>79、 返回在绘制文本的位置。 </p>
<p>CGPoint CGContextGetTextPosition(CGContextRef __nullable c)</p>
<p>80、 设置当前文本矩阵。 </p>
<p>void CGContextSetTextMatrix(CGContextRef__nullable c, CGAffineTransform t)</p>
<p>81、返回当前文本矩阵。 </p>
<p>CGAffineTransform CGContextGetTextMatrix(CGContextRef__nullable c)</p>
<p>82、 设置当前文本的绘图模式。 </p>
<p>void CGContextSetTextDrawingMode(CGContextRef__nullable c, CGTextDrawingMode mode)</p>
<p>83、 设置上下文的字体 </p>
<p>void CGContextSetFont(CGContextRef__nullable c, CGFontRef __nullable font)</p>
<p>84、 设置上下文的字体大小。 </p>
<p>void CGContextSetFontSize(CGContextRef__nullable c, CGFloat size)</p>
<p>85、 在所提供的位置绘制字形。 </p>
<p>void CGContextShowGlyphsAtPositions(CGContextRef__nullable c, const CGGlyph * __nullable glyphs, const CGPoint * __nullable Lpositions, size_t count)</p>
<p>/** PDF functions. *</p>
<p>86、 绘制一个PDF页面到当前的用户空间。 </p>
<p>void CGContextDrawPDFPage(CGContextRef__nullable c, CGPDFPageRef __nullable page)</p>
<p>/** Output page functions. *</p>
<p>87、 基于页面的图形上下文中开始了新的一页。 </p>
<p>void CGContextBeginPage(CGContextRef__nullable c,const CGRect *__nullable mediaBox)</p>
<p>88、 在基于页面的图形上下文结束当前的页面。 </p>
<p>void CGContextEndPage(CGContextRef__nullable c)</p>
<p>/** Context functions. *</p>
<p>89、 图形上下文的引用计数+1 </p>
<p>CGContextRef <strong>nullableCGContextRetain(CGContextRef</strong>nullable c)</p>
<p>90、 图形上下文的引用计数-1. </p>
<p>void CGContextRelease(CGContextRef__nullable c)</p>
<p>91、 强制所有挂起的绘图操作在一个窗口上下文中立即被渲染到目标设备 </p>
<p>void CGContextFlush(CGContextRef__nullable c)</p>
<p>92、 将一个窗口的图像上下文内容更新，即所有的绘图操作都会在下次同步到窗口上. </p>
<p>void CGContextSynchronize(CGContextRef__nullable c)</p>
<p>/** Antialiasing functions. *</p>
<p>93、设置该CGContextRef是否应该抗锯齿（即光滑图形曲线边缘）</p>
<p>void CGContextSetShouldAntialias(CGContextRef__nullable c, bool shouldAntialias)</p>
<p>94、设置该CGContextRef是否允许抗锯齿<br>void CGContextSetAllowsAntialiasing(CGContextRef__nullable c, bool allowsAntialiasing)</p>
<p>/** Font display functions. *</p>
<p>95、设置该CGContextRef是否允许光滑字体<br>void CGContextSetShouldSmoothFonts(CGContextRef__nullable c, bool shouldSmoothFonts)</p>
<p>96、设置该CGContextRef是否允许光滑字体<br>void CGContextSetAllowsFontSmoothing(CGContextRef__nullable c, bool allowsFontSmoothing)</p>
<p>97、 Enables or disables subpixel positioning in a graphics context.<br>void CGContextSetShouldSubpixelPositionFonts(CGContextRef __nullable c, bool shouldSubpixelPositionFonts)</p>
<p>98、 Sets whether or not to allow subpixel positioning for a graphics context<br>void CGContextSetAllowsFontSubpixelPositioning(CGContextRef __nullable c, bool allowsFontSubpixelPositioning)</p>
<p>99、 Enables or disables subpixel quantization in a graphics context.<br>void CGContextSetShouldSubpixelQuantizeFonts(CGContextRef __nullable c, bool shouldSubpixelQuantizeFonts)</p>
<p>100、 Sets whether or not to allow subpixel quantization for a graphics context<br>void CGContextSetAllowsFontSubpixelQuantization(CGContextRef __nullable c, bool allowsFontSubpixelQuantization)</p>
<p>/** Transparency layer support. *</p>
<p>101、 开始一个透明层。<br>直到相应的调用CGContextEndTransparencyLayer，在指定范围内的所有后续绘制操作组合到一个完全透明的背景（它被视为一个单独的目标缓冲区从上下文）。<br>在透明层中绘制需要三步：</p>
<ol>
<li>调用函数 CGContextBeginTransparencyLayer</li>
<li>在透明层中绘制需要组合的对象</li>
<li>调用函数 CGContextEndTransparencyLayer</li>
</ol>
<p>void CGContextBeginTransparencyLayer(CGContextRef__nullable c, CFDictionaryRef __nullable auxiliaryInfo)</p>
<p>102、 开始透明度层，它的边界是指定的矩形，其内容是有界的。<br>void CGContextBeginTransparencyLayerWithRect(CGContextRef <strong>nullable c, CGRect rect, CFDictionaryRef</strong>nullable auxInfo)</p>
<p>103、 结束一个透明层。<br>void CGContextEndTransparencyLayer(CGContextRef__nullable c)</p>
<p>/** User space to device space tranformations. *</p>
<p>104、  获取Quartz转换用户空间和设备空间的仿射变换<br>CGAffineTransform CGContextGetUserSpaceToDeviceSpaceTransform(CGContextRef__nullable c)</p>
<p>105、 将一个CGPoint数据结构从一个空间变换到另一个空间(DeviceSpace).<br>CGPoint CGContextConvertPointToDeviceSpace(CGContextRef__nullable c, CGPoint point)</p>
<p>106、 将一个CGPoint数据结构从一个空间变换到另一个空间(UserSpace). </p>
<p>CGPoint CGContextConvertPointToUserSpace(CGContextRef__nullable c, CGPoint point)</p>
<p>107、 将一个CGSize数据结构从一个空间变换到另一个空间(DeviceSpace).<br>CGSize CGContextConvertSizeToDeviceSpace(CGContextRef__nullable c, CGSize size)</p>
<p>108、 将一个CGSize数据结构从一个空间变换到另一个空间(UserSpace).<br>CGSize CGContextConvertSizeToUserSpace(CGContextRef__nullable c, CGSize size)</p>
<p>109、 将一个CGPoint数据结构从一个空间变换到另一个空间(DeviceSpace)。<br>CGRect CGContextConvertRectToDeviceSpace(CGContextRef__nullable c, CGRect rect)</p>
<p>110、 将一个CGPoint数据结构从一个空间变换到另一个空间(UserSpace)。<br>CGRect CGContextConvertRectToUserSpace(CGContextRef__nullable c, CGRect rect)</p>
<p>111、 设置在一个图形上下文的字体和字体大小<br>void CGContextSelectFont(CGContextRef__nullable c, const char *__nullable name, CGFloat size, CGTextEncoding textEncoding)</p>
<p>112、 在当前文本位置，由目前的文本矩阵指定的点显示一个字符数组。<br>void CGContextShowText(CGContextRef__nullable c, const char *__nullable string, size_t length)</p>
<p>113、 在指定的位置显示一个字符串。<br>void CGContextShowTextAtPoint(CGContextRef__nullable c, CGFloat x, CGFloat y, const char * __nullable string, size_t length)</p>
<p>114、 在当前文本位置显示一个数组的字形。<br>void CGContextShowGlyphs(CGContextRef__nullable c, const CGGlyph * __nullable g, size_t count)</p>
<p>115、 在指定的位置显示一个数组的字形。<br>void CGContextShowGlyphsAtPoint(CGContextRef__nullable c, CGFloat x, CGFloat y, const CGGlyph * __nullable glyphs, size_t count)</p>
<p>116、 绘制具有不同的偏移量的一个数组字形。<br>void CGContextShowGlyphsWithAdvances(CGContextRef__nullable c, const CGGlyph * __nullable glyphs, const CGSize * __nullable advances, size_t count)</p>
<p>117、 DEPRECATED; use the CGPDFPage API instead.<br>void CGContextDrawPDFDocument(CGContextRef__nullable c, CGRect rect, CGPDFDocumentRef__nullable document,int page)</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>绘制</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="一、为什么使用正则表达式？"><a href="#一、为什么使用正则表达式？" class="headerlink" title="一、为什么使用正则表达式？"></a>一、为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。<br>通过使用正则表达式，可以：</p>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
<p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p>
<h2 id="二、发展历史"><a href="#二、发展历史" class="headerlink" title="二、发展历史"></a>二、发展历史</h2><p>正则表达式的”祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。<br>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为”神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为”正则集的代数”的表达式，因此采用”正则表达式”这个术语。<br>随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。<br>如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。</p>
<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><h3 id="3-1、普通字符"><a href="#3-1、普通字符" class="headerlink" title="3.1、普通字符"></a>3.1、普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h3 id="3-2、非打印字符"><a href="#3-2、非打印字符" class="headerlink" title="3.2、非打印字符"></a>3.2、非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="3-3、特殊字符"><a href="#3-3、特殊字符" class="headerlink" title="3.3、特殊字符"></a>3.3、特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo<em>b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 : runo\</em>ob 匹配 runo*ob。<br>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">特别字符        描述 </span><br><span class="line">$              匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '<span class="symbol">\n</span>' 或 '<span class="symbol">\r</span>'。要匹配 $ 字符本身，请使用 <span class="symbol">\$</span>。</span><br><span class="line">( )            标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <span class="symbol">\(</span> 和 <span class="symbol">\)</span>。</span><br><span class="line">*              匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 <span class="symbol">\*</span>。</span><br><span class="line">+              匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <span class="symbol">\+</span>。</span><br><span class="line">.              匹配除换行符 <span class="symbol">\n</span> 之外的任何单字符。要匹配 . ，请使用 <span class="symbol">\.</span> 。</span><br><span class="line">[              标记一个中括号表达式的开始。要匹配 [，请使用 <span class="symbol">\[</span>。</span><br><span class="line">?              匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 <span class="symbol">\?</span>。 |</span><br><span class="line"><span class="symbol">\ </span>             将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'<span class="symbol">\n</span>' 匹配换行符。序列 '<span class="symbol">\\</span>' 匹配 "<span class="symbol">\"</span>，而 '<span class="symbol">\(</span>' 则匹配 "("。</span><br><span class="line">^              匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <span class="symbol">\^</span>。</span><br><span class="line">&#123;              标记限定符表达式的开始。要匹配 &#123;，请使用 <span class="symbol">\&#123;</span>。</span><br><span class="line">|              指明两项之间的一个选择。要匹配 |，请使用 <span class="symbol">\|</span>。</span><br></pre></td></tr></table></figure>

<h3 id="3-4、限定符"><a href="#3-4、限定符" class="headerlink" title="3.4、限定符"></a>3.4、限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p>由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]*/</span><br></pre></td></tr></table></figure>
<p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。<br>这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。<br>如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。<br>/Chapter [0-9]{1,2}/<br>上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]?/</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;/</span><br></pre></td></tr></table></figure>
<p>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。<br>例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>Chapter 1 - 介绍正则表达式<span class="tag">&lt;/<span class="name">H1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">.*</span>&gt;</span>/</span><br></pre></td></tr></table></figure>
<p><strong>非贪婪</strong>：如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 H1 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">.*?</span>&gt;</span>/</span><br></pre></td></tr></table></figure>

<p>如果只想匹配开始的 H1 标签，表达式则是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">\w+?</span>&gt;</span>/</span><br></pre></td></tr></table></figure>
<p>通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>
<h3 id="3-5、定位符"><a href="#3-5、定位符" class="headerlink" title="3.5、定位符"></a>3.5、定位符</h3><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。<br>定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。<br>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配。</td>
</tr>
</tbody></table>
<p>注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。<br>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。<br>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。<br>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/^Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;/</span><br></pre></td></tr></table></figure>
<p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/^Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
<p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/\bCha/</span></span><br></pre></td></tr></table></figure>
<p><strong>\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/ter\b/</span></span><br></pre></td></tr></table></figure>
<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/\Bapt/</span></span><br></pre></td></tr></table></figure>
<p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>
<h3 id="3-6、选择"><a href="#3-6、选择" class="headerlink" title="3.6、选择"></a>3.6、选择</h3><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 <strong>?</strong>: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>
<h3 id="3-7、反向引用"><a href="#3-7、反向引用" class="headerlink" title="3.7、反向引用"></a>3.7、反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。<br>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>
<p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：<br>Is is the cost of of gasoline going up up?<br>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p>
<p>实例<br>查找重复的单词：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Is is the cost of of gasoline going up up"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/\b([a-z]+) \1\b/ig</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(patt1));</span><br></pre></td></tr></table></figure>

<p>捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。<br>单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。<br>正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。<br>表达式的结尾处的不区分大小写 i 标记指定不区分大小写。<br>多行标记指定换行符的两边可能出现潜在的匹配。<br>反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.runoob.com:<span class="number">80</span><span class="regexp">/html/</span>html-tutorial.html</span><br></pre></td></tr></table></figure>
<p>下面的正则表达式提供该功能：</p>
<p>实例<br>输出所有匹配的数据：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.runoob.com:80/html/html-tutorial.html"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/(\w+):\/\/([^/</span>:]+)(:<span class="string">\d*)?([^#</span> ]*)/;</span><br><span class="line">arr = str.match(patt1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(arr[i]);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。<br>第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。<br>第二个括号子表达式捕获地址的域地址部分。子表达式匹配 : 和 / 之后的一个或多个字符。<br>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。<br>最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。<br>将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：</p>
<ul>
<li>第一个括号子表达式包含 http</li>
<li>第二个括号子表达式包含 <a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a></li>
<li>第三个括号子表达式包含 :80</li>
<li>第四个括号子表达式包含 /html/html-tutorial.html</li>
</ul>
<h2 id="四、元字符"><a href="#四、元字符" class="headerlink" title="四、元字符"></a>四、元字符</h2><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">字符            描述</span><br><span class="line"><span class="string">\</span>              将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<span class="string">'n'</span> 匹配字符 <span class="string">"n"</span>。<span class="string">'\n'</span> 匹配一个换行符。序列 <span class="string">'\\'</span> 匹配 <span class="string">"\" 而 "</span><span class="string">\("</span> 则匹配 <span class="string">"("</span>。</span><br><span class="line">^              匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 <span class="string">'\n'</span> 或 <span class="string">'\r'</span> 之后的位置。</span><br><span class="line">$匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 <span class="string">'\n'</span> 或 <span class="string">'\r'</span> 之前的位置。</span><br><span class="line">*              匹配前面的子表达式零次或多次。例如，zo* 能匹配 <span class="string">"z"</span> 以及 <span class="string">"zoo"</span>。* 等价于&#123;<span class="number">0</span>,&#125;。</span><br><span class="line">+              匹配前面的子表达式一次或多次。例如，<span class="string">'zo+'</span> 能匹配 <span class="string">"zo"</span> 以及 <span class="string">"zoo"</span>，但不能匹配 <span class="string">"z"</span>。+ 等价于 &#123;<span class="number">1</span>,&#125;。</span><br><span class="line">?              匹配前面的子表达式零次或一次。例如，<span class="string">"do(es)?"</span> 可以匹配 <span class="string">"do"</span> 或 <span class="string">"does"</span> 。? 等价于 &#123;<span class="number">0</span>,<span class="number">1</span>&#125;。</span><br><span class="line">&#123;n&#125;            n 是一个非负整数。匹配确定的 n 次。例如，<span class="string">'o&#123;2&#125;'</span> 不能匹配 <span class="string">"Bob"</span> 中的 <span class="string">'o'</span>，但是能匹配 <span class="string">"food"</span> 中的两个 o。</span><br><span class="line">&#123;n,&#125;           n 是一个非负整数。至少匹配n 次。例如，<span class="string">'o&#123;2,&#125;'</span> 不能匹配 <span class="string">"Bob"</span> 中的 <span class="string">'o'</span>，但能匹配 <span class="string">"foooood"</span> 中的所有 o。<span class="string">'o&#123;1,&#125;'</span> 等价于 <span class="string">'o+'</span>。<span class="string">'o&#123;0,&#125;'</span> 则等价于 <span class="string">'o*'</span>。</span><br><span class="line">&#123;n,m&#125;          m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<span class="string">"o&#123;1,3&#125;"</span> 将匹配 <span class="string">"fooooood"</span> 中的前三个 o。<span class="string">'o&#123;0,1&#125;'</span> 等价于 <span class="string">'o?'</span>。请注意在逗号和两个数之间不能有空格。</span><br><span class="line">?              当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 <span class="string">"oooo"</span>，<span class="string">'o+?'</span> 将匹配单个 <span class="string">"o"</span>，而 <span class="string">'o+'</span> 将匹配所有 <span class="string">'o'</span>。</span><br><span class="line">.              匹配除换行符（<span class="string">\n、\r）之外的任何单个字符。要匹配包括</span> <span class="string">'\n'</span> 在内的任何字符，请使用像<span class="string">"(.|\n)"</span>的模式。</span><br><span class="line">(pattern)      匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $<span class="number">0</span>…$<span class="number">9</span> 属性。要匹配圆括号字符，请使用 <span class="string">'\('</span> 或 <span class="string">'\)'</span>。</span><br><span class="line">(?:pattern)    匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 <span class="string">"或"</span> 字符 (|) 来组合一个模式的各个部分是很有用。例如， <span class="string">'industr(?:y|ies) 就是一个比 '</span>industry|industries<span class="string">' 更简略的表达式。</span></span><br><span class="line"><span class="string">(?=pattern)    正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span></span><br><span class="line"><span class="string">(?!pattern)    正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span></span><br><span class="line"><span class="string">(?&lt;=pattern)   反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?&lt;=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。</span></span><br><span class="line"><span class="string">(?&lt;!pattern)   反向否定预查，与正向否定预查类似，只是方向相反。例如"(?&lt;!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。</span></span><br><span class="line"><span class="string">x|y            匹配 x 或 y。例如，'</span>z|food<span class="string">' 能匹配 "z" 或 "food"。'</span>(z|f)ood<span class="string">' 则匹配 "zood" 或 "food"。</span></span><br><span class="line"><span class="string">[xyz]          字符集合。匹配所包含的任意一个字符。例如， '</span>[abc]<span class="string">' 可以匹配 "plain" 中的 '</span>a<span class="string">'。</span></span><br><span class="line"><span class="string">[^xyz]         负值字符集合。匹配未包含的任意字符。例如， '</span>[^abc]<span class="string">' 可以匹配 "plain" 中的'</span>p<span class="string">'、'</span>l<span class="string">'、'</span>i<span class="string">'、'</span>n<span class="string">'。</span></span><br><span class="line"><span class="string">[a-z]          字符范围。匹配指定范围内的任意字符。例如，'</span>[a-z]<span class="string">' 可以匹配 '</span>a<span class="string">' 到 '</span>z<span class="string">' 范围内的任意小写字母字符。</span></span><br><span class="line"><span class="string">[^a-z]         负值字符范围。匹配任何不在指定范围内的任意字符。例如，'</span>[^a-z]<span class="string">' 可以匹配任何不在 '</span>a<span class="string">' 到 '</span>z<span class="string">' 范围内的任意字符。</span></span><br><span class="line"><span class="string">\b             匹配一个单词边界，也就是指单词和空格间的位置。例如， '</span>er<span class="string">\b'</span> 可以匹配<span class="string">"never"</span> 中的 <span class="string">'er'</span>，但不能匹配 <span class="string">"verb"</span> 中的 <span class="string">'er'</span>。</span><br><span class="line"><span class="string">\B</span>             匹配非单词边界。<span class="string">'er\B'</span> 能匹配 <span class="string">"verb"</span> 中的 <span class="string">'er'</span>，但不能匹配 <span class="string">"never"</span> 中的 <span class="string">'er'</span>。</span><br><span class="line"><span class="string">\cx</span>            匹配由 x 指明的控制字符。例如， <span class="string">\cM</span> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 <span class="string">'c'</span> 字符。</span><br><span class="line"><span class="string">\d</span>             匹配一个数字字符。等价于 [<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line"><span class="string">\D</span>             匹配一个非数字字符。等价于 [^<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line"><span class="string">\f</span>             匹配一个换页符。等价于 <span class="string">\x0c</span> 和 <span class="string">\cL。</span></span><br><span class="line"><span class="string">\n</span>             匹配一个换行符。等价于 <span class="string">\x0a</span> 和 <span class="string">\cJ。</span></span><br><span class="line"><span class="string">\r</span>             匹配一个回车符。等价于 <span class="string">\x0d</span> 和 <span class="string">\cM。</span></span><br><span class="line"><span class="string">\s</span>             匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ <span class="string">\f\n\r\t\v]。</span></span><br><span class="line"><span class="string">\S</span>             匹配任何非空白字符。等价于 [^ <span class="string">\f\n\r\t\v]。</span></span><br><span class="line"><span class="string">\t</span>             匹配一个制表符。等价于 <span class="string">\x09</span> 和 <span class="string">\cI。</span></span><br><span class="line"><span class="string">\v</span>             匹配一个垂直制表符。等价于 <span class="string">\x0b</span> 和 <span class="string">\cK。</span></span><br><span class="line"><span class="string">\w</span>             匹配字母、数字、下划线。等价于<span class="string">'[A-Za-z0-9_]'</span>。</span><br><span class="line"><span class="string">\W</span>             匹配非字母、数字、下划线。等价于 <span class="string">'[^A-Za-z0-9_]'</span>。</span><br><span class="line"><span class="string">\xn</span>            匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<span class="string">'\x41'</span> 匹配 <span class="string">"A"</span>。<span class="string">'\x041'</span> 则等价于 <span class="string">'\x04'</span> &amp; <span class="string">"1"</span>。正则表达式中可以使用 ASCII 编码。</span><br><span class="line"><span class="string">\num</span>           匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<span class="string">'(.)\1'</span> 匹配两个连续的相同字符。</span><br><span class="line"><span class="string">\n</span>             标识一个八进制转义值或一个向后引用。如果 <span class="string">\n</span> 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则 n 为一个八进制转义值。</span><br><span class="line"><span class="string">\nm</span>            标识一个八进制转义值或一个向后引用。如果 <span class="string">\nm</span> 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 <span class="string">\nm</span> 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则 <span class="string">\nm</span> 将匹配八进制转义值 nm。</span><br><span class="line"><span class="string">\nml</span>           如果 n 为八进制数字 (<span class="number">0</span>-<span class="number">3</span>)，且 m 和 l 均为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则匹配八进制转义值 nml。</span><br><span class="line"><span class="string">\un</span>            匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， <span class="string">\u00A9</span> 匹配版权符号 (?)。</span><br></pre></td></tr></table></figure>

<h2 id="五、正则表达式-运算符优先级"><a href="#五、正则表达式-运算符优先级" class="headerlink" title="五、正则表达式 - 运算符优先级"></a>五、正则表达式 - 运算符优先级</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">运算符	描述</span><br><span class="line">\                            转义符</span><br><span class="line">(), (?<span class="symbol">:</span>), (?=), []           圆括号和方括号</span><br><span class="line">*, +, ?, &#123;<span class="built_in">n</span>&#125;, &#123;<span class="built_in">n</span>,&#125;, &#123;<span class="built_in">n</span>,m&#125;    限定符</span><br><span class="line">^, $, \任何元字符、任何字符     定位点和序列（即：位置和顺序）</span><br><span class="line">|                            替换，<span class="string">"或"</span>操作,字符具有高于替换运算符的优先级，使得<span class="string">"m|food"</span>匹配<span class="string">"m"</span>或<span class="string">"food"</span>。若要匹配<span class="string">"mood"</span>或<span class="string">"food"</span>，请使用括号创建子表达式，从而产生<span class="string">"(m|f)ood"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="六、正则表达式-匹配规则"><a href="#六、正则表达式-匹配规则" class="headerlink" title="六、正则表达式 - 匹配规则"></a>六、正则表达式 - 匹配规则</h2><h3 id="6-1、基本模式匹配"><a href="#6-1、基本模式匹配" class="headerlink" title="6.1、基本模式匹配"></a>6.1、基本模式匹配</h3><p>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">^once</span></span><br></pre></td></tr></table></figure>
<p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">bucket<span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 ^ 和 $ 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="symbol">^bucket</span>$</span><br></pre></td></tr></table></figure>
<p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure>
<p>与字符串</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">There once was <span class="keyword">a</span> man <span class="built_in">from</span> NewYork</span><br><span class="line">Who kept all <span class="keyword">of</span> his cash <span class="keyword">in</span> <span class="keyword">a</span> bucket.</span><br></pre></td></tr></table></figure>
<p>是匹配的。<br>在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是 \t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">^<span class="string">\t</span></span><br></pre></td></tr></table></figure>
<p>类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>
<h3 id="6-2、字符簇"><a href="#6-2、字符簇" class="headerlink" title="6.2、字符簇"></a>6.2、字符簇</h3><p>在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。<br>所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure>
<p>这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[a-z]        <span class="comment">//匹配所有的小写字母 </span></span><br><span class="line">[A-Z]        <span class="comment">//匹配所有的大写字母 </span></span><br><span class="line">[a-zA-Z]     <span class="comment">//匹配所有的字母 </span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]        <span class="comment">//匹配所有的数字 </span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>\.\-]    <span class="comment">//匹配所有的数字，句号和减号 </span></span><br><span class="line">[ \f\r\t\n]  <span class="comment">//匹配所有的白字符</span></span><br></pre></td></tr></table></figure>
<p>同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^[<span class="string">a-z</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure>
<p>尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。<br>前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 ^ 时，它表示”非”或”排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">^[<span class="string">^0-9</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure>
<p>这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[^a-z]    <span class="comment">//除了小写字母以外的所有字符 </span></span><br><span class="line">[^\\\/\^] <span class="comment">//除了(\)(/)(^)之外的所有字符 </span></span><br><span class="line">[^\<span class="string">"\']   //除了双引号("</span>)和单引号(')之外的所有字符</span><br></pre></td></tr></table></figure>
<p>特殊字符 .(点，句号)在正则表达式中用来表示除了”新行”之外的所有字符。所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式 . 可以匹配任何字符串，除了空串和只包括一个”新行”的字符串。<br>PHP的正则表达式有一些内置的通用字符簇，列表如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">字符簇	描述</span><br><span class="line"><span class="string">[[:alpha:]]</span>    任何字母</span><br><span class="line"><span class="string">[[:digit:]]</span>    任何数字</span><br><span class="line"><span class="string">[[:alnum:]]</span>    任何字母和数字</span><br><span class="line"><span class="string">[[:space:]]</span>    任何空白字符</span><br><span class="line"><span class="string">[[:upper:]]</span>    任何大写字母</span><br><span class="line"><span class="string">[[:lower:]]</span>    任何小写字母</span><br><span class="line"><span class="string">[[:punct:]]</span>    任何标点符号</span><br><span class="line"><span class="string">[[:xdigit:]]</span>   任何<span class="number">16</span>进制的数字，相当于[<span class="number">0</span><span class="number">-9</span>a-fA-F]</span><br></pre></td></tr></table></figure>

<h3 id="6-3、确定重复出现"><a href="#6-3、确定重复出现" class="headerlink" title="6.3、确定重复出现"></a>6.3、确定重复出现</h3><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">字符簇	描述</span><br><span class="line">^[a-zA-Z_]$         所有的字母和下划线</span><br><span class="line">^[[:alpha:]]&#123;<span class="number">3</span>&#125;$    所有的<span class="number">3</span>个字母的单词</span><br><span class="line">^a$                 字母a</span><br><span class="line">^a&#123;<span class="number">4</span>&#125;$              aaaa</span><br><span class="line">^a&#123;<span class="number">2</span>,<span class="number">4</span>&#125;$            aa,aaa或aaaa</span><br><span class="line">^a&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$            a,aa或aaa</span><br><span class="line">^a&#123;<span class="number">2</span>,&#125;$             包含多于两个a的字符串</span><br><span class="line">^a&#123;<span class="number">2</span>,&#125;              如：aardvark和aaab，但apple不行</span><br><span class="line">a&#123;<span class="number">2</span>,&#125;               如：baad和aaa，但Nantucket不行</span><br><span class="line">\t&#123;<span class="number">2</span>&#125;               两个制表符</span><br><span class="line">.&#123;<span class="number">2</span>&#125;                所有的两个字符</span><br></pre></td></tr></table></figure>
<p>这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。我们可以把模式扩展到更多的单词或数字：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0<span class="number">-9</span>_]&#123;<span class="number">1</span>,&#125;$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">0</span>,&#125;$        <span class="comment">// 所有的正整数 </span></span><br><span class="line">^\-&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;$      <span class="comment">// 所有的整数 </span></span><br><span class="line">^[-]?[<span class="number">0</span><span class="number">-9</span>]+\.?[<span class="number">0</span><span class="number">-9</span>]+$   <span class="comment">// 所有的浮点数</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。<br>特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^\-?[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;\.?[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;$ <span class="comment">//特殊字符 * 与 &#123;0,&#125; 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 &#123;1,&#125; 是相等的，表示 1 个或多个前面的内容 ，所以上面的4个例子可以写成：</span></span><br><span class="line">^[a-zA-Z0<span class="number">-9</span>_]+$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$        <span class="comment">// 所有的正整数 </span></span><br><span class="line">^\-?[<span class="number">0</span><span class="number">-9</span>]+$          <span class="comment">// 所有的整数 </span></span><br><span class="line">^[-]?[<span class="number">0</span><span class="number">-9</span>]+(\.[<span class="number">0</span><span class="number">-9</span>]+)?$ <span class="comment">// 所有的浮点数</span></span><br></pre></td></tr></table></figure>
<p>当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。</p>
<h2 id="七、正则表达式-示例"><a href="#七、正则表达式-示例" class="headerlink" title="七、正则表达式 - 示例"></a>七、正则表达式 - 示例</h2><p>简单表达式<br>正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/a/</span></span><br><span class="line"><span class="regexp">/7/</span></span><br><span class="line"><span class="regexp">/M/</span></span><br></pre></td></tr></table></figure>
<p>可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/a7M/</span></span><br></pre></td></tr></table></figure>
<p>请注意，没有串联运算符。只须在一个字符后面键入另一个字符。</p>
<h3 id="7-1、字符匹配"><a href="#7-1、字符匹配" class="headerlink" title="7.1、字符匹配"></a>7.1、字符匹配</h3><p>句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/a.c/</span></span><br></pre></td></tr></table></figure>
<p>若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜杠 () 字符。举例来说明，下面的正则表达式匹配 filename.ext：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/filename</span>\<span class="string">.ext/</span></span><br></pre></td></tr></table></figure>
<p>这些表达式只让您匹配”任何”单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。</p>
<h3 id="7-2、中括号表达式"><a href="#7-2、中括号表达式" class="headerlink" title="7.2、中括号表达式"></a>7.2、中括号表达式</h3><p>若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为”中括号表达式”。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：<br>如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。<br>\ 字符继续作为转义符。若要匹配 \ 字符，请使用 \。<br>括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="number">12345</span>]/</span><br></pre></td></tr></table></figure>
<p>请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。<br>若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="number">1</span><span class="number">-5</span>]/</span><br></pre></td></tr></table></figure>
<p>当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。<br>若要在中括号表达式中包括连字符，请采用下列方法之一：</p>
<ul>
<li>用反斜杠将它转义：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[\-]</span><br></pre></td></tr></table></figure></li>
<li>将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[-a-z]</span><br><span class="line">[a-z-]</span><br></pre></td></tr></table></figure></li>
<li>创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[!--]</span><br><span class="line">[!-~]</span><br></pre></td></tr></table></figure>
若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/Chapter [^<span class="number">12345</span>]/</span><br></pre></td></tr></table></figure>
在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。<br>上面的表达式可以使用连字符 (-) 来表示：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/Chapter [^<span class="number">1</span><span class="number">-5</span>]/</span><br></pre></td></tr></table></figure>
中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/[A-Za-z0<span class="number">-9</span>]/</span><br></pre></td></tr></table></figure>
<h3 id="7-3、替换和分组"><a href="#7-3、替换和分组" class="headerlink" title="7.3、替换和分组"></a>7.3、替换和分组</h3>替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。<br>您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/^Chapter|Section [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。<br>若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。<br>下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/^(Chapter|Section) [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的”子匹配项”。<br>在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/^(?:Chapter|Section) [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
除 ?: 元字符外，两个其他非捕获元字符创建被称为”预测先行”匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。<br>例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">/Windows(?=<span class="number">95</span> |<span class="number">98</span> |NT )/</span><br></pre></td></tr></table></figure>
找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。<br>其他示例<br>下面列出一些正则表达式示例：<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">正则表达式          描述</span><br><span class="line">/<span class="tag">\<span class="name">b</span></span>([a-z]+) <span class="tag">\</span>1<span class="tag">\<span class="name">b</span></span>/gi                                一个单词连续出现的位置。</span><br><span class="line">/(<span class="tag">\<span class="name">w</span></span>+):<span class="tag">\<span class="name">/</span></span><span class="tag">\<span class="name">/</span></span>([^/:]+)(:<span class="tag">\<span class="name">d*</span></span>)?([^# ]*)/                将一个URL解析为协议、域、端口及相对路径。</span><br><span class="line">/^(?:Chapter|Section) [1-9][0-9]&#123;0,1&#125;<span class="formula">$/            定位章节的位置。</span></span><br><span class="line"><span class="formula">/[-a-z]/                                           a至z共26个字母再加一个-号。</span></span><br><span class="line"><span class="formula">/ter<span class="tag">\<span class="name">b</span></span>/                                            可匹配chapter，而不能匹配terminal。</span></span><br><span class="line"><span class="formula">/<span class="tag">\<span class="name">Bapt</span></span>/                                            可匹配chapter，而不能匹配aptitude。</span></span><br><span class="line"><span class="formula">/Windows(?=95 |98 |NT )/                           可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。</span></span><br><span class="line"><span class="formula">/^<span class="tag">\<span class="name">s*</span></span>$</span>/                                            匹配空行。</span><br><span class="line">/<span class="tag">\<span class="name">d</span><span class="string">&#123;2&#125;</span></span>-<span class="tag">\<span class="name">d</span><span class="string">&#123;5&#125;</span></span>/                                      验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</span><br><span class="line">/&lt;<span class="tag">\<span class="name">s*</span></span>(<span class="tag">\<span class="name">S</span></span>+)(<span class="tag">\<span class="name">s</span><span class="string">[^&gt;]</span></span>*)?&gt;[<span class="tag">\<span class="name">s</span></span><span class="tag">\<span class="name">S</span></span>]*&lt;<span class="tag">\<span class="name">s*</span></span><span class="tag">\<span class="name">/</span></span><span class="tag">\</span>1<span class="tag">\<span class="name">s*</span></span>&gt;/          匹配 HTML 标记。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>最基本的几种排序算法</title>
    <url>/%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>排序算法可以说是一项基本功，解决实际问题中经常遇到，针对实际数据的特点选择合适的排序算法可以使程序获得更高的效率，有时候排序的稳定性还是实际问题中必须考虑的，这篇博客对常见的排序算法进行整理，包括：插入排序、选择排序、冒泡排序、快速排序、堆排序、归并排序、希尔排序、二叉树排序、计数排序、桶排序、基数排序。</p>
<p><strong>比较排序和非比较排序</strong></p>
<p>常见的排序算法都是比较排序，非比较排序包括计数排序、桶排序和基数排序，非比较排序对数据有要求，因为数据本身包含了定位特征，所以才能不通过比较来确定元素的位置。</p>
<p>比较排序的时间复杂度通常为O(n2)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。</p>
<p>比较排序时间复杂度为O(nlogn)的证明：</p>
<p>a1,a2,a3……an序列的所有排序有n!种，所以满足要求的排序a1’,a2’,a3’……an’（其中a1’&lt;=a2’&lt;=a3’……&lt;=an’）的概率为1/n!。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小可以把序列分成a1,a2……an与a2,a1……an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1,a2,a3……an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1’,a2’,a3’……an’）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。</p>
<p>又因为 :</p>
<ol>
<li>n! &lt; nn ,两边取对数就得到log(n!)&lt;nlog(n)，所以log(n!) = O(nlogn).</li>
<li>n!=n(n-1)(n-2)(n-3)…1 &gt; (n/2)^(n/2) 两边取对数得到 log(n!) &gt; (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。</li>
</ol>
<p>因此log(n!)的增长速度与 nlogn 相同,即 log(n!)=Θ(nlogn)，这就是通用排序算法的最低时间复杂度O(nlogn)的依据。</p>
<p><strong>排序的稳定性和复杂度</strong></p>
<p> 不稳定：</p>
<ul>
<li><p>选择排序（selection sort）— O(n2)</p>
</li>
<li><p>快速排序（quicksort）— O(nlogn) 平均时间, O(n2) 最坏情况; 对于大的、乱序串列一般认为是最快的已知排序</p>
</li>
<li><p>堆排序 （heapsort）— O(nlogn)</p>
</li>
<li><p>希尔排序 （shell sort）— O(nlogn)</p>
</li>
<li><p>基数排序（radix sort）— O(n·k); 需要 O(n) 额外存储空间 （K为特征个数）</p>
</li>
</ul>
<p>稳定：</p>
<ul>
<li><p>插入排序（insertion sort）— O(n2)</p>
</li>
<li><p>冒泡排序（bubble sort） — O(n2)</p>
</li>
<li><p>归并排序 （merge sort）— O(n log n); 需要 O(n) 额外存储空间</p>
</li>
<li><p>二叉树排序（Binary tree sort） — O(nlogn); 需要 O(n) 额外存储空间</p>
</li>
<li><p>计数排序  (counting sort) — O(n+k); 需要 O(n+k) 额外存储空间，k为序列中Max-Min+1</p>
</li>
<li><p>桶排序 （bucket sort）— O(n); 需要 O(k) 额外存储空间</p>
</li>
</ul>
<p><strong>每种排序的原理和实现</strong></p>
<h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>遍历数组，遍历到i时，a0,a1…ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是拍在后边，所以插入排序是稳定的。</p>
<p>当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> insertion_sort (<span class="built_in">int</span> a[], <span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">int</span> i,j,v;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">　　　　  <span class="comment">//如果第i个元素小于第j个，则第j个向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (v=a[i], j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>&amp;&amp;v&lt;a[j]; j--)</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        a[j+<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3><p>遍历数组，遍历到i时，a0,a1…ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">void selection_sort (<span class="keyword">int</span> a[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,<span class="keyword">pos</span>,tmp<span class="comment">;</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span><span class="comment">; i&lt;n-1; i++) &#123;</span></span><br><span class="line">　　　　  <span class="comment">//寻找最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">pos</span>=i, j=i+<span class="number">1</span><span class="comment">; j&lt;n; j++)</span></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="keyword">pos</span>]&gt;a[j])</span><br><span class="line">                <span class="keyword">pos</span>=j<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">pos</span> != i) &#123;</span><br><span class="line">            tmp=a[i]<span class="comment">;</span></span><br><span class="line">            a[i]=a[<span class="keyword">pos</span>]<span class="comment">;</span></span><br><span class="line">            a[<span class="keyword">pos</span>]=tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、冒泡排序"><a href="#三、冒泡排序" class="headerlink" title="三、冒泡排序"></a>三、冒泡排序</h3><p>冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。</p>
<p>优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个Flag做标记，默认为false，如果发生交互则置为true，每轮结束时检测Flag，如果为true则继续，如果为false则返回。</p>
<p>优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastSwap的位置，则lastSwap到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastSwap即可，代码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> bubble_sort (<span class="built_in">int</span> a[], <span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">int</span> i, j, lastSwap, tmp;</span><br><span class="line">    <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;<span class="number">0</span>; j=lastSwap) &#123;</span><br><span class="line">        lastSwap=<span class="number">0</span>;     <span class="comment">//每一轮要初始化为0，防止某一轮未发生交换，lastSwap保留上一轮的值进入死循环</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                tmp=a[i];</span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">                a[i+<span class="number">1</span>]=tmp;</span><br><span class="line">　　　　　　　　   <span class="comment">//最后一次交换位置的坐标</span></span><br><span class="line">                lastSwap = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h3><p>快速排序首先找到一个基准，下面程序以第一个元素作为基准（pivot），然后先从右向左搜索，如果发现比pivot小，则和pivot交换，然后从左向右搜索，如果发现比pivot大，则和pivot交换，一直到左边大于右边，此时pivot左边的都比它小，而右边的都比它大，此时pivot的位置就是排好序后应该在的位置，此时pivot将数组划分为左右两部分，可以递归采用该方法进行。快排的交换使排序成为不稳定的。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mpartition(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r &amp;&amp; pivot&lt;=a[r]) r<span class="comment">--;</span></span><br><span class="line">        <span class="keyword">if</span> (l&lt;r) a[l++]=a[r];</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r &amp;&amp; pivot&gt;a[l]) l++;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;r) a[r<span class="comment">--]=a[l];</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> quick_sort (<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> q = mpartition(a, l, r);</span><br><span class="line">        msort(a, l, q<span class="number">-1</span>);</span><br><span class="line">        msort(a, q+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、堆排序"><a href="#五、堆排序" class="headerlink" title="五、堆排序"></a>五、堆排序</h3><p>堆排序是把数组看作堆，第i个结点的孩子结点为第2<em>i+1和2</em>i+2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。</p>
<p>下述代码使用的大顶堆，建立好堆后堆顶元素为最大值，此时取堆顶元素即使堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序。</p>
<p>堆排序的主要时间花在初始建堆期间，建好堆后，堆这种数据结构以及它奇妙的特征，使得找到数列中最大的数字这样的操作只需要O(1)的时间复杂度，维护需要logn的时间复杂度。堆排序不适宜于记录数较少的文件</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> heapAdjust(<span class="built_in">int</span> a[], <span class="built_in">int</span> i, <span class="built_in">int</span> nLength)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nChild;</span><br><span class="line">    <span class="built_in">int</span> nTemp;</span><br><span class="line">    <span class="keyword">for</span> (nTemp = a[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; nLength; i = nChild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子结点的位置=2*（父结点位置）+ 1</span></span><br><span class="line">        nChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 得到子结点中较大的结点</span></span><br><span class="line">        <span class="keyword">if</span> ( nChild &lt; nLength<span class="number">-1</span> &amp;&amp; a[nChild + <span class="number">1</span>] &gt; a[nChild])</span><br><span class="line">            ++nChild;</span><br><span class="line">        <span class="comment">// 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span></span><br><span class="line">        <span class="keyword">if</span> (nTemp &lt; a[nChild])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = a[nChild];</span><br><span class="line">            a[nChild]= nTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// 堆排序算法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void heap<span class="constructor">_sort(<span class="params">int</span> <span class="params">a</span>[],<span class="params">int</span> <span class="params">length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> tmp;</span><br><span class="line">    <span class="comment">// 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span></span><br><span class="line">    <span class="comment">//length/2-1是第一个非叶节点，此处"/"为整除</span></span><br><span class="line">    for (<span class="built_in">int</span> i = length<span class="operator"> / </span><span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        heap<span class="constructor">Adjust(<span class="params">a</span>, <span class="params">i</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    <span class="comment">// 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span></span><br><span class="line">    for (<span class="built_in">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把第一个元素和当前的最后一个元素交换，</span></span><br><span class="line">        <span class="comment">// 保证当前的最后一个位置的元素都是在现在的这个序列之中最大的</span></span><br><span class="line">      <span class="comment">///  Swap(&amp;a[0], &amp;a[i]);</span></span><br><span class="line">          tmp = a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">          a<span class="literal">[<span class="identifier">i</span>]</span> = a<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">          a<span class="literal">[<span class="number">0</span>]</span> = tmp;</span><br><span class="line">        <span class="comment">// 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span></span><br><span class="line">        heap<span class="constructor">Adjust(<span class="params">a</span>, 0, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><p>归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行.logn.次，因此，总的时间复杂度为O(nlogn)。</p>
<p>归并排序在归并过程中需 要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。</p>
<p>归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void mergearray(<span class="built_in">int</span> a<span class="literal">[]</span>, <span class="built_in">int</span> first, <span class="built_in">int</span> mid, <span class="built_in">int</span> last, <span class="built_in">int</span> temp<span class="literal">[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = first, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> m = mid,   n = last;</span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m<span class="operator"> &amp;&amp; </span>j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt;= a<span class="literal">[<span class="identifier">j</span>]</span>)</span><br><span class="line">            temp<span class="literal">[<span class="identifier">k</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp<span class="literal">[<span class="identifier">k</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">        temp<span class="literal">[<span class="identifier">k</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">        temp<span class="literal">[<span class="identifier">k</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line"></span><br><span class="line">    for (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        a<span class="literal">[<span class="identifier">first</span> + <span class="identifier">i</span>]</span> = temp<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">&#125;</span><br><span class="line">void merge<span class="constructor">_sort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">first</span>, <span class="params">int</span> <span class="params">last</span>, <span class="params">int</span> <span class="params">temp</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (first + last)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        merge<span class="constructor">_sort(<span class="params">a</span>, <span class="params">first</span>, <span class="params">mid</span>, <span class="params">temp</span>)</span>;    <span class="comment">//左边有序</span></span><br><span class="line">        merge<span class="constructor">_sort(<span class="params">a</span>, <span class="params">mid</span> + 1, <span class="params">last</span>, <span class="params">temp</span>)</span>; <span class="comment">//右边有序</span></span><br><span class="line">        mergearray(a, first, mid, last, temp); <span class="comment">//再将二个有序数列合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的地方看到在mergearray()合并有序数列时分配临时数组，即每一步mergearray的结果存放的一个新的临时数组里，这样会在递归中消耗大量的空间。因此做出小小的变化。只需要new一个临时数组。后面的操作都共用这一个临时数组。合并完后将临时数组中排好序的部分写回原数组。</p>
<p>归并排序计算时间复杂度时可以很容易的列出递归方程，也是计算时间复杂度的一种方法。</p>
<h3 id="七、希尔排序"><a href="#七、希尔排序" class="headerlink" title="七、希尔排序"></a>七、希尔排序</h3><p>希尔排序是对插入排序的优化，基于以下两个认识：1. 数据量较小时插入排序速度较快，因为n和n2差距很小；2. 数据基本有序时插入排序效率很高，因为比较和移动的数据量少。</p>
<p>因此，希尔排序的基本思想是将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过则插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。</p>
<p>希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数，二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。</p>
<p>希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> shell_sort(<span class="built_in">int</span> a[], <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> d, i, j, temp; <span class="comment">//d为增量</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span>;d &gt;= <span class="number">1</span>;d = d/<span class="number">2</span>) <span class="comment">//增量递减到1使完成排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = d; i &lt; n;i++)   <span class="comment">//插入排序的一轮</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i - d;(j &gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt; temp);j = j-d)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j + d] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        a[j + d] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、二叉树排序"><a href="#八、二叉树排序" class="headerlink" title="八、二叉树排序"></a>八、二叉树排序</h3><p>二叉树排序法借助了数据结构二叉排序树，二叉排序数满足三个条件：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3）左、右子树也分别为二叉排序树。根据这三个特点，用中序遍历二叉树得到的结果就是排序的结果。</p>
<p>二叉树排序法需要首先根据数据构建二叉排序树，然后中序遍历，排序时间复杂度为O(nlogn)，构建二叉树需要额外的O(n)的存储空间，有相同的元素是可以设置排在后边的放在右子树，在中序变量的时候也会在后边，所以二叉树排序是稳定的。</p>
<p>在实现此算法的时候遇到不小的困难，指针参数在函数中无法通过new赋值，后来采用取指针地址，然后函数设置BST** tree的方式解决。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> arr<span class="literal">[]</span> = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">56</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">15</span>,<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BST&#123;</span><br><span class="line">    <span class="built_in">int</span> number; <span class="comment">//保存数组元素的值</span></span><br><span class="line">    <span class="keyword">struct</span> BST* left;</span><br><span class="line">    <span class="keyword">struct</span> BST* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void insert<span class="constructor">BST(BST<span class="operator">**</span> <span class="params">tree</span>, <span class="params">int</span> <span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*tree<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        *tree = <span class="keyword">new</span> BST;</span><br><span class="line">        (*tree)-&gt;left=(*tree)-&gt;right=NULL;</span><br><span class="line">        (*tree)-&gt;number=v;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; (*tree)-&gt;number)</span><br><span class="line">        insert<span class="constructor">BST(&amp;((<span class="operator">*</span><span class="params">tree</span>)</span>-&gt;left), v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert<span class="constructor">BST(&amp;((<span class="operator">*</span><span class="params">tree</span>)</span>-&gt;right), v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print<span class="constructor">Result(BST<span class="operator">*</span> <span class="params">tree</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree<span class="operator"> == </span>NULL)</span><br><span class="line">        return;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != NULL)</span><br><span class="line">        print<span class="constructor">Result(<span class="params">tree</span>-&gt;<span class="params">left</span>)</span>;</span><br><span class="line">    cout &lt;&lt; tree-&gt;number &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != NULL)</span><br><span class="line">        print<span class="constructor">Result(<span class="params">tree</span>-&gt;<span class="params">right</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create<span class="constructor">BST(BST<span class="operator">**</span> <span class="params">tree</span>, <span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    *tree = NULL;</span><br><span class="line">    for (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        insert<span class="constructor">BST(<span class="params">tree</span>, <span class="params">a</span>[<span class="params">i</span>])</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> n = sizeof(arr)/sizeof(<span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">    BST* root;</span><br><span class="line">    create<span class="constructor">BST(&amp;<span class="params">root</span>, <span class="params">arr</span>, <span class="params">n</span>)</span>;</span><br><span class="line">    print<span class="constructor">Result(<span class="params">root</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、计数排序"><a href="#九、计数排序" class="headerlink" title="九、计数排序"></a>九、计数排序</h3><p>如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。</p>
<p>计数排序要求待排序的数组元素都是 整数，有很多地方都要去是0-K的正整数，其实负整数也可以通过都加一个偏移量解决的。</p>
<p>计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。</p>
<p>计数排序的步骤：</p>
<p>找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性）<br>以下代码中寻找最大和最小元素参考编程之美，比较次数为1.5n次。</p>
<p>计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findArrMaxMin</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> *<span class="built_in">min</span>, <span class="keyword">int</span> *<span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        *<span class="built_in">min</span> = *<span class="built_in">max</span> = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *<span class="built_in">min</span> = a[<span class="number">0</span>] &gt; a[<span class="number">1</span>] ? a[<span class="number">1</span>] : a[<span class="number">0</span>];</span><br><span class="line">    *<span class="built_in">max</span> = a[<span class="number">0</span>] &lt;= a[<span class="number">1</span>] ? a[<span class="number">1</span>] : a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>, j = <span class="number">3</span>; i &lt; <span class="built_in">size</span>, j &lt; <span class="built_in">size</span>; i += <span class="number">2</span>, j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempmax = a[i] &gt;= a[j] ? a[i] : a[j];</span><br><span class="line">        <span class="keyword">int</span> tempmin = a[i] &lt; a[j] ? a[i] : a[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tempmax &gt; *<span class="built_in">max</span>)</span><br><span class="line">            *<span class="built_in">max</span> = tempmax;</span><br><span class="line">        <span class="keyword">if</span>(tempmin &lt; *<span class="built_in">min</span>)</span><br><span class="line">            *<span class="built_in">min</span> = tempmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数组元素是奇数个，那么最后一个元素在分组的过程中没有包含其中，</span></span><br><span class="line">    <span class="comment">//这里单独比较</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="built_in">size</span> <span class="number">-1</span>] &gt; *<span class="built_in">max</span>)</span><br><span class="line">            *<span class="built_in">max</span> = a[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="built_in">size</span> <span class="number">-1</span>] &lt; *<span class="built_in">min</span>)</span><br><span class="line">            *<span class="built_in">min</span> = a[<span class="built_in">size</span> <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>, <span class="built_in">min</span>;</span><br><span class="line">    findArrMaxMin(a, n, &amp;<span class="built_in">min</span>, &amp;<span class="built_in">max</span>);</span><br><span class="line">    <span class="keyword">int</span> numRange = <span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* counter = <span class="keyword">new</span> <span class="keyword">int</span>[numRange];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;numRange; k++)</span><br><span class="line">        counter[k]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        counter[a[i]-<span class="built_in">min</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">1</span>; k&lt;numRange; k++)</span><br><span class="line">        counter[k] += counter[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = a[j];</span><br><span class="line">        <span class="keyword">int</span> index = counter[v-<span class="built_in">min</span>]<span class="number">-1</span>;</span><br><span class="line">        b[index]=v;</span><br><span class="line">        counter[v-<span class="built_in">min</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十、桶排序"><a href="#十、桶排序" class="headerlink" title="十、桶排序"></a>十、桶排序</h3><p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。</p>
<p>桶排序利用函数的映射关系，减少了计划所有的比较操作，是一种Hash的思想，可以用在海量数据处理中。</p>
<p>我觉得计数排序也可以看作是桶排序的特例，数组关键字范围为N，划分为N个桶。</p>
<h3 id="十一、基数排序"><a href="#十一、基数排序" class="headerlink" title="十一、基数排序"></a>十一、基数排序</h3><p>基数排序也可以看作一种桶排序，不断的使用不同的标准对数据划分到桶中，最终实现有序。基数排序的思想是对数据选择多种基数，对每一种基数依次使用桶排序。</p>
<p>基数排序的步骤：以整数为例，将整数按十进制位划分，从低位到高位执行以下过程。</p>
<ol>
<li><p>从个位开始，根据0~9的值将数据分到10个桶桶，例如12会划分到2号桶中。</p>
</li>
<li><p>将0~9的10个桶中的数据顺序放回到数组中。</p>
</li>
</ol>
<p>重复上述过程，一直到最高位。</p>
<p>上述方法称为LSD（Least significant digital），还可以从高位到低位，称为MSD。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> getNumInPos(<span class="built_in">int</span> num,<span class="built_in">int</span> pos) <span class="comment">//获得某个数字的第pos位的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">        temp *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (num / temp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define RADIX_10 <span class="number">10</span>    <span class="comment">//十个桶，表示每一位的十个数字</span></span><br><span class="line">#define KEYNUM <span class="number">5</span>     <span class="comment">//整数位数</span></span><br><span class="line"><span class="built_in">void</span> radix_sort(<span class="built_in">int</span>* pDataArray, <span class="built_in">int</span> iDataNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> *radixArrays[RADIX_10];    <span class="comment">//分别为0~9的序列空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; RADIX_10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        radixArrays[i] = new <span class="built_in">int</span>[iDataNum];</span><br><span class="line">        radixArrays[i][<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">//index为0处记录这组数据的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> pos = <span class="number">1</span>; pos &lt;= KEYNUM; pos++)    <span class="comment">//从个位开始到31位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iDataNum; i++)    <span class="comment">//分配过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num = getNumInPos(pDataArray[i], pos);</span><br><span class="line">            <span class="built_in">int</span> index = ++radixArrays[num][<span class="number">0</span>];</span><br><span class="line">            radixArrays[num][index] = pDataArray[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j =<span class="number">0</span>; i &lt; RADIX_10; i++) <span class="comment">//写回到原数组中，复位radixArrays</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">1</span>; k &lt;= radixArrays[i][<span class="number">0</span>]; k++)</span><br><span class="line">                pDataArray[j++] = radixArrays[i][k];</span><br><span class="line">            radixArrays[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode、UTF-8编码问题</title>
    <url>/Unicode%E3%80%81UTF-8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a>一、ASCII 码</h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。<br>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。<br>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>
<h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a>二、非 ASCII 编码</h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。<br>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。<br>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。<br>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
<h2 id="三-Unicode"><a href="#三-Unicode" class="headerlink" title="三. Unicode"></a>三. Unicode</h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。<br>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。<br>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</p>
<h2 id="四、Unicode-的问题"><a href="#四、Unicode-的问题" class="headerlink" title="四、Unicode 的问题"></a>四、Unicode 的问题</h2><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。<br>比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。<br>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。<br>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
<h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a>五、UTF-8</h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。<br>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8 的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。<br>2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。<br>下表总结了编码规则，字母x表示可用编码的位。<br>Unicode符号范围     |        UTF-8编码方式<br>(十六进制)        |              （二进制）<br>———————-+———————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。<br>下面，还是以汉字严为例，演示如何实现 UTF-8 编码。<br>严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</p>
<h2 id="六、Unicode-与-UTF-8-之间的转换"><a href="#六、Unicode-与-UTF-8-之间的转换" class="headerlink" title="六、Unicode 与 UTF-8 之间的转换"></a>六、Unicode 与 UTF-8 之间的转换</h2><p>通过上一节的例子，可以看到严的 Unicode码 是4E25，UTF-8 编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。<br>Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序notepad.exe。打开文件后，点击文件菜单中的另存为命令，会跳出一个对话框，在最底部有一个编码的下拉条。<br>bg2007102801.jpg<br>里面有四个选项：ANSI，Unicode，Unicode big endian和UTF-8。<br>1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。<br>2）Unicode编码这里指的是notepad.exe使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。<br>3）Unicode big endian编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。<br>4）UTF-8编码，也就是上一节谈到的编码方法。<br>选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="七、Little-endian-和-Big-endian"><a href="#七、Little-endian-和-Big-endian" class="headerlink" title="七、Little endian 和 Big endian"></a>七、Little endian 和 Big endian</h2><p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。<br>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。<br>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。<br>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？<br>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。<br>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。<br>大头方式（Big Endian, 简称BE）：一个字中的高位字节放在内存中这个字区域的低地址。小头方式（Little Endian, 简称LE）：即一个字中的低位字节放在内存中这个字区域的低地址处。</p>
<h2 id="八、实例"><a href="#八、实例" class="headerlink" title="八、实例"></a>八、实例</h2><p>下面，举一个实例。<br>打开”记事本”程序notepad.exe，新建一个文本文件，内容就是一个严字，依次采用ANSI，Unicode，Unicode big endian和UTF-8编码方式保存。<br>然后，用文本编辑软件UltraEdit 中的”十六进制功能”，观察该文件的内部编码方式。<br>1）ANSI：文件的编码就是两个字节D1 CF，这正是严的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。<br>2）Unicode：编码是四个字节FF FE 25 4E，其中FF FE表明是小头方式存储，真正的编码是4E25。<br>3）Unicode big endian：编码是四个字节FE FF 4E 25，其中FE FF表明是大头方式存储。<br>4）UTF-8：编码是六个字节EF BB BF E4 B8 A5，前三个字节EF BB BF表示这是UTF-8编码，后三个E4B8A5就是严的具体编码，它的存储顺序与编码顺序是一致的。</p>
<h2 id="九、关于Unicode的延伸阅读"><a href="#九、关于Unicode的延伸阅读" class="headerlink" title="九、关于Unicode的延伸阅读"></a>九、关于Unicode的延伸阅读</h2><p><a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets（关于字符集的最基本知识）</a><br><a href="http://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html" target="_blank" rel="noopener">谈谈Unicode编码</a><br><a href="http://www.ietf.org/rfc/rfc3629.txt" target="_blank" rel="noopener">RFC3629：UTF-8, a transformation format of ISO 10646（如果实现UTF-8的规定）</a></p>
<h2 id="十、适配iOS中的表情"><a href="#十、适配iOS中的表情" class="headerlink" title="十、适配iOS中的表情"></a>十、适配iOS中的表情</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> NumBetween(<span class="built_in">int</span> num, <span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">    BOOL result = NO;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= a &amp;&amp; num &gt;= b) &#123;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= a &amp;&amp; num &lt;= b) &#123;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL IsEmojiUnicode(<span class="built_in">int</span> unicode) &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL result = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (NumBetween(unicode, <span class="number">0x20D0</span>, <span class="number">0x20FF</span>)   ||<span class="comment">//奇怪的符号</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x2190</span>, <span class="number">0x21FF</span>)   ||<span class="comment">//各种箭头</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x2300</span>, <span class="number">0x23FF</span>)   ||<span class="comment">//包括一些符号</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x2460</span>, <span class="number">0x24FF</span>)   ||<span class="comment">//①</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x2600</span>, <span class="number">0x27BF</span>)   ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x2B00</span>, <span class="number">0x2BFF</span>)   ||<span class="comment">//各种箭头</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x3200</span>, <span class="number">0x32FF</span>)   ||<span class="comment">//✔️片假字</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0xFE00</span>, <span class="number">0xFE0F</span>)   ||<span class="comment">//未知区域</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F0A0</span>, <span class="number">0x1F0FF</span>) ||<span class="comment">//✔️扑克牌</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F170</span>, <span class="number">0x1F251</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F300</span>, <span class="number">0x1F5ff</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F30D</span>, <span class="number">0x1F567</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F600</span>, <span class="number">0x1F64F</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F680</span>, <span class="number">0x1F6FF</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        NumBetween(unicode, <span class="number">0x1F900</span>, <span class="number">0x1F9FF</span>) ||<span class="comment">//✔️</span></span><br><span class="line">        unicode == <span class="number">0x00A9</span> || unicode == <span class="number">0x00AE</span> || unicode == <span class="number">0x2122</span> || unicode == <span class="number">0x3030</span>) &#123;</span><br><span class="line">        result = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL Utf8ToUnicode(NSString * <span class="built_in">string</span>, <span class="built_in">int</span> *bytes, <span class="built_in">int</span> *unicode) &#123;</span><br><span class="line">    </span><br><span class="line">    char * s   = (char*)[<span class="built_in">string</span> UTF8String];</span><br><span class="line">    <span class="built_in">int</span> t_num  = <span class="number">0</span>;</span><br><span class="line">    BOOL is_emoji  = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        NSData * <span class="built_in">string</span>Data    = [<span class="built_in">string</span> dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        NSUInteger <span class="literal">true</span>Bytes   = [<span class="built_in">string</span>Data length];</span><br><span class="line">        NSUInteger bytesLength = <span class="number">0</span>;</span><br><span class="line">        BOOL stop  = NO;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">int</span> a, b, c, d, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ( <span class="number">0x80</span> &amp; s[<span class="number">0</span>] ) == <span class="number">0</span> )<span class="comment">//一个字节的UTF-8</span></span><br><span class="line">            &#123;</span><br><span class="line">                bytesLength += <span class="number">1</span>;</span><br><span class="line">                t = s[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (( <span class="number">0xE0</span> &amp; s[<span class="number">0</span>] ) == <span class="number">0xC0</span> )<span class="comment">//两字节的UTF-8</span></span><br><span class="line">            &#123;</span><br><span class="line">                bytesLength += <span class="number">2</span>;</span><br><span class="line">                a = ( <span class="number">0x1F</span> &amp; s[<span class="number">0</span>] ) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">                b = <span class="number">0x3F</span> &amp; s[<span class="number">1</span>];</span><br><span class="line">                t += a + b;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( ( <span class="number">0xF0</span> &amp; s[<span class="number">0</span>] ) == <span class="number">0xE0</span> )<span class="comment">//三字节的UTF-8</span></span><br><span class="line">            &#123;</span><br><span class="line">                bytesLength += <span class="number">3</span>;</span><br><span class="line">                a = ( <span class="number">0x0F</span> &amp; s[<span class="number">0</span>] ) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">                b = ( <span class="number">0x3F</span> &amp; s[<span class="number">1</span>] ) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">                c = <span class="number">0x3F</span> &amp; s[<span class="number">2</span>];</span><br><span class="line">                t += a + b + c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( ( <span class="number">0xF0</span> &amp; s[<span class="number">0</span>] ) == <span class="number">0xF0</span> )<span class="comment">//四字节的UTF-8</span></span><br><span class="line">            &#123;</span><br><span class="line">                bytesLength += <span class="number">4</span>;</span><br><span class="line">                a = ( <span class="number">0x07</span> &amp; s[<span class="number">0</span>] ) &lt;&lt; <span class="number">18</span>;</span><br><span class="line">                b = ( <span class="number">0x3F</span> &amp; s[<span class="number">1</span>] ) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">                c = ( <span class="number">0x3F</span> &amp; s[<span class="number">2</span>] ) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">                d = <span class="number">0x3F</span> &amp; s[<span class="number">3</span>];</span><br><span class="line">                t += a + b + c + d;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            t_num += t;</span><br><span class="line">            <span class="keyword">if</span> (bytesLength &gt;= <span class="literal">true</span>Bytes) &#123;</span><br><span class="line">                stop = YES;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesLength &lt; <span class="literal">true</span>Bytes) &#123;</span><br><span class="line">                NSData * subData = [<span class="built_in">string</span>Data subdataWithRange:NSMakeRange(bytesLength, <span class="literal">true</span>Bytes - bytesLength)];</span><br><span class="line">                s = (char *)[subData bytes];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (IsEmojiUnicode(t)) &#123;</span><br><span class="line">                stop = YES;</span><br><span class="line">                is_emoji = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!is_emoji) &#123;</span><br><span class="line">            is_emoji = IsEmojiUnicode(t_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unicode) &#123;</span><br><span class="line">            *unicode = t_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bytes) &#123;</span><br><span class="line">            *bytes = (<span class="built_in">int</span>)bytesLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> is_emoji;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是适配一个字是否是表情的方法，目前应该算是比较准确的。</p>
<h2 id="十一、汉字-Unicode-编码范围"><a href="#十一、汉字-Unicode-编码范围" class="headerlink" title="十一、汉字 Unicode 编码范围"></a>十一、汉字 Unicode 编码范围</h2><p>字符集    字数    Unicode 编码<br>基本汉字    20902字    4E00-9FA5<br>基本汉字补充    74字    9FA6-9FEF<br>扩展A    6582字    3400-4DB5<br>扩展B    42711字    20000-2A6D6<br>扩展C    4149字    2A700-2B734<br>扩展D    222字    2B740-2B81D<br>扩展E    5762字    2B820-2CEA1<br>扩展F    7473字    2CEB0-2EBE0<br>康熙部首    214字    2F00-2FD5<br>部首扩展    115字    2E80-2EF3<br>兼容汉字    477字    F900-FAD9<br>兼容扩展    542字    2F800-2FA1D<br>PUA(GBK)部件    81字    E815-E86F<br>部件扩展    452字    E400-E5E8<br>PUA增补    207字    E600-E6CF<br>汉字笔画    36字    31C0-31E3<br>汉字结构    12字    2FF0-2FFB<br>汉语注音    43字    3105-312F<br>注音扩展    22字    31A0-31BA<br>〇    1字    3007<br><a href="https://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php" target="_blank" rel="noopener">参考https://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Unicode-编码</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS保持界面流畅的技巧</title>
    <url>/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h2 id="一、屏幕显示图像的原理"><a href="#一、屏幕显示图像的原理" class="headerlink" title="一、屏幕显示图像的原理"></a>一、屏幕显示图像的原理</h2><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_screen_scan.png" alt></p>
<p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_frame_drop.png" alt></p>
<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p>
<p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_vsync_off.jpg" alt></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<p>那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p>
<h2 id="二、卡顿产生的原因和解决方案"><a href="#二、卡顿产生的原因和解决方案" class="headerlink" title="二、卡顿产生的原因和解决方案"></a>二、卡顿产生的原因和解决方案</h2><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_frame_drop.png" alt></p>
<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h3 id="2-1、CPU-资源消耗原因和解决方案"><a href="#2-1、CPU-资源消耗原因和解决方案" class="headerlink" title="2.1、CPU 资源消耗原因和解决方案"></a>2.1、CPU 资源消耗原因和解决方案</h3><p><strong>对象创建</strong></p>
<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>
<p><strong>对象调整</strong></p>
<p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<p><strong>对象销毁</strong></p>
<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>布局计算</strong></p>
<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<p><strong>Autolayout</strong></p>
<p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/。" target="_blank" rel="noopener">http://pilky.me/36/。</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<p><strong>文本计算</strong></p>
<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<p><strong>文本渲染</strong></p>
<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<p><strong>图片的解码</strong></p>
<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<p><strong>图像的绘制</strong></p>
<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2、GPU-资源消耗原因和解决方案"><a href="#2-2、GPU-资源消耗原因和解决方案" class="headerlink" title="2.2、GPU 资源消耗原因和解决方案"></a>2.2、GPU 资源消耗原因和解决方案</h2><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<p><strong>纹理的渲染</strong></p>
<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p>
<p><strong>视图的混合 (Composing)</strong></p>
<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<p><strong>图形的生成</strong></p>
<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<h2 id="三、AsyncDisplayKit"><a href="#三、AsyncDisplayKit" class="headerlink" title="三、AsyncDisplayKit"></a>三、AsyncDisplayKit</h2><p>AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。</p>
<h3 id="3-1、ASDK-的由来"><a href="#3-1、ASDK-的由来" class="headerlink" title="3.1、ASDK 的由来"></a>3.1、ASDK 的由来</h3><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/scott_goodson.png" alt></p>
<p>ASDK 的作者是 Scott Goodson (Linkedin)，<br>他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置、Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_history.png" alt></p>
<p>ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。<br>V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。<br>现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。</p>
<h3 id="3-2、ASDK-的资料"><a href="#3-2、ASDK-的资料" class="headerlink" title="3.2、ASDK 的资料"></a>3.2、ASDK 的资料</h3><p>想要了解 ASDK 的原理和细节，最好从下面几个视频开始：<br>2014.10.15 <a href="https://www.youtube.com/watch?v=-IPMNWqA638" target="_blank" rel="noopener">NSLondon – Scott Goodson – Behind AsyncDisplayKit</a><br>2015.03.02 <a href="https://www.youtube.com/watch?v=ZPL4Nse76oY" target="_blank" rel="noopener">MCE 2015 – Scott Goodson – Effortless Responsiveness with AsyncDisplayKit</a><br>2015.10.25 <a href="https://www.youtube.com/watch?v=RY_X7l1g79Q" target="_blank" rel="noopener">AsyncDisplayKit 2.0: Intelligent User Interfaces – NSSpain 2015</a><br>前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。<br>后一个视频增加了 ASDK 2.0 的新特性的介绍。</p>
<p>除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容：<br>关于 Runloop Dispatch<br>关于 ComponentKit 和 ASDK 的区别<br>为什么不支持 Storyboard 和 Autolayout<br>如何评测界面的流畅度</p>
<p>之后，还可以到 Google Groups 来查看和讨论更多内容：<br><a href="https://groups.google.com/forum/#!forum/asyncdisplaykit" target="_blank" rel="noopener">https://groups.google.com/forum/#!forum/asyncdisplaykit</a></p>
<h3 id="3-3、ASDK-的基本原理"><a href="#3-3、ASDK-的基本原理" class="headerlink" title="3.3、ASDK 的基本原理"></a>3.3、ASDK 的基本原理</h3><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_design.png" alt></p>
<p>ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。</p>
<p>为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_layer_backed_view.png" alt></p>
<p>这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_view_backed_node.png" alt></p>
<p>ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&gt;CALayer 相同的方式，实现了 ASNode-&gt;UIView 这样一个关系。</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_layer_backed_node.png" alt></p>
<p>当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。</p>
<p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。</p>
<p>通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。</p>
<h3 id="3-4、ASDK-的图层预合成"><a href="#3-4、ASDK-的图层预合成" class="headerlink" title="3.4、ASDK 的图层预合成"></a>3.4、ASDK 的图层预合成</h3><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_comoose_1.png" alt> <img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_compose_2.png" alt></p>
<p>有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。</p>
<p>通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。</p>
<h3 id="3-5、ASDK-异步并发操作"><a href="#3-5、ASDK-异步并发操作" class="headerlink" title="3.5、ASDK 异步并发操作"></a>3.5、ASDK 异步并发操作</h3><p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/asdk_a9_chip.jpg" alt></p>
<p>自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。</p>
<h3 id="3-6、Runloop-任务分发"><a href="#3-6、Runloop-任务分发" class="headerlink" title="3.6、Runloop 任务分发"></a>3.6、Runloop 任务分发</h3><p>Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章 深入理解RunLoop，里面对 ASDK 也有所提及。</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_vsync_runloop.png" alt></p>
<p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>
<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p>
<p>ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：ASAsyncTransactionGroup。</p>
<p>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</p>
<p>其他<br>ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。</p>
<h2 id="四、微博-Demo-性能优化技巧"><a href="#四、微博-Demo-性能优化技巧" class="headerlink" title="四、微博 Demo 性能优化技巧"></a>四、微博 Demo 性能优化技巧</h2><p>我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。</p>
<h3 id="4-1、预排版"><a href="#4-1、预排版" class="headerlink" title="4.1、预排版"></a>4.1、预排版</h3><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：FDTemplateLayoutCell。</p>
<h3 id="4-2、预渲染"><a href="#4-2、预渲染" class="headerlink" title="4.2、预渲染"></a>4.2、预渲染</h3><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h3 id="4-3、异步绘制"><a href="#4-3、异步绘制" class="headerlink" title="4.3、异步绘制"></a>4.3、异步绘制</h3><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：YYAsyncLayer。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
<h3 id="4-4、全局并发控制"><a href="#4-4、全局并发控制" class="headerlink" title="4.4、全局并发控制"></a>4.4、全局并发控制</h3><p>当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：</p>
<p><img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_dispatch_blocked_1.png" alt> <img src="/iOS%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7/ios_dispatch_blocked_2.png" alt></p>
<p>大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：SocialAppLayout，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p>
<p>使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 YYDispatchQueuePool，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p>
<h3 id="4-5、更高效的异步图片加载"><a href="#4-5、更高效的异步图片加载" class="headerlink" title="4.5、更高效的异步图片加载"></a>4.5、更高效的异步图片加载</h3><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p>
<h3 id="4-6、其他可以改进的地方"><a href="#4-6、其他可以改进的地方" class="headerlink" title="4.6、其他可以改进的地方"></a>4.6、其他可以改进的地方</h3><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p>
<p>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</p>
<p>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</p>
<p>目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</p>
<p>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</p>
<h2 id="五、如何评测界面的流畅度"><a href="#五、如何评测界面的流畅度" class="headerlink" title="五、如何评测界面的流畅度"></a>五、如何评测界面的流畅度</h2><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。</p>
<p>如果你需要一个明确的 FPS 指示器，可以尝试一下 KMCGeigerCounter。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1×1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p>
<p>我自己也写了个简单的 FPS 指示器：FPSLabel 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p>
<p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p>
<p>转自：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>FPS</tag>
        <tag>界面流畅</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity】Unity 工程配置打包成 iOS 工程</title>
    <url>/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B.html</url>
    <content><![CDATA[<p>摘要：Unity下载地址Unity破解地址本文Unity版本:5.3.6f1Unity5.0以下版本打包出来的工程结构和Unity5.0以上版本是有区别的,后续会更新Unity4.6版本升级到Unity5.3版本的文章Unity5.3.6版本打包出来的iOS工程是ARC的。Unity4.6版本打包出来的iOS工程是MRC,所以注意混编。1、Command+Shift+B调出BuildSettings界面如下图1.png2、选中DevelopmentBulid以后打包出来的游戏进入游</p>
<p>Unity 下载地址<br>Unity 破解地址<br>本文 Unity 版本:5.3.6f1<br>Unity 5.0 以下版本打包出来的工程结构和 Unity 5.0 以上版本是有区别的,后续会更新 Unity 4.6 版本升级到 Unity 5.3 版本的文章<br>Unity 5.3.6 版本打包出来的 iOS 工程是 ARC 的。 Unity 4.6 版本打包出来的 iOS 工程是 MRC,所以注意混编。</p>
<p>1、Command + Shift + B 调出 Build Settings 界面 如下图</p>
<p><img src="/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B/1.jpg" alt></p>
<p>2、选中 Development Bulid 以后打包出来的游戏进入游戏右下角会有 Development 的字样</p>
<p><img src="/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B/2.jpeg" alt></p>
<p>3、点击 Player Settings 进入工程设置界面(里面大多数设置都可以在打包出来以后,iOS 在 Xcode 里面重新设置)</p>
<p><img src="/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B/3.jpeg" alt></p>
<p>其中屏幕方向一般都选择为 Auto Roatation , 后续可在 iOS 代码中控制进游戏横竖屏。<br>其中应用图标,启动图都可后续在 Xcode 中重新设置。</p>
<p>4、如果选中 Splash Image 中的 Show Unity Splash Screen 则会在启动App的时候多一个 Unity 自己的界面,所以建议不要勾选。</p>
<p><img src="/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B/4.jpeg" alt></p>
<p>5、其他的设置自己注意就行,比如可以勾选是否支付 Http 协议等等。但是注意勾选的设置不一样,可能打包成 iOS 工程以后里面的 Unity 相关代码是有一点点差距。如果有图片资源,注意选择为高清模式。</p>
<p>6、开始 Build</p>
<p>7、Build 成功以后,如下图所示,一般更新只替换 Native, MapFileParser, MapFileParser.sh,data四个文件即可达到解释器更新的目的。特殊情况替换 Libraries 文件。</p>
<p><img src="/%E3%80%90Unity%E3%80%91Unity-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E6%88%90-iOS-%E5%B7%A5%E7%A8%8B/5.jpeg" alt></p>
<p>8、后续更新 Unity 如何和 iOS 进行数据交互,如何在 iOS 工程内启动 Unity 项目/游戏,退出 Unity 游戏返回到 iOS 项目等操作。</p>
<p>原创文章,转载请注明出处。<br><a href="https://www.aliyun.com/jiaocheng/361001.html" target="_blank" rel="noopener">转载</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS获取各类基本信息（型号，cpu）</title>
    <url>/iOS%E8%8E%B7%E5%8F%96%E5%90%84%E7%B1%BB%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%EF%BC%88%E5%9E%8B%E5%8F%B7%EF%BC%8Ccpu%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="一、获取基本信息"><a href="#一、获取基本信息" class="headerlink" title="一、获取基本信息"></a>一、获取基本信息</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *deviceName = [<span class="keyword">self</span> getDeviceName]; <span class="comment">// 这个方法后面会列出来</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"设备型号--&gt;%@"</span>, deviceName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *iPhoneName = [<span class="built_in">UIDevice</span> currentDevice].name;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"iPhone名称--&gt;%@"</span>, iPhoneName); </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *appVerion = [[[<span class="built_in">NSBundle</span> mainBundle] infoDictionary] objectForKey:<span class="string">@"CFBundleShortVersionString"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"app版本号--&gt;%@"</span>, appVerion);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> batteryLevel = [[<span class="built_in">UIDevice</span> currentDevice] batteryLevel];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"电池电量--&gt;%f"</span>, batteryLevel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *localizedModel = [<span class="built_in">UIDevice</span> currentDevice].localizedModel;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"localizedModel--&gt;%@"</span>, localizedModel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *systemName = [<span class="built_in">UIDevice</span> currentDevice].systemName;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"当前系统名称--&gt;%@"</span>, systemName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *systemVersion = [<span class="built_in">UIDevice</span> currentDevice].systemVersion;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"当前系统版本号--&gt;%@"</span>, systemVersion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> utsname systemInfo;</span><br><span class="line">uname(&amp;systemInfo);</span><br><span class="line"><span class="built_in">NSString</span> *device_model = [<span class="built_in">NSString</span> stringWithCString:systemInfo.machine encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"device_model--&gt;%@"</span>, device_model);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *macAddress = [<span class="keyword">self</span> getMacAddress];<span class="comment">// 这个方法后面会单独列出</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"macAddress--&gt;%@"</span>, macAddress);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *deviceIP = [<span class="keyword">self</span> getDeviceIPAddresses];<span class="comment">// 这个方法后面会单独列出</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"deviceIP--&gt;%@"</span>, deviceIP);</span><br></pre></td></tr></table></figure>

<h3 id="1-1、设备上次重启的时间"><a href="#1-1、设备上次重启的时间" class="headerlink" title="1.1、设备上次重启的时间"></a>1.1、设备上次重启的时间</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSTimeInterval time = <span class="comment">[<span class="comment">[NSProcessInfo processInfo]</span> systemUptime]</span>;</span><br><span class="line">NSDate *lastRestartDate = <span class="comment">[<span class="comment">[NSDate alloc]</span> initWithTimeIntervalSinceNow:(0 - time)]</span>;</span><br></pre></td></tr></table></figure>
<p>广告位标识符：在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是绰绰有余了</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *idfa = [[[<span class="symbol">ASIdentifierManager</span> sharedManager] advertisingIdentifier] <span class="symbol">UUIDString</span>];</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"广告位标识符idfa--&gt;%@"</span>, idfa);</span><br></pre></td></tr></table></figure>
<p>UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *uuid = [[[<span class="built_in">UIDevice</span> currentDevice] identifierForVendor] UUIDString];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"唯一识别码uuid--&gt;%@"</span>, uuid);</span><br></pre></td></tr></table></figure>
<h3 id="1-2、获取设备型号"><a href="#1-2、获取设备型号" class="headerlink" title="1.2、获取设备型号"></a>1.2、获取设备型号</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取设备型号然后手动转化为对应名称  需要导入 "sys/utsname.h"</span></span><br><span class="line">- (NSString *)getDeviceName</span><br><span class="line">&#123;</span><br><span class="line">    struct utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    NSString *deviceString = [NSString <span class="string">stringWithCString:</span>systemInfo.machine <span class="string">encoding:</span>NSUTF8StringEncoding];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone3,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 4"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone3,2"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 4"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone3,3"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 4"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone4,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 4S"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone5,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone5,2"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5 (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone5,3"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5c (GSM)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone5,4"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5c (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone6,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5s (GSM)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone6,2"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 5s (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone7,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 6 Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone7,2"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 6"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone8,1"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 6s"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone8,2"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone 6s Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone8,4"</span>])    <span class="keyword">return</span> @<span class="string">"iPhone SE"</span>;</span><br><span class="line">    <span class="comment">// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付</span></span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone9,1"</span>])    <span class="keyword">return</span> @<span class="string">"国行、日版、港行iPhone 7"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone9,2"</span>])    <span class="keyword">return</span> @<span class="string">"港行、国行iPhone 7 Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone9,3"</span>])    <span class="keyword">return</span> @<span class="string">"美版、台版iPhone 7"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone9,4"</span>])    <span class="keyword">return</span> @<span class="string">"美版、台版iPhone 7 Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,1"</span>])   <span class="keyword">return</span> @<span class="string">"国行(A1863)、日行(A1906)iPhone 8"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,4"</span>])   <span class="keyword">return</span> @<span class="string">"美版(Global/A1905)iPhone 8"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,2"</span>])   <span class="keyword">return</span> @<span class="string">"国行(A1864)、日行(A1898)iPhone 8 Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,5"</span>])   <span class="keyword">return</span> @<span class="string">"美版(Global/A1897)iPhone 8 Plus"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,3"</span>])   <span class="keyword">return</span> @<span class="string">"国行(A1865)、日行(A1902)iPhone X"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPhone10,6"</span>])   <span class="keyword">return</span> @<span class="string">"美版(Global/A1901)iPhone X"</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPod1,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPod Touch 1G"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPod2,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPod Touch 2G"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPod3,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPod Touch 3G"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPod4,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPod Touch 4G"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPod5,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPod Touch (5 Gen)"</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad1,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPad"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad1,2"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 3G"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 2 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,2"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 2"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,3"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 2 (CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,4"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 2"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,5"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,6"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad2,7"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 3 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,2"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 3 (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,3"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 3"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,4"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 4 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,5"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 4"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad3,6"</span>])      <span class="keyword">return</span> @<span class="string">"iPad 4 (GSM+CDMA)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Air (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,2"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Air (Cellular)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,4"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 2 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,5"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 2 (Cellular)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,6"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 2"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,7"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 3"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,8"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 3"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad4,9"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 3"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad5,1"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 4 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad5,2"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Mini 4 (LTE)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad5,3"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Air 2"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad5,4"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Air 2"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,3"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Pro 9.7"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,4"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Pro 9.7"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,7"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Pro 12.9"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,8"</span>])      <span class="keyword">return</span> @<span class="string">"iPad Pro 12.9"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,11"</span>])    <span class="keyword">return</span> @<span class="string">"iPad 5 (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad6,12"</span>])    <span class="keyword">return</span> @<span class="string">"iPad 5 (Cellular)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad7,1"</span>])     <span class="keyword">return</span> @<span class="string">"iPad Pro 12.9 inch 2nd gen (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad7,2"</span>])     <span class="keyword">return</span> @<span class="string">"iPad Pro 12.9 inch 2nd gen (Cellular)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad7,3"</span>])     <span class="keyword">return</span> @<span class="string">"iPad Pro 10.5 inch (WiFi)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([machineString <span class="string">isEqualToString:</span>@<span class="string">"iPad7,4"</span>])     <span class="keyword">return</span> @<span class="string">"iPad Pro 10.5 inch (Cellular)"</span>;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"AppleTV2,1"</span>])    <span class="keyword">return</span> @<span class="string">"Apple TV 2"</span>;</span><br><span class="line">   <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"AppleTV3,1"</span>])    <span class="keyword">return</span> @<span class="string">"Apple TV 3"</span>;</span><br><span class="line">   <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"AppleTV3,2"</span>])    <span class="keyword">return</span> @<span class="string">"Apple TV 3"</span>;</span><br><span class="line">   <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"AppleTV5,3"</span>])    <span class="keyword">return</span> @<span class="string">"Apple TV 4"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"i386"</span>])         <span class="keyword">return</span> @<span class="string">"Simulator"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([deviceString <span class="string">isEqualToString:</span>@<span class="string">"x86_64"</span>])       <span class="keyword">return</span> @<span class="string">"Simulator"</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> deviceString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、mac-地址"><a href="#二、mac-地址" class="headerlink" title="二、mac 地址"></a>二、mac 地址</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (NSString *)getMacAddress &#123;</span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">if_msghdr</span> *<span class="title">ifm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_dl</span> *<span class="title">sdl</span>;</span></span><br><span class="line">     </span><br><span class="line">    mib[<span class="number">0</span>] = CTL_NET;</span><br><span class="line">    mib[<span class="number">1</span>] = AF_ROUTE;</span><br><span class="line">    mib[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    mib[<span class="number">3</span>] = AF_LINK;</span><br><span class="line">    mib[<span class="number">4</span>] = NET_RT_IFLIST;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((mib[<span class="number">5</span>] = if_nametoindex(<span class="string">"en0"</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: if_nametoindex error/n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">6</span>, <span class="literal">NULL</span>, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: sysctl, take 1/n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((buf = <span class="built_in">malloc</span>(len)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not allocate memory. error!/n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">6</span>, buf, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: sysctl, take 2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ifm = (struct if_msghdr *)buf;</span><br><span class="line">    sdl = (struct sockaddr_dl *)(ifm + <span class="number">1</span>);</span><br><span class="line">    ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)LLADDR(sdl);</span><br><span class="line">     </span><br><span class="line">    NSString *outstring = [NSString stringWithFormat:@<span class="string">"xxxxxx"</span>, *ptr, *(ptr+<span class="number">1</span>), *(ptr+<span class="number">2</span>), *(ptr+<span class="number">3</span>), *(ptr+<span class="number">4</span>), *(ptr+<span class="number">5</span>)];</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> [outstring uppercaseString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、IP地址"><a href="#三、IP地址" class="headerlink" title="三、IP地址"></a>三、IP地址</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">- (NSString *)getDeviceIPAddresses &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    NSMutableArray *ips = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> BUFFERSIZE = <span class="number">4096</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> <span class="title">ifc</span>;</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> *<span class="title">ifr</span>, <span class="title">ifrcopy</span>;</span></span><br><span class="line">     </span><br><span class="line">    ifc.ifc_len = BUFFERSIZE;</span><br><span class="line">    ifc.ifc_buf = <span class="built_in">buffer</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (ptr = <span class="built_in">buffer</span>; ptr &lt; <span class="built_in">buffer</span> + ifc.ifc_len; )&#123;</span><br><span class="line">             </span><br><span class="line">            ifr = (struct ifreq *)ptr;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (ifr-&gt;ifr_addr.sa_len &gt; len) &#123;</span><br><span class="line">                len = ifr-&gt;ifr_addr.sa_len;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(ifr-&gt;ifr_name) + len;</span><br><span class="line">            <span class="keyword">if</span> (ifr-&gt;ifr_addr.sa_family != AF_INET) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((cptr = (<span class="keyword">char</span> *)<span class="built_in">strchr</span>(ifr-&gt;ifr_name, <span class="string">':'</span>)) != <span class="literal">NULL</span>) *cptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="built_in">memcpy</span>(lastname, ifr-&gt;ifr_name, IFNAMSIZ);</span><br><span class="line">            ifrcopy = *ifr;</span><br><span class="line">            ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ((ifrcopy.ifr_flags &amp; IFF_UP) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">             </span><br><span class="line">            NSString *ip = [NSString  stringWithFormat:@<span class="string">"%s"</span>, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)];</span><br><span class="line">            [ips addObject:ip];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    NSString *deviceIP = @<span class="string">""</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; ips.count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ips.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            deviceIP = [NSString stringWithFormat:@<span class="string">"%@"</span>,ips.lastObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceIP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、CPU"><a href="#四、CPU" class="headerlink" title="四、CPU"></a>四、CPU</h2><h3 id="4-1、CPU总数目"><a href="#4-1、CPU总数目" class="headerlink" title="4.1、CPU总数目"></a>4.1、CPU总数目</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)getCPUCount &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSProcessInfo</span> processInfo].activeProcessorCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2、已使用的CPU比例"><a href="#4-2、已使用的CPU比例" class="headerlink" title="4.2、已使用的CPU比例"></a>4.2、已使用的CPU比例</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">float</span>)getCPUUsage &#123;</span><br><span class="line">    <span class="built_in">float</span> cpu = <span class="number">0</span>;</span><br><span class="line">    NSArray *cpus = [self getPerCPUUsage];</span><br><span class="line">    <span class="keyword">if</span> (cpus.count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (NSNumber *n <span class="keyword">in</span> cpus) &#123;</span><br><span class="line">        cpu += n.<span class="built_in">float</span>Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3、获取每个cpu的使用比例"><a href="#4-3、获取每个cpu的使用比例" class="headerlink" title="4.3、获取每个cpu的使用比例"></a>4.3、获取每个cpu的使用比例</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (NSArray *)getPerCPUUsage &#123;</span><br><span class="line">    processor_info_array_t <span class="variable">_cpuInfo</span>, <span class="variable">_prevCPUInfo</span> = <span class="literal">nil</span>;</span><br><span class="line">    mach_msg_type_number_t <span class="variable">_numCPUInfo</span>, <span class="variable">_numPrevCPUInfo</span> = <span class="number">0</span>;</span><br><span class="line">    unsigned <span class="variable">_numCPUs</span>;</span><br><span class="line">    NSLock *<span class="variable">_cpuUsageLock</span>;</span><br><span class="line">     </span><br><span class="line">    int <span class="variable">_mib</span>[<span class="number">2</span>U] = &#123; CTL_HW, HW_NCPU &#125;;</span><br><span class="line">    size_t <span class="variable">_sizeOfNumCPUs</span> = <span class="built_in">sizeof</span>(<span class="variable">_numCPUs</span>);</span><br><span class="line">    int <span class="variable">_status</span> = sysctl(<span class="variable">_mib</span>, <span class="number">2</span>U, &amp;<span class="variable">_numCPUs</span>, &amp;<span class="variable">_sizeOfNumCPUs</span>, NULL, <span class="number">0</span>U);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_status</span>)</span><br><span class="line">        <span class="variable">_numCPUs</span> = <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="variable">_cpuUsageLock</span> = [[NSLock alloc] init];</span><br><span class="line">     </span><br><span class="line">    natural_t <span class="variable">_numCPUsU</span> = <span class="number">0</span>U;</span><br><span class="line">    kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;<span class="variable">_numCPUsU</span>, &amp;<span class="variable">_cpuInfo</span>, &amp;<span class="variable">_numCPUInfo</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == KERN_SUCCESS) &#123;</span><br><span class="line">        [<span class="variable">_cpuUsageLock</span> <span class="built_in">lock</span>];</span><br><span class="line">         </span><br><span class="line">        NSMutableArray *cpus = [NSMutableArray new];</span><br><span class="line">        <span class="keyword">for</span> (unsigned i = <span class="number">0</span>U; i &lt; <span class="variable">_numCPUs</span>; ++i) &#123;</span><br><span class="line">            Float32 <span class="variable">_inUse</span>, <span class="variable">_total</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">_prevCPUInfo</span>) &#123;</span><br><span class="line">                <span class="variable">_inUse</span> = (</span><br><span class="line">                          (<span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_USER]   - <span class="variable">_prevCPUInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_USER])</span><br><span class="line">                          + (<span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - <span class="variable">_prevCPUInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])</span><br><span class="line">                          + (<span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_NICE]   - <span class="variable">_prevCPUInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_NICE])</span><br><span class="line">                          );</span><br><span class="line">                <span class="variable">_total</span> = <span class="variable">_inUse</span> + (<span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - <span class="variable">_prevCPUInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">_inUse</span> = <span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_USER] + <span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + <span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_NICE];</span><br><span class="line">                <span class="variable">_total</span> = <span class="variable">_inUse</span> + <span class="variable">_cpuInfo</span>[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];</span><br><span class="line">            &#125;</span><br><span class="line">            [cpus addObject:@(<span class="variable">_inUse</span> / <span class="variable">_total</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        [<span class="variable">_cpuUsageLock</span> unlock];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_prevCPUInfo</span>) &#123;</span><br><span class="line">            size_t prevCpuInfoSize = <span class="built_in">sizeof</span>(integer_t) * <span class="variable">_numPrevCPUInfo</span>;</span><br><span class="line">            vm_deallocate(mach_task_self(), (vm_address_t)<span class="variable">_prevCPUInfo</span>, prevCpuInfoSize);</span><br><span class="line">        &#125;</span><br><span class="line">        return cpus;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        return <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、Disk磁盘空间"><a href="#五、Disk磁盘空间" class="headerlink" title="五、Disk磁盘空间"></a>五、Disk磁盘空间</h2><h3 id="5-1、获取磁盘总空间"><a href="#5-1、获取磁盘总空间" class="headerlink" title="5.1、获取磁盘总空间"></a>5.1、获取磁盘总空间</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">- (int64_t)getTotalDiskSpace &#123;</span><br><span class="line">    NSError *<span class="built_in">error</span> = nil;</span><br><span class="line">    NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() <span class="built_in">error</span>:&amp;<span class="built_in">error</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">error</span>) <span class="built_in">return</span> -<span class="number">1</span>;</span><br><span class="line">    int64_t <span class="built_in">space</span> =  [[attrs objectForKey:NSFileSystemSize] longLongValue];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">space</span> &lt; <span class="number">0</span>) <span class="built_in">space</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">space</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2、获取未使用的磁盘空间"><a href="#5-2、获取未使用的磁盘空间" class="headerlink" title="5.2、获取未使用的磁盘空间"></a>5.2、获取未使用的磁盘空间</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">- (int64_t)getFreeDiskSpace &#123;</span><br><span class="line">    NSError *<span class="built_in">error</span> = nil;</span><br><span class="line">    NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() <span class="built_in">error</span>:&amp;<span class="built_in">error</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">error</span>) <span class="built_in">return</span> -<span class="number">1</span>;</span><br><span class="line">    int64_t <span class="built_in">space</span> =  [[attrs objectForKey:NSFileSystemFreeSize] longLongValue];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">space</span> &lt; <span class="number">0</span>) <span class="built_in">space</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">space</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3、获取已使用的磁盘空间"><a href="#5-3、获取已使用的磁盘空间" class="headerlink" title="5.3、获取已使用的磁盘空间"></a>5.3、获取已使用的磁盘空间</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">int</span>64_t)getUsedDiskSpace &#123;</span><br><span class="line">    <span class="built_in">int</span>64_t totalDisk = [self getTotalDiskSpace];</span><br><span class="line">    <span class="built_in">int</span>64_t freeDisk = [self getFreeDiskSpace];</span><br><span class="line">    <span class="keyword">if</span> (totalDisk &lt; <span class="number">0</span> || freeDisk &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">int</span>64_t usedDisk = totalDisk - freeDisk;</span><br><span class="line">    <span class="keyword">if</span> (usedDisk &lt; <span class="number">0</span>) usedDisk = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> usedDisk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、Memory内存相关数据"><a href="#六、Memory内存相关数据" class="headerlink" title="六、Memory内存相关数据"></a>六、Memory内存相关数据</h2><h3 id="6-1、系统总内存空间"><a href="#6-1、系统总内存空间" class="headerlink" title="6.1、系统总内存空间"></a>6.1、系统总内存空间</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">int</span>64_t)getTotalMemory &#123;</span><br><span class="line">    <span class="built_in">int</span>64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory];</span><br><span class="line">    <span class="keyword">if</span> (totalMemory &lt; <span class="number">-1</span>) totalMemory = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> totalMemory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2、活跃的内存-正在使用或者很短时间内被使用过"><a href="#6-2、活跃的内存-正在使用或者很短时间内被使用过" class="headerlink" title="6.2、活跃的内存,正在使用或者很短时间内被使用过"></a>6.2、活跃的内存,正在使用或者很短时间内被使用过</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getActiveMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_stat.active_count * page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3、最近使用过-但是目前处于不活跃状态的内存"><a href="#6-3、最近使用过-但是目前处于不活跃状态的内存" class="headerlink" title="6.3、最近使用过,但是目前处于不活跃状态的内存"></a>6.3、最近使用过,但是目前处于不活跃状态的内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getInActiveMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_stat.inactive_count * page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4、空闲的内存空间"><a href="#6-4、空闲的内存空间" class="headerlink" title="6.4、空闲的内存空间"></a>6.4、空闲的内存空间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getFreeMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_stat.free_count * page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5、已使用的内存空间"><a href="#6-5、已使用的内存空间" class="headerlink" title="6.5、已使用的内存空间"></a>6.5、已使用的内存空间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getUsedMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6、用来存放内核和数据结构的内存-framework、用户级别的应用无法分配"><a href="#6-6、用来存放内核和数据结构的内存-framework、用户级别的应用无法分配" class="headerlink" title="6.6、用来存放内核和数据结构的内存,framework、用户级别的应用无法分配"></a>6.6、用来存放内核和数据结构的内存,framework、用户级别的应用无法分配</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getWiredMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_stat.wire_count * page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-7、可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间"><a href="#6-7、可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间" class="headerlink" title="6.7、可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间"></a>6.7、可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int64_t</span>)getPurgableMemory &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> host_port = mach_host_self();</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> host_size = <span class="keyword">sizeof</span>(<span class="keyword">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">integer_t</span>);</span><br><span class="line">    <span class="keyword">vm_size_t</span> page_size;</span><br><span class="line">    <span class="keyword">vm_statistics_data_t</span> vm_stat;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kern;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    kern = host_page_size(host_port, &amp;page_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    kern = host_statistics(host_port, HOST_VM_INFO, (<span class="keyword">host_info_t</span>)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    <span class="keyword">if</span> (kern != KERN_SUCCESS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_stat.purgeable_count * page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iPhone型号</tag>
        <tag>cpu</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>TextField标记区选择区</title>
    <url>/TextField%E6%A0%87%E8%AE%B0%E5%8C%BA%E9%80%89%E6%8B%A9%E5%8C%BA.html</url>
    <content><![CDATA[<p>在调试UITextField控件的时候，有时候不得不满足各种奇怪(pa)的需求，因此必须了解各种api。只有掌握了足够的api，才能定制出我们想要的效果（满足各种奇葩需求）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resetTextWithNoWhite </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">NSString</span> * textString = <span class="keyword">self</span>.text;</span><br><span class="line">        <span class="built_in">NSRange</span>    markedRang = [<span class="keyword">self</span> markedRang];</span><br><span class="line">        <span class="built_in">NSInteger</span>  position   = markedRang.location;</span><br><span class="line">        <span class="built_in">NSInteger</span>  length     = markedRang.length;</span><br><span class="line">        <span class="built_in">NSString</span> * markedText = [textString substringWithRange:markedRang];<span class="comment">//取出被标记的文字</span></span><br><span class="line">        textString = [textString stringByReplacingCharactersInRange:markedRang withString:<span class="string">@""</span>];<span class="comment">//暂时替换掉被标记的文字</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRange</span> whiteRang = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        whiteRang = [textString rangeOfString:<span class="string">@" "</span>];<span class="comment">//找出剩下的文字中空格的位置</span></span><br><span class="line">        <span class="keyword">while</span> (whiteRang.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            textString = [textString stringByReplacingCharactersInRange:whiteRang withString:<span class="string">@""</span>];</span><br><span class="line">            <span class="keyword">if</span> (position &gt; whiteRang.location) &#123;</span><br><span class="line">                position = position - whiteRang.length;</span><br><span class="line">            &#125;</span><br><span class="line">            whiteRang = [textString rangeOfString:<span class="string">@" "</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        textString = [textString stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(position, <span class="number">0</span>) withString:markedText];<span class="comment">//替换回</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"*******\n markedText:%@ \n position:%ld \n length:%ld \n ******"</span>,markedText,(<span class="keyword">long</span>)position,(<span class="keyword">long</span>)length);</span><br><span class="line">        <span class="keyword">if</span> (markedText.length) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> performWithoutAnimation:^&#123;</span><br><span class="line">                [<span class="keyword">self</span> setMarkedText:textString selectedRange:<span class="built_in">NSMakeRange</span>(position, markedText.length)];<span class="comment">//不仅会设置标记区，也会设置选中区，这里textString为整个textField的text</span></span><br><span class="line">                [<span class="keyword">self</span> setSelectedRange:<span class="built_in">NSMakeRange</span>(position + markedText.length, <span class="number">0</span>)];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> setText:textString];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记区 - 标记区</span></span><br><span class="line">- (<span class="built_in">NSRange</span>)markedRang</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * beginning      = <span class="keyword">self</span>.beginningOfDocument;</span><br><span class="line">    <span class="built_in">UITextRange</span>     * markedRang     = <span class="keyword">self</span>.markedTextRange;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * markedStart    = markedRang.start;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * markedEnd      = markedRang.end;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> location = [<span class="keyword">self</span> offsetFromPosition:beginning toPosition:markedStart];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> length   = [<span class="keyword">self</span> offsetFromPosition:markedStart toPosition:markedEnd];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSMakeRange</span>(location, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择区 - 复制的时候选中</span></span><br><span class="line">- (<span class="built_in">NSRange</span>)selectedRange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * beginning      = <span class="keyword">self</span>.beginningOfDocument;</span><br><span class="line">    <span class="built_in">UITextRange</span>     * selectedRange  = <span class="keyword">self</span>.selectedTextRange;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * selectionStart = selectedRange.start;</span><br><span class="line">    <span class="built_in">UITextPosition</span>  * selectionEnd   = selectedRange.end;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> location = [<span class="keyword">self</span> offsetFromPosition:beginning toPosition:selectionStart];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> length   = [<span class="keyword">self</span> offsetFromPosition:selectionStart toPosition:selectionEnd];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSMakeRange</span>(location, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSelectedRange:(<span class="built_in">NSRange</span>)range  <span class="comment">// 备注：UITextField必须为第一响应者才有效</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITextPosition</span>   * beginning      = <span class="keyword">self</span>.beginningOfDocument;</span><br><span class="line">    <span class="built_in">UITextPosition</span>   * startPosition  = [<span class="keyword">self</span> positionFromPosition:beginning offset:range.location];</span><br><span class="line">    <span class="built_in">UITextPosition</span>   * endPosition    = [<span class="keyword">self</span> positionFromPosition:beginning offset:range.location + range.length];</span><br><span class="line">    <span class="built_in">UITextRange</span>      * selectionRange = [<span class="keyword">self</span> textRangeFromPosition:startPosition toPosition:endPosition];</span><br><span class="line">    [<span class="keyword">self</span> setSelectedTextRange:selectionRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>textField</tag>
      </tags>
  </entry>
  <entry>
    <title>Git中ssh配置（完美解决）</title>
    <url>/Git%E4%B8%ADssh%E9%85%8D%E7%BD%AE%EF%BC%88%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%EF%BC%89.html</url>
    <content><![CDATA[<p>下面详述一下配置git的详细过程。<br>命令行：</p>
<h3 id="一、ssh-keygen-t-rsa-C-邮箱"><a href="#一、ssh-keygen-t-rsa-C-邮箱" class="headerlink" title="一、ssh-keygen -t rsa -C 邮箱"></a><strong>一、</strong>ssh-keygen -t rsa -C 邮箱</h3><p>注释：这里的邮箱加不加（单，双）引号都是一样的<br>点击enter之后如出现如下提示：</p>
<h3 id="二、Enter-file-in-which-to-save-the-key-Users-yourname-ssh-id-rsa-Users-yourname-ssh-id-rsa-company"><a href="#二、Enter-file-in-which-to-save-the-key-Users-yourname-ssh-id-rsa-Users-yourname-ssh-id-rsa-company" class="headerlink" title="二、Enter file in which to save the key (/Users/yourname/.ssh/id_rsa): /Users/yourname/.ssh/id_rsa_company"></a><strong>二、</strong>Enter file in which to save the key (/Users/yourname/.ssh/id_rsa): /Users/yourname/.ssh/id_rsa_company</h3><p>注释：/Users/yourname/.ssh/id_rsa_company   这个是路径，生成的ssh文件名字就是id_rsa_company，可以根据喜好自定义</p>
<h3 id="三、Enter-passphrase-empty-for-no-passphrase"><a href="#三、Enter-passphrase-empty-for-no-passphrase" class="headerlink" title="三、Enter passphrase (empty for no passphrase):"></a><strong>三、</strong>Enter passphrase (empty for no passphrase):</h3><p>注释：这里是让输入密码，可以不输入，避免以后每次都要输入密码的麻烦</p>
<h3 id="四、The-key-fingerprint-is"><a href="#四、The-key-fingerprint-is" class="headerlink" title="四、The key fingerprint is:"></a><strong>四、</strong>The key fingerprint is:</h3><p>注释：出现上述一串包括一个image表示生成成功，打开id_rsa_company.pub文件，复制粘贴到你的git中的ssh配置中</p>
<h3 id="五、ssh-add-ssh-id-rsa-company"><a href="#五、ssh-add-ssh-id-rsa-company" class="headerlink" title="五、ssh-add ~/.ssh/id_rsa_company"></a><strong>五、</strong>ssh-add ~/.ssh/id_rsa_company</h3><p>注释：这一步很重要，当时在做的时候缺少了这一步，一直报错，（在github中这步可以省略，可能是因为公开的原因）</p>
<h3 id="六、配置多个平台，多个账户"><a href="#六、配置多个平台，多个账户" class="headerlink" title="六、配置多个平台，多个账户"></a><strong>六、</strong>配置多个平台，多个账户</h3><p>打开 ~/.ssh/config 文件，用文本编辑</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --- Sourcetree Generated ---</span></span><br><span class="line"> Host GitHub</span><br><span class="line"> HostName github.com</span><br><span class="line"><span class="built_in"> User </span>userName</span><br><span class="line"> PreferredAuthentications publickey</span><br><span class="line"> IdentityFile /Users/qiushan/.ssh/id_rsa</span><br><span class="line"> UseKeychain <span class="literal">yes</span></span><br><span class="line"> AddKeysToAgent <span class="literal">yes</span></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br></pre></td></tr></table></figure>
<p>HostName 对应网站的host，或者自定义一个，去host文件中指向对应网站<br>IdentityFile 对应到生成的ssh路径，多个账号配置不同的路径</p>
<h3 id="七、检测是否成功"><a href="#七、检测是否成功" class="headerlink" title="七、检测是否成功"></a><strong>七、</strong>检测是否成功</h3><p>命令行：ssh -T <a href="mailto:git@100.10.10.100">git@100.10.10.100</a><br>注释：这个命令行是检测是否配置成功的。（<a href="mailto:git@100.10.10.100">git@100.10.10.100</a>替换成你的git地址，注意是地址，不是仓库）<br>点击enter之后：Are you sure you want to continue connecting (yes/no)? yes<br>输入yes<br>。。。<br>Welcome to GitLab<br><strong>恭喜，配置成功。可以尽情拉取推送代码了。</strong></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>CATransform3D详解</title>
    <url>/CATransform3D%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="一、view图层"><a href="#一、view图层" class="headerlink" title="一、view图层"></a>一、view图层</h2><p>既然要了解就必须先要了解view和layer之间的关系。</p>
<h3 id="1-1、view与layer职责"><a href="#1-1、view与layer职责" class="headerlink" title="1.1、view与layer职责"></a>1.1、view与layer职责</h3><p>在ios中，每个view都至少会对应一个layer，layer主要负责绘制图层，显示效果。而view则是可以响应用户的触摸事件。属于各有各的分工。</p>
<h3 id="1-2、坐标系"><a href="#1-2、坐标系" class="headerlink" title="1.2、坐标系"></a>1.2、坐标系</h3><p>iOS中坐标系是一个三维坐标系，视角垂直于屏幕，x轴向右，y轴向下，z轴垂直屏幕向外</p>
<h3 id="1-3、坐标系原点"><a href="#1-3、坐标系原点" class="headerlink" title="1.3、坐标系原点"></a>1.3、坐标系原点</h3><h4 id="1-3-1、默认情况"><a href="#1-3-1、默认情况" class="headerlink" title="1.3.1、默认情况"></a>1.3.1、默认情况</h4><p>默认情况下，view相对于子视图的坐标原点为(0,0)【子视图是以父试图原点进行参照布局的】。这种情况一般是设置view的frame以及bounds为（0，0，200，100），注意设置bounds时x和y必须均为0.</p>
<h4 id="1-3-2、非默认情况"><a href="#1-3-2、非默认情况" class="headerlink" title="1.3.2、非默认情况"></a>1.3.2、非默认情况</h4><p>非默认情况下，假如bounds为（20，20，200，100），这个时候，并不是将当前图层的坐标原点相对于图层左上角偏移了（20，20），而是将图层左上角点的坐标设置成了（20，20），本地坐标系的坐标原点偏移了（-20，-20）。如果view的子视图的frame.x = 0,frame.y = 0,此时这个子视图的左上角就会出现在view的左上角（-20，-20）处。</p>
<h4 id="1-3-3、改变layer的anchorPoint"><a href="#1-3-3、改变layer的anchorPoint" class="headerlink" title="1.3.3、改变layer的anchorPoint"></a>1.3.3、改变layer的anchorPoint</h4><p>改变layer的anchorPoint，layer的anchorPoint默认值是（0.5，0.5）。layer的anchorPoint的具体作用在下面讨论。</p>
<h2 id="二、positon与anchorPoint"><a href="#二、positon与anchorPoint" class="headerlink" title="二、positon与anchorPoint"></a>二、positon与anchorPoint</h2><p>view的frame，bounds，center对应layer中的frame，bounds，position。layer中的anchorPoint在view中是没有的。以下说的都是layer的属性，除了anchorPoint以外，其他的都跟view意义相同。</p>
<h3 id="2-1、不得不说一下iOS确定一个图层位置的原理"><a href="#2-1、不得不说一下iOS确定一个图层位置的原理" class="headerlink" title="2.1、不得不说一下iOS确定一个图层位置的原理"></a>2.1、不得不说一下iOS确定一个图层位置的原理</h3><p>在设置一个图层frame等跟位置有关的属性时，<br>layer.position.x = layer.frame.origin.x + layer.anchorPoint.x * layer.frame.size.width<br>layer.position.y = layer.frame.origin.y + layer.anchorPoint.y * layer.frame.size.height<br>等同于该图层layer的position。（其实叫center或者position为中心点不太准确，应该叫做基准点较为准确一点。至于为什么，继续看吧）</p>
<h3 id="2-2、在layer的frame确定的情况下，更改anchorPoint"><a href="#2-2、在layer的frame确定的情况下，更改anchorPoint" class="headerlink" title="2.2、在layer的frame确定的情况下，更改anchorPoint"></a>2.2、在layer的frame确定的情况下，更改anchorPoint</h3><h4 id="2-2-1、anchorPoint是什么？"><a href="#2-2-1、anchorPoint是什么？" class="headerlink" title="2.2.1、anchorPoint是什么？"></a>2.2.1、anchorPoint是什么？</h4><p>anchorPoint默认值是（0.5，0.5），对应于layer的中心点。（0，0）对应左上角，（1，1）对应于右下角，范围在0 - 1之间。在做旋转动画时，anchorPoint指示着旋转的基准点，即是围绕着该点旋转。</p>
<h4 id="2-2-2、改变anchorPoint，影响什么"><a href="#2-2-2、改变anchorPoint，影响什么" class="headerlink" title="2.2.2、改变anchorPoint，影响什么"></a>2.2.2、改变anchorPoint，影响什么</h4><p>假如layer的frame都确定了，且width和height都不为0.此时改变anchorPoint由默认值（0.5，0.5）变为（1.0，1.0），改变后view的位置和大小会发生变化么？<br>大小不会改变，位置会发生变化。此时，view的center坐标点不会发生变化，假如为（200，300）。但是layer的位置会发生变化。因为我们将anchorPoint改为了（1.0，1.0）为右下角的点。所以此时view右下角的点会在view之前的center点位置上。即此时view的右下角会在点（200，300）上。<br>此时：<br>layer.frame.origin.x = layer.position.x - layer.anchorPoint.x * layer.frame.size.width<br>layer.frame.origin.y = layer.position.y - layer.anchorPoint.y * layer.frame.size.height</p>
<h4 id="2-2-3、结论"><a href="#2-2-3、结论" class="headerlink" title="2.2.3、结论"></a>2.2.3、结论</h4><p>单独改变anchorPoint，会影响layer的frame.origin.x和layer.frame.origin.y,以及layer做动画时的基准点。<br>不会影响position的值，但是基准点变了。所以同样适用于view。<br>要想不让layer位置改变，只能重新计算新的center</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="built_in">set</span>AnchorPoint:(CGPoint)<span class="built_in">anchor</span>Point <span class="keyword">for</span>View:(UIView *)view</span><br><span class="line">&#123;</span><br><span class="line">  CGRect oldFrame = view.frame;</span><br><span class="line">  view.layer.<span class="built_in">anchor</span>Point = <span class="built_in">anchor</span>Point;</span><br><span class="line">  view.center = CGPointMake(oldFrame.origin.x + oldFrame.size.width * <span class="built_in">anchor</span>Point.x,oldFrame.origin.y + oldFrame.size.height * <span class="built_in">anchor</span>Point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、CATransform3D（3D变换）"><a href="#三、CATransform3D（3D变换）" class="headerlink" title="三、CATransform3D（3D变换）"></a>三、CATransform3D（3D变换）</h2><h3 id="3-1、认识CATransform3D"><a href="#3-1、认识CATransform3D" class="headerlink" title="3.1、认识CATransform3D"></a>3.1、认识CATransform3D</h3><p>CATransform3D 的数据结构定义了一个同质的三维变换（4x4CGFloat值的矩阵），用于图层的旋转，缩放，偏移，歪斜和应用的透视。CATransform3D的结构体定义及各成员变量的职能如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">struct CATra<span class="symbol">nsform3</span>D</span><br><span class="line">&#123;</span><br><span class="line">  CGFloat <span class="name">m11</span>, <span class="name">m12</span>, <span class="name">m13</span>, <span class="name">m14</span>;</span><br><span class="line">  CGFloat <span class="name">m21</span>, <span class="name">m22</span>, <span class="name">m23</span>, <span class="name">m24</span>;</span><br><span class="line">  CGFloat <span class="name">m31</span>, <span class="name">m32</span>, <span class="name">m33</span>, <span class="name">m34</span>;</span><br><span class="line">  CGFloat <span class="name">m41</span>, <span class="name">m42</span>, <span class="name">m43</span>, <span class="name">m44</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、各个api对应参数："><a href="#3-2、各个api对应参数：" class="headerlink" title="3.2、各个api对应参数："></a>3.2、各个api对应参数：</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CATransform3DRotate</span>    (<span class="built_in">CATransform3D</span> t, <span class="built_in">CGFloat</span> angle, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)<span class="comment">//旋转</span></span><br><span class="line"><span class="built_in">CATransform3DScale</span>     (<span class="built_in">CATransform3D</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz)<span class="comment">//缩放</span></span><br><span class="line"><span class="built_in">CATransform3DTranslate</span> (<span class="built_in">CATransform3D</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)<span class="comment">//平移</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3、改变其中的值，对矩阵的影响"><a href="#3-3、改变其中的值，对矩阵的影响" class="headerlink" title="3.3、改变其中的值，对矩阵的影响"></a>3.3、改变其中的值，对矩阵的影响</h3><h4 id="3-3-1、改变缩放与平移时"><a href="#3-3-1、改变缩放与平移时" class="headerlink" title="3.3.1、改变缩放与平移时"></a>3.3.1、改变缩放与平移时</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">struct CATra<span class="symbol">nsform3</span>D</span><br><span class="line">&#123;</span><br><span class="line">  CGFloat <span class="name">m11</span> = sx,         <span class="name">m12</span> = <span class="number">0</span>,           <span class="name">m13</span> = <span class="number">0</span>,            <span class="name">m14</span> = <span class="number">0</span>;</span><br><span class="line">  CGFloat <span class="name">m21</span> = <span class="number">0</span>,          <span class="name">m22</span> = sy,          <span class="name">m23</span> = <span class="number">0</span>,            <span class="name">m24</span> = <span class="number">0</span>;</span><br><span class="line">  CGFloat <span class="name">m31</span> = <span class="number">0</span>,          <span class="name">m32</span> = <span class="number">0</span>,           <span class="name">m33</span> = sz,           <span class="name">m34</span> = <span class="number">0</span>;</span><br><span class="line">  CGFloat <span class="name">m41</span> = tx,         <span class="name">m42</span> = ty,          <span class="name">m43</span> = tz,           <span class="name">m44</span> = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2、改变旋转参数"><a href="#3-3-2、改变旋转参数" class="headerlink" title="3.3.2、改变旋转参数"></a>3.3.2、改变旋转参数</h4><p>注意：这里的x，y，z只有1或者-1两个值，也就是如果x如果大于0即为1，小于0即为-1，否则为0。<br>sin与cos都是针对弧度进行计算。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">float u = <span class="symbol">x</span>/<span class="built_in">sqrt</span>(<span class="symbol">x</span>*<span class="symbol">x</span> + <span class="symbol">y</span>*<span class="symbol">y</span> + z*z)<span class="comment">//sqrt为开方</span></span><br><span class="line">falot v = <span class="symbol">y</span>/<span class="built_in">sqrt</span>(<span class="symbol">x</span>*<span class="symbol">x</span> + <span class="symbol">y</span>*<span class="symbol">y</span> + z*z)</span><br><span class="line">float w = z/<span class="built_in">sqrt</span>(<span class="symbol">x</span>*<span class="symbol">x</span> + <span class="symbol">y</span>*<span class="symbol">y</span> + z*z)</span><br><span class="line">float θ = angle</span><br><span class="line"></span><br><span class="line">struct CATransform3D</span><br><span class="line">&#123;</span><br><span class="line">  CGFloat m11 = u²+(<span class="number">1</span>-u²)*<span class="built_in">cos</span>θ,         m12 = uv*(<span class="number">1</span>-<span class="built_in">cos</span>θ)-w*<span class="built_in">sin</span>θ,     m13 = uw*(<span class="number">1</span>-<span class="built_in">cos</span>θ)+v*<span class="built_in">sin</span>θ,    m14 = <span class="number">0</span>;</span><br><span class="line">  CGFloat m21 = uv*(<span class="number">1</span>-<span class="built_in">cos</span>θ)+w*<span class="built_in">sin</span>θ,     m22 = v²+(<span class="number">1</span>-v²)*<span class="built_in">cos</span>θ,         m23 = vw*(<span class="number">1</span>-<span class="built_in">cos</span>θ)-u*<span class="built_in">sin</span>θ,    m24 = <span class="number">0</span>;</span><br><span class="line">  CGFloat m31 = uw*(<span class="number">1</span>-<span class="built_in">cos</span>θ)-v*<span class="built_in">sin</span>θ,     m32 = vw*(<span class="number">1</span>-<span class="built_in">cos</span>θ)+u*<span class="built_in">sin</span>θ,     m33 = w²+(<span class="number">1</span>-w²)*<span class="built_in">cos</span>θ,        m34 = <span class="number">0</span>;</span><br><span class="line">  CGFloat m41 = <span class="number">0</span>,                      m42 = <span class="number">0</span>,                      m43 = <span class="number">0</span>,                     m44 = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>CATransform3DRotate(CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)<br>在经过以上函数生成矩阵之后，用生成的矩阵 x 传进来的矩阵t，计算出新的矩阵。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">struct CATra<span class="symbol">nsform3</span>D</span><br><span class="line">&#123;</span><br><span class="line">  CGFloat  <span class="name">m11</span>（x缩放）, <span class="name">m12</span>（切变） , <span class="name">m13</span>（切变） , <span class="name">m14</span>（）;</span><br><span class="line">  CGFloat  <span class="name">m21</span>（切变） , <span class="name">m22</span>（y缩放）, <span class="name">m23</span>（切变） , <span class="name">m24</span>（）;</span><br><span class="line">  CGFloat  <span class="name">m31</span>（切变） , <span class="name">m32</span>（切变） , <span class="name">m33</span>（z缩放）, <span class="name">m34</span>（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;</span><br><span class="line">  CGFloat  <span class="name">m41</span>（x平移）, <span class="name">m42</span>（y平移）, <span class="name">m43</span>（z平移）, <span class="name">m44</span>（）;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://www.cnblogs.com/ll-10/p/5470637.html" target="_blank" rel="noopener">图形变换之基本矩阵变换</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode调试LLDB</title>
    <url>/Xcode%E8%B0%83%E8%AF%95LLDB.html</url>
    <content><![CDATA[<p>XCode版本：9.2 (9C40b)</p>
<p>apropos<br>– List debugger commands related to a word or subject.<br>列出与单词或主题相关的调试器命令。</p>
<p>breakpoint<br>– Commands for operating on breakpoints (see ‘help b’ for<br>shorthand.)<br>在断点上运行的命令（参见’help b’速记。）</p>
<p>bugreport<br>– Commands for creating domain-specific bug reports.<br>用于创建特定于域的错误报告的命令。</p>
<p>command<br>– Commands for managing custom LLDB commands.<br>用于管理自定义LLDB命令的命令。</p>
<p>disassemble<br>– Disassemble specified instructions in the current<br>target. Defaults to the current function for the<br>current thread and stack frame.<br>拆解当前的指定说明目标。默认为当前的函数当前线程和堆栈帧。</p>
<p>expression<br>– Evaluate an expression on the current thread. Displays<br>any returned value with LLDB’s default formatting.<br>评估当前线程上的表达式。显示器任何返回值与LLDB的默认格式。</p>
<p>frame<br>– Commands for selecting and examing the current thread’s<br>stack frames.<br>选择和检查当前线程的命令堆栈帧。</p>
<p>gdb-remote<br>– Connect to a process via remote GDB server. If no host<br>is specifed, localhost is assumed.<br>通过远程GDB服务器连接到进程。如果没有主机被指定，localhost被假定。</p>
<p>gui<br>– Switch into the curses based GUI mode.<br>切换到基于curses的GUI模式。</p>
<p>help<br>– Show a list of all debugger commands, or give details<br>about a specific command.<br>显示所有调试器命令的列表，或者提供详细信息关于一个特定的命令。</p>
<p>kdp-remote<br>– Connect to a process via remote KDP server. If no UDP<br>port is specified, port 41139 is assumed.<br>通过远程KDP服务器连接到进程。如果没有UDP端口被指定，端口41139被假定。</p>
<p>language<br>– Commands specific to a source language.<br>特定于源语言的命令。</p>
<p>log<br>– Commands controlling LLDB internal logging.<br>控制LLDB内部记录的命令。</p>
<p>memory<br>– Commands for operating on memory in the current target<br>process.<br>用于在当前目标中对内存进行操作的命令处理。</p>
<p>platform<br>– Commands to manage and create platforms.<br>管理和创建平台的命令。</p>
<p>plugin<br>– Commands for managing LLDB plugins.<br>管理LLDB插件的命令。</p>
<p>process<br>– Commands for interacting with processes on the current<br>platform.<br>与当前进程交互的命令平台。</p>
<p>quit<br>– Quit the LLDB debugger.<br>退出LLDB调试器。</p>
<p>register<br>– Commands to access registers for the current thread and<br>stack frame.<br>访问当前线程和寄存器的命令堆栈框架。</p>
<p>script<br>– Invoke the script interpreter with provided code and<br>display any results. Start the interactive interpreter<br>if no code is supplied.<br>用提供的代码和调用脚本解释器显示任何结果。启动交互式解释器如果没有代码提供。</p>
<p>settings<br>– Commands for managing LLDB settings.<br>用于管理LLDB设置的命令。</p>
<p>source<br>– Commands for examining source code described by debug<br>information for the current target process.<br>检查由调试描述的源代码的命令当前目标进程的信息。</p>
<p>target<br>– Commands for operating on debugger targets.<br>用于在调试器目标上运行的命令。</p>
<p>thread<br>– Commands for operating on one or more threads in the<br>current process.<br>在一个或多个线程上运行的命令当前进程。</p>
<p>type<br>– Commands for operating on the type system.<br>在类型系统上运行的命令。</p>
<p>version<br>– Show the LLDB debugger version.<br>显示LLDB调试器版本。</p>
<p>watchpoint<br>– Commands for operating on watchpoints.<br>用于在观察点上操作的命令。</p>
<p>Current command abbreviations (type ‘help command alias’ for more info):<br>当前命令缩写（更多信息请输入“help command alias”）</p>
<p>add-dsym<br>– Add a debug symbol file to one of the target’s current modules<br>by specifying a path to a debug symbols file, or using the<br>options to specify a module to download symbols for.<br>将调试符号文件添加到目标的当前模块之一 通过指定调试符号文件的路径，或使用选项来指定一个模块下载符号。</p>
<p>attach<br>– Attach to process by ID or name.<br>通过ID或名称附加到进程。</p>
<p>b<br>– Set a breakpoint using one of several shorthand formats.<br>使用几种简写格式之一来设置断点。</p>
<p>bt<br>– Show the current thread’s call stack. Any numeric argument<br>displays at most that many frames. The argument ‘all’ displays<br>all threads.<br>显示当前线程的调用堆栈。任何数字参数最多显示多个帧。显示“全部”参数所有线程。</p>
<p>c<br>– Continue execution of all threads in the current process.<br>继续执行当前进程中的所有线程。</p>
<p>call<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何<br>以LLDB的默认格式返回值。</p>
<p>continue<br>– Continue execution of all threads in the current process.<br>继续执行当前进程中的所有线程。</p>
<p>detach<br>– Detach from the current target process.<br>从当前目标进程中分离出来。</p>
<p>di<br>– Disassemble specified instructions in the current target.<br>Defaults to the current function for the current thread and<br>stack frame.<br>反汇编当前目标中的指定指令。默认为当前线程的当前函数堆栈框架。</p>
<p>dis<br>– Disassemble specified instructions in the current target.<br>Defaults to the current function for the current thread and<br>stack frame.<br>反汇编当前目标中的指定指令。默认为当前线程的当前函数堆栈框架。</p>
<p>display<br>– Evaluate an expression at every stop (see ‘help target<br>stop-hook’.)<br>在每一站评估表达（请参阅“帮助目标”停止挂机”。）</p>
<p>down<br>– Select a newer stack frame. Defaults to moving one frame, a<br>numeric argument can specify an arbitrary number.<br>选择一个较新的堆栈帧。默认移动一帧，a数字参数可以指定任意数字。</p>
<p>env<br>– Shorthand for viewing and setting environment variables.<br>查看和设置环境变量的简写。</p>
<p>exit<br>– Quit the LLDB debugger.<br>退出LLDB调试器。</p>
<p>f<br>– Select the current stack frame by index from within the current<br>thread (see ‘thread backtrace’.)<br>从当前的索引中选择当前的堆栈帧线程（请参阅“线程回溯”）。</p>
<p>file<br>– Create a target using the argument as the main executable.<br>使用参数作为主要的可执行文件创建一个目标。</p>
<p>finish<br>– Finish executing the current stack frame and stop after<br>returning. Defaults to current thread unless specified.<br>完成当前堆栈帧的执行并停止返回。除非指定，否则默认为当前线程。</p>
<p>image<br>– Commands for accessing information for one or more target<br>modules.<br>用于访问一个或多个目标的信息的命令模块。</p>
<p>j<br>– Set the program counter to a new address.<br>将程序计数器设置为新地址。</p>
<p>jump<br>– Set the program counter to a new address.<br>将程序计数器设置为新地址。</p>
<p>kill<br>– Terminate the current target process.<br>终止当前目标进程。</p>
<p>l<br>– List relevant source code using one of several shorthand formats.<br>使用几种简写格式之一列出相关的源代码。</p>
<p>list<br>– List relevant source code using one of several shorthand formats.<br>使用几种简写格式之一列出相关的源代码。</p>
<p>n<br>– Source level single step, stepping over calls. Defaults to<br>current thread unless specified.<br>来源级别单步骤，跨越通话。默认为当前线程，除非指定。</p>
<p>next<br>– Source level single step, stepping over calls. Defaults to<br>current thread unless specified.<br>来源级别单步骤，跨越通话。默认为当前线程，除非指定。</p>
<p>nexti<br>– Instruction level single step, stepping over calls. Defaults to<br>current thread unless specified.<br>指令级单步执行，逐步调用。默认为当前线程，除非指定。</p>
<p>ni<br>– Instruction level single step, stepping over calls. Defaults to<br>current thread unless specified.<br>指令级单步执行，逐步调用。默认为当前线程，除非指定。</p>
<p>p<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何以LLDB的默认格式返回值。</p>
<p>parray<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何以LLDB的默认格式返回值。</p>
<p>po<br>– Evaluate an expression on the current thread. Displays any<br>returned value with formatting controlled by the type’s author.<br>在当前线程上评估一个表达式。显示任何返回值的格式由该作者控制。</p>
<p>poarray<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何以LLDB的默认格式返回值。</p>
<p>print<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何以LLDB的默认格式返回值。</p>
<p>q<br>– Quit the LLDB debugger.<br>退出LLDB调试器。</p>
<p>r<br>– Launch the executable in the debugger.<br>在调试器中启动可执行文件。</p>
<p>rbreak<br>– Sets a breakpoint or set of breakpoints in the executable.<br>在可执行文件中设置一个断点或一组断点。</p>
<p>repl<br>– Evaluate an expression on the current thread. Displays any<br>returned value with LLDB’s default formatting.<br>在当前线程上评估一个表达式。显示任何以LLDB的默认格式返回值。</p>
<p>run<br>– Launch the executable in the debugger.<br>在调试器中启动可执行文件。</p>
<p>s<br>– Source level single step, stepping into calls. Defaults to<br>current thread unless specified.<br>来源级单步骤，进入呼叫。默认为当前线程，除非指定。</p>
<p>si<br>– Instruction level single step, stepping into calls. Defaults to<br>current thread unless specified.<br>指令级单步，加入呼叫。默认为当前线程，除非指定。</p>
<p>sif<br>– Step through the current block, stopping if you step directly<br>into a function whose name matches the TargetFunctionName.<br>逐步通过当前块，如果直接步进则停止转换成名称与TargetFunctionName匹配的函数。</p>
<p>step<br>– Source level single step, stepping into calls. Defaults to<br>current thread unless specified.<br>来源级单步骤，进入呼叫。默认为当前线程，除非指定。</p>
<p>stepi<br>– Instruction level single step, stepping into calls. Defaults to<br>current thread unless specified.<br>指令级单步，加入呼叫。默认为当前线程，除非指定。</p>
<p>t<br>– Change the currently selected thread.<br>更改当前选择的线程。</p>
<p>tbreak<br>– Set a one-shot breakpoint using one of several shorthand<br>formats.<br>使用几种简写中的一种设置一次性断点格式。</p>
<p>undisplay<br>– Stop displaying expression at every stop (specified by stop-hook<br>index.)<br>停止在每个停止处显示表达式（由stop-hook指定）指数。）</p>
<p>up<br>– Select an older stack frame. Defaults to moving one frame, a<br>numeric argument can specify an arbitrary number.<br>选择一个较旧的堆栈帧。 默认移动一帧，a数字参数可以指定任意数字。</p>
<p>x<br>– Read from the memory of the current target process.<br>从当前目标进程的内存中读取。</p>
<p>For more information on any command, type ‘help <command-name>‘.<br>有关任何命令的更多信息，请键入“help <command-name>”。</command-name></command-name></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title>App-Store-审核指南</title>
    <url>/App-Store-%E5%AE%A1%E6%A0%B8%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<p><a href="https://developer.apple.com/cn/app-store/review/guidelines/#spam" target="_blank" rel="noopener">App Store 审核指南</a><br>简介<br>App 正在改变世界，丰富人们的生活，并为像您一样的开发者提供前所未有的创新机会。因此，App Store 已成长为一个激动人心且充满活力的生态系统，正为数百万的开发者和超过十亿的用户提供服务。不管是开发新手，还是由经验丰富的程序员所组成的大型团队，我们都非常欢迎您为 App Store 创建 app，并希望能够帮助您了解我们的准则，以确保您的 app 能够快速通过审核流程。</p>
<p>App Store 的指导原则非常简单：我们希望为用户获取 app 时提供更安全可靠的体验，并为所有开发者提供借助 app 获得成功的契机。在后续页面中，您会发现这些准则已被清晰地划分为五个部分：安全、性能、业务、设计及法律。另外，请将以下几点谨记在心：</p>
<p>很多儿童会从我们这里大量下载各种 app。尽管家长控制功能能为儿童提供有效保护，但您也必须做好自己份内的工作。因此，您要知道，我们时刻都在关注这些儿童。<br>App Store 是向全球数亿人分享 app 的好方法。如果您开发 app 只是为了分发给亲朋好友，那么 App Store 并不是最适合的途径。这时可考虑使用 Xcode 在设备上安装您的 app，或使用 Apple Developer Program 会员资格中的 Ad Hoc 分发。如果您刚开始开发 app，请进一步了解 Apple Developer Program。<br>在 App Store 上发布的所有观点，我们都非常支持 — 只要这些 app 尊重用户的不同意见，并能带来良好的 app 体验。如果我们认为 app 的任何内容或行为超出了可接受的范围，我们将拒绝该 app。您可能会问，这个可接受的范围是什么？套用最高法院大法官的一句话：“当我看到的时候，我就知道了”。而且，我们相信，当您超出这个范围时，您自己也会意识到。<br>如果您试图欺骗系统 (例如，试图在审核流程中弄虚作假，窃取用户数据，抄袭其他开发者的作品，或者操纵评级)，我们会从商店中移除您的 app，并将您从开发者帐户中除名。<br>您要确保 app 中所含内容全部符合这些准则的要求，包括广告网络、分析服务和第三方 SDK 等；因此，在审核和选择这些内容时务必要慎重。<br>我们希望这些准则能帮助您顺利通过 App Review 流程，并使批准和拒绝标准在整体上更加一致。本文是一个动态文稿；如果新的 app 引发了新的问题，我们可能会随时制定新的规则。也许，您的 app 就将促成新的规则。我们同样热爱 app 开发，并且尊重您所做的一切。我们正竭尽全力为您营造世界上最优秀的平台，既能让您展示才华，还能让您获得回报。</p>
<h1 id="1-安全"><a href="#1-安全" class="headerlink" title="1. 安全"></a>1. 安全</h1><p>当用户通过 App Store 安装 app 时，他们希望获得安全的体验：app 不含令人不快或具有攻击性的内容，不会损坏用户的设备，不会在使用中造成人身伤害。我们在下方列出了主要的安全隐患。如果您想恐吓或攻击他人，则您的 app 不适合出现在 App Store 中。</p>
<h2 id="1-1-令人反感的内容"><a href="#1-1-令人反感的内容" class="headerlink" title="1.1 令人反感的内容"></a>1.1 令人反感的内容</h2><p>App 不应包含具有攻击性、不顾及他人感受、令人不安、惹人厌恶或低俗不堪的内容。此类内容的示例有：</p>
<h3 id="1-1-1-诽谤、歧视或恶意的内容，包括有关宗教、种族、性取向、性别、国籍、种族起源或其他目标群体的引用或评论，特别是当-app-很可能对特定的个人或团体进行羞辱、恐吓、或造成伤害时。通常情况下，专业政治讽刺和政治幽默作家不受此要求限制。"><a href="#1-1-1-诽谤、歧视或恶意的内容，包括有关宗教、种族、性取向、性别、国籍、种族起源或其他目标群体的引用或评论，特别是当-app-很可能对特定的个人或团体进行羞辱、恐吓、或造成伤害时。通常情况下，专业政治讽刺和政治幽默作家不受此要求限制。" class="headerlink" title="1.1.1 诽谤、歧视或恶意的内容，包括有关宗教、种族、性取向、性别、国籍、种族起源或其他目标群体的引用或评论，特别是当 app 很可能对特定的个人或团体进行羞辱、恐吓、或造成伤害时。通常情况下，专业政治讽刺和政治幽默作家不受此要求限制。"></a>1.1.1 诽谤、歧视或恶意的内容，包括有关宗教、种族、性取向、性别、国籍、种族起源或其他目标群体的引用或评论，特别是当 app 很可能对特定的个人或团体进行羞辱、恐吓、或造成伤害时。通常情况下，专业政治讽刺和政治幽默作家不受此要求限制。</h3><h3 id="1-1-2-人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。"><a href="#1-1-2-人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。" class="headerlink" title="1.1.2 人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。"></a>1.1.2 人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。</h3><h3 id="1-1-3-鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火购买的描述。"><a href="#1-1-3-鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火购买的描述。" class="headerlink" title="1.1.3 鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火购买的描述。"></a>1.1.3 鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火购买的描述。</h3><h3 id="1-1-4-过于色情的内容-韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感-。"><a href="#1-1-4-过于色情的内容-韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感-。" class="headerlink" title="1.1.4 过于色情的内容 (韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感)。"></a>1.1.4 过于色情的内容 (韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感)。</h3><h3 id="1-1-5-具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。"><a href="#1-1-5-具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。" class="headerlink" title="1.1.5 具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。"></a>1.1.5 具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。</h3><h3 id="1-1-6-虚假信息和功能，其中包括不准确的设备数据或用于恶作剧-开玩笑的功能，如虚假的位置跟踪器。即使指明-app“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信-彩信的-app-会被拒绝。"><a href="#1-1-6-虚假信息和功能，其中包括不准确的设备数据或用于恶作剧-开玩笑的功能，如虚假的位置跟踪器。即使指明-app“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信-彩信的-app-会被拒绝。" class="headerlink" title="1.1.6 虚假信息和功能，其中包括不准确的设备数据或用于恶作剧/开玩笑的功能，如虚假的位置跟踪器。即使指明 app“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信/彩信的 app 会被拒绝。"></a>1.1.6 虚假信息和功能，其中包括不准确的设备数据或用于恶作剧/开玩笑的功能，如虚假的位置跟踪器。即使指明 app“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信/彩信的 app 会被拒绝。</h3><h3 id="1-1-7-App-Store-评论："><a href="#1-1-7-App-Store-评论：" class="headerlink" title="1.1.7 App Store 评论："></a>1.1.7 App Store 评论：</h3><p>App Store 客户评论是 app 体验中不可或缺的一部分；因此，在回复客户的评论时，您应当对他们保持尊重。另外，您的回复应直接回应客户评论的主题，请勿在回复中包含个人信息、垃圾信息或营销广告。<br>利用我们提供的 API 提示用户评价您的 app：通过这项便利功能，客户无需离开 app，就可直接在 App Store 中留下评分和评论；不允许使用预定的评论提示。</p>
<h2 id="1-2-用户生成的内容"><a href="#1-2-用户生成的内容" class="headerlink" title="1.2 用户生成的内容"></a>1.2 用户生成的内容</h2><p>对于包含用户生成内容的 App，有特定的难题需要解决，比如知识产权侵权、匿名欺凌等。为了避免滥用，包含用户生成内容或社交网络服务的 app 必须满足以下条件：</p>
<p>采用相应的方法来过滤令人反感的内容，以免这些内容在 app 中发布<br>制定一个机制，以举报攻击性内容并在出现问题时及时作出回应<br>若用户发布攻击性内容，可以取消其使用服务的资格<br>公布联系信息，以便用户与您联系<br>如果 app 中所含的用户生成内容或服务最终主要用于色情内容、客观化现实生活中的某人 (如“性感与否”投票)、进行人身威胁或欺凌，则这些 app 不适合出现在 App Store 中，它们可能会在未经通知的情况下被移除。如果 app 中所含的用户生成内容来自于基于 web 的服务，则可显示意外产生的“NSFW (公众场所不宜)”内容，前提是这些内容是默认隐藏的，只有当用户通过您的网站将其打开时才会显示。</p>
<h2 id="1-3-儿童类别"><a href="#1-3-儿童类别" class="headerlink" title="1.3 儿童类别"></a>1.3 儿童类别</h2><p>“儿童类别”可帮助用户轻松找到专为儿童设计的 app。如果您希望参与“儿童类别”，则应该致力于为年纪较小的用户量身打造卓越的使用体验。这些 app 不得提供 app 外链接、购买机会或其他会对儿童造成干扰的内容，除非其保留在受家长监控的指定区域中。请谨记，一旦客户认为您的 app 能够满足“儿童类别”要求，您的 app 就需要一直满足后续更新中的相应准则；即使您决定取消选择此类别，也是如此。进一步了解家长监控。</p>
<p>“儿童类别”中的 app 不得展示行为广告 (例如，广告商不得根据用户在 app 中的活动投放广告)，而且所有内容相关广告都必须适合儿童观看。您还应特别留意世界各地与在线收集儿童数据相关的隐私法。请务必查阅这些准则的“隐私”部分，以了解更多信息。</p>
<h2 id="1-4-人身伤害"><a href="#1-4-人身伤害" class="headerlink" title="1.4 人身伤害"></a>1.4 人身伤害</h2><p>如果 app 的行为方式可能会造成人身伤害，我们可能会拒绝该 app。例如：</p>
<h3 id="1-4-1-如果医疗-app-可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些-app-可能会面临更加严格的审核。"><a href="#1-4-1-如果医疗-app-可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些-app-可能会面临更加严格的审核。" class="headerlink" title="1.4.1 如果医疗 app 可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些 app 可能会面临更加严格的审核。"></a>1.4.1 如果医疗 app 可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些 app 可能会面临更加严格的审核。</h3><p>App 必须清楚地披露相关数据和方法，用于佐证声明的健康测量准确度，如果准确度或方法得不到验证，我们会拒绝该 app。例如，如果 app 声称仅通过设备上的传感器就能照 X 光、测血压、测体温、测血糖浓度或测血氧含量，则这个 app 会被拒绝。<br>App 应当提醒用户，除了使用该 app，还应咨询医生的意见，然后才能做出医疗决定。<br>如果您的医疗 app 已经获得监管部门的批准，请随 app 提交相关文稿的链接。</p>
<h3 id="1-4-2-药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司、药店或经过-FDA-或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保-app-将在长时间内获得支持，并保持更新。"><a href="#1-4-2-药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司、药店或经过-FDA-或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保-app-将在长时间内获得支持，并保持更新。" class="headerlink" title="1.4.2 药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司、药店或经过 FDA 或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保 app 将在长时间内获得支持，并保持更新。"></a>1.4.2 药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司、药店或经过 FDA 或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保 app 将在长时间内获得支持，并保持更新。</h3><h3 id="1-4-3-App-Store-中不允许分发任何鼓励食用烟草产品、使用违禁药物或摄入过量酒精的-app。鼓励未成年人摄入任何上述物品的-app-都会被拒绝。为大麻、烟草或管制物品的销售提供便利-经授权的药店除外-同样不被允许。"><a href="#1-4-3-App-Store-中不允许分发任何鼓励食用烟草产品、使用违禁药物或摄入过量酒精的-app。鼓励未成年人摄入任何上述物品的-app-都会被拒绝。为大麻、烟草或管制物品的销售提供便利-经授权的药店除外-同样不被允许。" class="headerlink" title="1.4.3 App Store 中不允许分发任何鼓励食用烟草产品、使用违禁药物或摄入过量酒精的 app。鼓励未成年人摄入任何上述物品的 app 都会被拒绝。为大麻、烟草或管制物品的销售提供便利 (经授权的药店除外) 同样不被允许。"></a>1.4.3 App Store 中不允许分发任何鼓励食用烟草产品、使用违禁药物或摄入过量酒精的 app。鼓励未成年人摄入任何上述物品的 app 都会被拒绝。为大麻、烟草或管制物品的销售提供便利 (经授权的药店除外) 同样不被允许。</h3><h3 id="1-4-4-App-只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。"><a href="#1-4-4-App-只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。" class="headerlink" title="1.4.4 App 只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。"></a>1.4.4 App 只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。</h3><h3 id="1-4-5-App-不得促使客户以违背-Apple-硬件安全文稿的方式，或以可能会造成设备或人身伤害的方式来使用他们的设备。例如，app-不得鼓励在充电期间将设备置于床垫或枕头下，或对固态硬盘进行过多的写入循环操作。请查阅设备文稿。"><a href="#1-4-5-App-不得促使客户以违背-Apple-硬件安全文稿的方式，或以可能会造成设备或人身伤害的方式来使用他们的设备。例如，app-不得鼓励在充电期间将设备置于床垫或枕头下，或对固态硬盘进行过多的写入循环操作。请查阅设备文稿。" class="headerlink" title="1.4.5 App 不得促使客户以违背 Apple 硬件安全文稿的方式，或以可能会造成设备或人身伤害的方式来使用他们的设备。例如，app 不得鼓励在充电期间将设备置于床垫或枕头下，或对固态硬盘进行过多的写入循环操作。请查阅设备文稿。"></a>1.4.5 App 不得促使客户以违背 Apple 硬件安全文稿的方式，或以可能会造成设备或人身伤害的方式来使用他们的设备。例如，app 不得鼓励在充电期间将设备置于床垫或枕头下，或对固态硬盘进行过多的写入循环操作。请查阅设备文稿。</h3><h2 id="1-5-开发者信息"><a href="#1-5-开发者信息" class="headerlink" title="1.5 开发者信息"></a>1.5 开发者信息</h2><p>用户需要知道如何就疑问和支持问题与您取得联系。确保您的 app 及其支持 URL 中包含能轻松联系到您的联系信息；对于可能会在课堂中使用的 app 而言，这一点尤为重要。如果未能提供准确的最新联系信息，不但会让客户有不好的感受，可能还会违反某些国家/地区的法律。另外，请确保在钱包凭证中包含发卡机构的有效联系方式，以及分配给凭证的品牌或商标所有者的专用证书。</p>
<h2 id="1-6-数据安全"><a href="#1-6-数据安全" class="headerlink" title="1.6 数据安全"></a>1.6 数据安全</h2><p>App 应实施适当的安全举措，确保按照“Apple Developer Program 许可协议”和这些准则 (更多信息见“准则 5.1”) 妥善处理收集到的用户信息，防止对这些信息进行未经授权使用、披露或者被第三方访问。</p>
<h1 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h1><h2 id="2-1-App-完成度"><a href="#2-1-App-完成度" class="headerlink" title="2.1 App 完成度"></a>2.1 App 完成度</h2><p>提交至 App Review 的申请 (包括可供预订的 app) 应为该 app 的最终版本，并应包含所有必要的元数据和有效网址。所有占位符文本、空白网站和其他临时内容应在提交前移除。在提交 app 之前，请务必在设备上对 app 的错误和稳定性进行测试；如果您的 app 需要登录，请提供演示帐户信息 (并打开您的后台服务！)。如果您在 app 中提供了 App 内购买项目，请确保审核人员能够看到这些内容，并确保这些内容处于完整且最新的状态，否则请在审核备注中说明相关原因。请不要将 App Review 视作软件测试服务。我们将拒绝不完整的 app 套装以及会出现崩溃或存在明显技术问题的二进制文件。</p>
<h2 id="2-2-Beta-版测试"><a href="#2-2-Beta-版测试" class="headerlink" title="2.2 Beta 版测试"></a>2.2 Beta 版测试</h2><p>App 的演示版、beta 版和试用版不适合出现在 App Store 中，请改用 TestFlight。所有通过 TestFlight 提交以进行测试发布的 app 都应旨在公开发布，并应遵循“App Review 准则”。请注意，使用 TestFlight 的 app 不得分发给测试者用以换取任何类型的报酬，包括作为众筹资金的奖励。对于 beta 版 app 的大幅更新应先提交至 TestFlight App Review 团队，然后再分发给您的测试者。欲了解更多信息，请访问“TestFlight Beta 测试”。</p>
<h2 id="2-3-准确的元数据"><a href="#2-3-准确的元数据" class="headerlink" title="2.3 准确的元数据"></a>2.3 准确的元数据</h2><p>客户应该知道他们在下载或购买您的 app 时会得到什么，所以请确保 app 的描述、屏幕快照和预览能够准确反映 app 的核心体验，并记得不断更新，以便保持与新版本相应的最新状态。</p>
<h3 id="2-3-1-请勿在-app-中包含未记录的功能或隐藏功能；不管是对于最终用户还是-App-Review-团队，app-功能都应清晰可见。同样，您不应该在-App-Store-或离线情况下，营销您的-app-中实际并不提供的内容或服务-例如基于-iOS-的病毒和恶意软件扫描工具-。如果出现恶劣或屡教不改的行为，则可能会从-Apple-Developer-Program-中除名。我们正努力将-App-Store-打造成值得信赖的生态系统，并希望我们的-app-开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。"><a href="#2-3-1-请勿在-app-中包含未记录的功能或隐藏功能；不管是对于最终用户还是-App-Review-团队，app-功能都应清晰可见。同样，您不应该在-App-Store-或离线情况下，营销您的-app-中实际并不提供的内容或服务-例如基于-iOS-的病毒和恶意软件扫描工具-。如果出现恶劣或屡教不改的行为，则可能会从-Apple-Developer-Program-中除名。我们正努力将-App-Store-打造成值得信赖的生态系统，并希望我们的-app-开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。" class="headerlink" title="2.3.1 请勿在 app 中包含未记录的功能或隐藏功能；不管是对于最终用户还是 App Review 团队，app 功能都应清晰可见。同样，您不应该在 App Store 或离线情况下，营销您的 app 中实际并不提供的内容或服务 (例如基于 iOS 的病毒和恶意软件扫描工具)。如果出现恶劣或屡教不改的行为，则可能会从 Apple Developer Program 中除名。我们正努力将 App Store 打造成值得信赖的生态系统，并希望我们的 app 开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。"></a>2.3.1 请勿在 app 中包含未记录的功能或隐藏功能；不管是对于最终用户还是 App Review 团队，app 功能都应清晰可见。同样，您不应该在 App Store 或离线情况下，营销您的 app 中实际并不提供的内容或服务 (例如基于 iOS 的病毒和恶意软件扫描工具)。如果出现恶劣或屡教不改的行为，则可能会从 Apple Developer Program 中除名。我们正努力将 App Store 打造成值得信赖的生态系统，并希望我们的 app 开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。</h3><h3 id="2-3-2-如果您的-app-包含-App-内购买项目，请确保-app-的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡和订阅等。如果您决定在-App-Store-中推广-App-内购买项目，请确保-App-内购买项目的显示名称、屏幕快照和描述适合所有公众，并遵循“推广您的-App-内购买项目”中的准则；此外，您的-app-也应正确使用-SKPaymentTransactionObserver-方法-英文-，以便客户可以在-app-内无缝完成购买。"><a href="#2-3-2-如果您的-app-包含-App-内购买项目，请确保-app-的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡和订阅等。如果您决定在-App-Store-中推广-App-内购买项目，请确保-App-内购买项目的显示名称、屏幕快照和描述适合所有公众，并遵循“推广您的-App-内购买项目”中的准则；此外，您的-app-也应正确使用-SKPaymentTransactionObserver-方法-英文-，以便客户可以在-app-内无缝完成购买。" class="headerlink" title="2.3.2 如果您的 app 包含 App 内购买项目，请确保 app 的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡和订阅等。如果您决定在 App Store 中推广 App 内购买项目，请确保 App 内购买项目的显示名称、屏幕快照和描述适合所有公众，并遵循“推广您的 App 内购买项目”中的准则；此外，您的 app 也应正确使用 SKPaymentTransactionObserver 方法 (英文)，以便客户可以在 app 内无缝完成购买。"></a>2.3.2 如果您的 app 包含 App 内购买项目，请确保 app 的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡和订阅等。如果您决定在 App Store 中推广 App 内购买项目，请确保 App 内购买项目的显示名称、屏幕快照和描述适合所有公众，并遵循“推广您的 App 内购买项目”中的准则；此外，您的 app 也应正确使用 SKPaymentTransactionObserver 方法 (英文)，以便客户可以在 app 内无缝完成购买。</h3><h3 id="2-3-3-屏幕快照应展示-app-的使用情况，而非仅显示标题封面、登录页面或初始屏幕。屏幕快照还可以包括文本及图像说明-例如：演示输入机制，如触控点或-Apple-Pencil-的动画-，并展示设备上的扩展功能，如触控栏。"><a href="#2-3-3-屏幕快照应展示-app-的使用情况，而非仅显示标题封面、登录页面或初始屏幕。屏幕快照还可以包括文本及图像说明-例如：演示输入机制，如触控点或-Apple-Pencil-的动画-，并展示设备上的扩展功能，如触控栏。" class="headerlink" title="2.3.3 屏幕快照应展示 app 的使用情况，而非仅显示标题封面、登录页面或初始屏幕。屏幕快照还可以包括文本及图像说明 (例如：演示输入机制，如触控点或 Apple Pencil 的动画)，并展示设备上的扩展功能，如触控栏。"></a>2.3.3 屏幕快照应展示 app 的使用情况，而非仅显示标题封面、登录页面或初始屏幕。屏幕快照还可以包括文本及图像说明 (例如：演示输入机制，如触控点或 Apple Pencil 的动画)，并展示设备上的扩展功能，如触控栏。</h3><h3 id="2-3-4-预览是让客户了解-app-外观和功能的好方法。为了确保客户理解他们将在-app-中获得的体验，预览只可使用从-app-中采集的视频屏幕。Stickers-和-iMessage-信息扩展可以将用户体验展示在“信息”app-中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。"><a href="#2-3-4-预览是让客户了解-app-外观和功能的好方法。为了确保客户理解他们将在-app-中获得的体验，预览只可使用从-app-中采集的视频屏幕。Stickers-和-iMessage-信息扩展可以将用户体验展示在“信息”app-中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。" class="headerlink" title="2.3.4 预览是让客户了解 app 外观和功能的好方法。为了确保客户理解他们将在 app 中获得的体验，预览只可使用从 app 中采集的视频屏幕。Stickers 和 iMessage 信息扩展可以将用户体验展示在“信息”app 中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。"></a>2.3.4 预览是让客户了解 app 外观和功能的好方法。为了确保客户理解他们将在 app 中获得的体验，预览只可使用从 app 中采集的视频屏幕。Stickers 和 iMessage 信息扩展可以将用户体验展示在“信息”app 中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。</h3><h3 id="2-3-5-请为-app-选择最适合的类别，并在需要帮助时参考“App-Store-类别定义”。如果选择的类别与实际情况相差较远，我们可能会更改-app-的类别。"><a href="#2-3-5-请为-app-选择最适合的类别，并在需要帮助时参考“App-Store-类别定义”。如果选择的类别与实际情况相差较远，我们可能会更改-app-的类别。" class="headerlink" title="2.3.5 请为 app 选择最适合的类别，并在需要帮助时参考“App Store 类别定义”。如果选择的类别与实际情况相差较远，我们可能会更改 app 的类别。"></a>2.3.5 请为 app 选择最适合的类别，并在需要帮助时参考“App Store 类别定义”。如果选择的类别与实际情况相差较远，我们可能会更改 app 的类别。</h3><h3 id="2-3-6-请在-App-Store-Connect-中诚实地回答年龄分级问题，以使-app-与家长控制功能的分级保持一致。如果-app-分级有误，客户在获得-app-时可能会感到诧异，或促使政府监管部门展开相应调查。如果-app-所含的媒体内容要求显示内容分级或警告-如电影、音乐和游戏等-，则需在销售-app-的每个地区内遵循当地要求。"><a href="#2-3-6-请在-App-Store-Connect-中诚实地回答年龄分级问题，以使-app-与家长控制功能的分级保持一致。如果-app-分级有误，客户在获得-app-时可能会感到诧异，或促使政府监管部门展开相应调查。如果-app-所含的媒体内容要求显示内容分级或警告-如电影、音乐和游戏等-，则需在销售-app-的每个地区内遵循当地要求。" class="headerlink" title="2.3.6 请在 App Store Connect 中诚实地回答年龄分级问题，以使 app 与家长控制功能的分级保持一致。如果 app 分级有误，客户在获得 app 时可能会感到诧异，或促使政府监管部门展开相应调查。如果 app 所含的媒体内容要求显示内容分级或警告 (如电影、音乐和游戏等)，则需在销售 app 的每个地区内遵循当地要求。"></a>2.3.6 请在 App Store Connect 中诚实地回答年龄分级问题，以使 app 与家长控制功能的分级保持一致。如果 app 分级有误，客户在获得 app 时可能会感到诧异，或促使政府监管部门展开相应调查。如果 app 所含的媒体内容要求显示内容分级或警告 (如电影、音乐和游戏等)，则需在销售 app 的每个地区内遵循当地要求。</h3><h3 id="2-3-7-请选择一个独一无二的-app-名称，指定能够准确描述-app-的关键词，不要试图用商标术语、流行-app-的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App-名称必须限制在-30-个字符以内，且不得包含不属于-app-名称的价格、词语或描述。App-副标题是详细介绍-app-背景信息的绝佳之处。副标题必须遵循我们的标准元数据规则，且不得包含不当内容、提及其他-app-或做出无法证实的产品声明。Apple-可以随时修改不合适的关键字或采取其他相应步骤，以防止不当使用。"><a href="#2-3-7-请选择一个独一无二的-app-名称，指定能够准确描述-app-的关键词，不要试图用商标术语、流行-app-的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App-名称必须限制在-30-个字符以内，且不得包含不属于-app-名称的价格、词语或描述。App-副标题是详细介绍-app-背景信息的绝佳之处。副标题必须遵循我们的标准元数据规则，且不得包含不当内容、提及其他-app-或做出无法证实的产品声明。Apple-可以随时修改不合适的关键字或采取其他相应步骤，以防止不当使用。" class="headerlink" title="2.3.7 请选择一个独一无二的 app 名称，指定能够准确描述 app 的关键词，不要试图用商标术语、流行 app 的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App 名称必须限制在 30 个字符以内，且不得包含不属于 app 名称的价格、词语或描述。App 副标题是详细介绍 app 背景信息的绝佳之处。副标题必须遵循我们的标准元数据规则，且不得包含不当内容、提及其他 app 或做出无法证实的产品声明。Apple 可以随时修改不合适的关键字或采取其他相应步骤，以防止不当使用。"></a>2.3.7 请选择一个独一无二的 app 名称，指定能够准确描述 app 的关键词，不要试图用商标术语、流行 app 的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App 名称必须限制在 30 个字符以内，且不得包含不属于 app 名称的价格、词语或描述。App 副标题是详细介绍 app 背景信息的绝佳之处。副标题必须遵循我们的标准元数据规则，且不得包含不当内容、提及其他 app 或做出无法证实的产品声明。Apple 可以随时修改不合适的关键字或采取其他相应步骤，以防止不当使用。</h3><h3 id="2-3-8-元数据应适合所有受众，所以请确保您的-app-和-App-内购买项目的相关图标、屏幕快照和预览保持在-4-年龄分级；即使您的-app-分级更高，也应如此。例如，如果您的-app-是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。只有“儿童类别”的-app-才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。请务必确保包括-app-名称和图标-小图标、大图标、Apple-Watch-app-和备用图标等-在内的元数据彼此相似，以免引起困惑。"><a href="#2-3-8-元数据应适合所有受众，所以请确保您的-app-和-App-内购买项目的相关图标、屏幕快照和预览保持在-4-年龄分级；即使您的-app-分级更高，也应如此。例如，如果您的-app-是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。只有“儿童类别”的-app-才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。请务必确保包括-app-名称和图标-小图标、大图标、Apple-Watch-app-和备用图标等-在内的元数据彼此相似，以免引起困惑。" class="headerlink" title="2.3.8 元数据应适合所有受众，所以请确保您的 app 和 App 内购买项目的相关图标、屏幕快照和预览保持在 4+ 年龄分级；即使您的 app 分级更高，也应如此。例如，如果您的 app 是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。只有“儿童类别”的 app 才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。请务必确保包括 app 名称和图标 (小图标、大图标、Apple Watch app 和备用图标等) 在内的元数据彼此相似，以免引起困惑。"></a>2.3.8 元数据应适合所有受众，所以请确保您的 app 和 App 内购买项目的相关图标、屏幕快照和预览保持在 4+ 年龄分级；即使您的 app 分级更高，也应如此。例如，如果您的 app 是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。只有“儿童类别”的 app 才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。请务必确保包括 app 名称和图标 (小图标、大图标、Apple Watch app 和备用图标等) 在内的元数据彼此相似，以免引起困惑。</h3><h3 id="2-3-9-您应负责确保有权使用-app-图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。"><a href="#2-3-9-您应负责确保有权使用-app-图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。" class="headerlink" title="2.3.9 您应负责确保有权使用 app 图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。"></a>2.3.9 您应负责确保有权使用 app 图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。</h3><h3 id="2-3-10-请确保您的-app-注重-iOS、Mac、Apple-TV-或-Apple-Watch-体验，并且不在-app-或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。"><a href="#2-3-10-请确保您的-app-注重-iOS、Mac、Apple-TV-或-Apple-Watch-体验，并且不在-app-或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。" class="headerlink" title="2.3.10 请确保您的 app 注重 iOS、Mac、Apple TV 或 Apple Watch 体验，并且不在 app 或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。"></a>2.3.10 请确保您的 app 注重 iOS、Mac、Apple TV 或 Apple Watch 体验，并且不在 app 或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。</h3><h3 id="2-3-11-您提交至-App-Store-可供预订的-app-必须为完整且可发布的状态。请确保您最终发布的-app-与其可供预订状态时所宣传的内容没有实质性差异。如果您对该-app-进行了重大更改-例如更改其商业模式-，则应重新开始其预订销售。"><a href="#2-3-11-您提交至-App-Store-可供预订的-app-必须为完整且可发布的状态。请确保您最终发布的-app-与其可供预订状态时所宣传的内容没有实质性差异。如果您对该-app-进行了重大更改-例如更改其商业模式-，则应重新开始其预订销售。" class="headerlink" title="2.3.11 您提交至 App Store 可供预订的 app 必须为完整且可发布的状态。请确保您最终发布的 app 与其可供预订状态时所宣传的内容没有实质性差异。如果您对该 app 进行了重大更改 (例如更改其商业模式)，则应重新开始其预订销售。"></a>2.3.11 您提交至 App Store 可供预订的 app 必须为完整且可发布的状态。请确保您最终发布的 app 与其可供预订状态时所宣传的内容没有实质性差异。如果您对该 app 进行了重大更改 (例如更改其商业模式)，则应重新开始其预订销售。</h3><h3 id="2-3-12-App-必须在其“新功能”文本中清楚地描述新功能和产品更改情况。一些简单的错误修复、安全更新和性能改进可以通过一般描述来说明，但较为重大的更改必须列明在备注中。"><a href="#2-3-12-App-必须在其“新功能”文本中清楚地描述新功能和产品更改情况。一些简单的错误修复、安全更新和性能改进可以通过一般描述来说明，但较为重大的更改必须列明在备注中。" class="headerlink" title="2.3.12 App 必须在其“新功能”文本中清楚地描述新功能和产品更改情况。一些简单的错误修复、安全更新和性能改进可以通过一般描述来说明，但较为重大的更改必须列明在备注中。"></a>2.3.12 App 必须在其“新功能”文本中清楚地描述新功能和产品更改情况。一些简单的错误修复、安全更新和性能改进可以通过一般描述来说明，但较为重大的更改必须列明在备注中。</h3><h2 id="2-4-硬件兼容性"><a href="#2-4-硬件兼容性" class="headerlink" title="2.4 硬件兼容性"></a>2.4 硬件兼容性</h2><h3 id="2-4-1-为了确保用户能够充分利用您的-app，iPhone-app-应尽量能在-iPad-上运行。我们鼓励您考虑开发通用-app，这样客户就可以在所有设备上加以使用。进一步了解通用-app。"><a href="#2-4-1-为了确保用户能够充分利用您的-app，iPhone-app-应尽量能在-iPad-上运行。我们鼓励您考虑开发通用-app，这样客户就可以在所有设备上加以使用。进一步了解通用-app。" class="headerlink" title="2.4.1 为了确保用户能够充分利用您的 app，iPhone app 应尽量能在 iPad 上运行。我们鼓励您考虑开发通用 app，这样客户就可以在所有设备上加以使用。进一步了解通用 app。"></a>2.4.1 为了确保用户能够充分利用您的 app，iPhone app 应尽量能在 iPad 上运行。我们鼓励您考虑开发通用 app，这样客户就可以在所有设备上加以使用。进一步了解通用 app。</h3><h3 id="2-4-2-通过设计，使-app-节省能耗。App-不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。App-及其中显示的任何第三方广告均不可运行无关的后台进程，如加密货币挖矿。"><a href="#2-4-2-通过设计，使-app-节省能耗。App-不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。App-及其中显示的任何第三方广告均不可运行无关的后台进程，如加密货币挖矿。" class="headerlink" title="2.4.2 通过设计，使 app 节省能耗。App 不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。App 及其中显示的任何第三方广告均不可运行无关的后台进程，如加密货币挖矿。"></a>2.4.2 通过设计，使 app 节省能耗。App 不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。App 及其中显示的任何第三方广告均不可运行无关的后台进程，如加密货币挖矿。</h3><h3 id="2-4-3-对于-Apple-TV-app，应确保用户无需使用除-Siri-Remote-或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中清晰说明，以便用户知晓他们需要额外的设备才能玩游戏。"><a href="#2-4-3-对于-Apple-TV-app，应确保用户无需使用除-Siri-Remote-或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中清晰说明，以便用户知晓他们需要额外的设备才能玩游戏。" class="headerlink" title="2.4.3 对于 Apple TV app，应确保用户无需使用除 Siri Remote 或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中清晰说明，以便用户知晓他们需要额外的设备才能玩游戏。"></a>2.4.3 对于 Apple TV app，应确保用户无需使用除 Siri Remote 或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中清晰说明，以便用户知晓他们需要额外的设备才能玩游戏。</h3><h3 id="2-4-4-App-不得建议或要求重新启动设备，或者修改与-app-核心功能无关的系统设置。例如，请勿鼓励用户关闭-Wi-Fi-或停用安全功能等。"><a href="#2-4-4-App-不得建议或要求重新启动设备，或者修改与-app-核心功能无关的系统设置。例如，请勿鼓励用户关闭-Wi-Fi-或停用安全功能等。" class="headerlink" title="2.4.4 App 不得建议或要求重新启动设备，或者修改与 app 核心功能无关的系统设置。例如，请勿鼓励用户关闭 Wi-Fi 或停用安全功能等。"></a>2.4.4 App 不得建议或要求重新启动设备，或者修改与 app 核心功能无关的系统设置。例如，请勿鼓励用户关闭 Wi-Fi 或停用安全功能等。</h3><h3 id="2-4-5-对于通过-Mac-App-Store-分发的-app，还有几个额外要求需要您留意："><a href="#2-4-5-对于通过-Mac-App-Store-分发的-app，还有几个额外要求需要您留意：" class="headerlink" title="2.4.5 对于通过 Mac App Store 分发的 app，还有几个额外要求需要您留意："></a>2.4.5 对于通过 Mac App Store 分发的 app，还有几个额外要求需要您留意：</h3><p>(i) 这些 app 必须妥当地沙箱化，并遵循“macOS 文件系统文档 (英文)”。另外，这些 app 只应使用相应的 macOS API 来修改其他 app 存储的用户数据 (如书签、“地址簿”或“日历”条目)。<br>(ii) 这些 app 必须使用 Xcode 中提供的技术来进行打包和提交；不允许使用第三方安装器。另外，这些 app 必须是单个的自包含 app 安装包，不能将代码或资源安装在共享位置。<br>(iii) 这些 app 不得自动启动或者在启动时包含其他自动运行的代码，不得在未经同意的情况下登录，也不得大量生成在用户退出 app 后仍在未经同意的情况下继续运行的进程。这些 app 不得将图标自动添加到程序坞中，或在用户桌面上留下快捷方式。<br>(iv) 这些 app 不得下载或安装独立的 app、kext、额外代码或资源，以向我们在审核过程中看到的 app 添加功能，或进行大幅更改。<br>(v) 这些 app 不得申请升级至 root 特权或使用 setuid 属性。<br>(vi) 这些 app 不得在启动时显示许可证屏幕、需要使用许可证密匙或实施自己的拷贝保护措施。<br>(vii) 这些 app 必须使用 Mac App Store 分发更新；不允许使用其他更新机制。<br>(viii) 这些 app 应在当前发布的 OS 上运行，不得使用已停用或选装的技术 (如 Java、Rosetta)。<br>(ix) 这些 app 必须在单个 app 套装内包含所有的语言和本地化支持。</p>
<h2 id="2-5-软件要求"><a href="#2-5-软件要求" class="headerlink" title="2.5 软件要求"></a>2.5 软件要求</h2><h3 id="2-5-1-App-仅可使用公共-API，并且必须在当前发布的-OS-上运行。进一步了解公共-APIs-英文-。及时更新您的-app，在未来的操作系统版本中不再支持的任何过时功能、框架或技术皆应被淘汰。App-使用的-API-和框架应该是为了实现预期用途，并在-app-描述中说明集成详情。例如，HomeKit-框架应提供家居自动化服务，HealthKit-则应该用于保持健康和健身目的，并集成在“健康”app-中。"><a href="#2-5-1-App-仅可使用公共-API，并且必须在当前发布的-OS-上运行。进一步了解公共-APIs-英文-。及时更新您的-app，在未来的操作系统版本中不再支持的任何过时功能、框架或技术皆应被淘汰。App-使用的-API-和框架应该是为了实现预期用途，并在-app-描述中说明集成详情。例如，HomeKit-框架应提供家居自动化服务，HealthKit-则应该用于保持健康和健身目的，并集成在“健康”app-中。" class="headerlink" title="2.5.1 App 仅可使用公共 API，并且必须在当前发布的 OS 上运行。进一步了解公共 APIs (英文)。及时更新您的 app，在未来的操作系统版本中不再支持的任何过时功能、框架或技术皆应被淘汰。App 使用的 API 和框架应该是为了实现预期用途，并在 app 描述中说明集成详情。例如，HomeKit 框架应提供家居自动化服务，HealthKit 则应该用于保持健康和健身目的，并集成在“健康”app 中。"></a>2.5.1 App 仅可使用公共 API，并且必须在当前发布的 OS 上运行。进一步了解公共 APIs (英文)。及时更新您的 app，在未来的操作系统版本中不再支持的任何过时功能、框架或技术皆应被淘汰。App 使用的 API 和框架应该是为了实现预期用途，并在 app 描述中说明集成详情。例如，HomeKit 框架应提供家居自动化服务，HealthKit 则应该用于保持健康和健身目的，并集成在“健康”app 中。</h3><h3 id="2-5-2-App-应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改-app-特性或功能的代码，包括其他-app。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类-app-可以下载所提供的代码，但这类代码不得用于其他用途。这类-app-必须开放-app-提供的源代码，让客户可以完全查看和编辑这些源代码。"><a href="#2-5-2-App-应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改-app-特性或功能的代码，包括其他-app。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类-app-可以下载所提供的代码，但这类代码不得用于其他用途。这类-app-必须开放-app-提供的源代码，让客户可以完全查看和编辑这些源代码。" class="headerlink" title="2.5.2 App 应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改 app 特性或功能的代码，包括其他 app。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类 app 可以下载所提供的代码，但这类代码不得用于其他用途。这类 app 必须开放 app 提供的源代码，让客户可以完全查看和编辑这些源代码。"></a>2.5.2 App 应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改 app 特性或功能的代码，包括其他 app。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类 app 可以下载所提供的代码，但这类代码不得用于其他用途。这类 app 必须开放 app 提供的源代码，让客户可以完全查看和编辑这些源代码。</h3><h3 id="2-5-3-如果-app-传输的病毒、文件、计算机代码或程序会对操作系统和-或硬件功能-包括推送通知和-Game-Center-的正常运行造成负面影响或导致其中断，则该-app-会被拒绝。屡教不改或恶劣的违规行为会导致开发者从-Apple-Developer-Program-中被除名。"><a href="#2-5-3-如果-app-传输的病毒、文件、计算机代码或程序会对操作系统和-或硬件功能-包括推送通知和-Game-Center-的正常运行造成负面影响或导致其中断，则该-app-会被拒绝。屡教不改或恶劣的违规行为会导致开发者从-Apple-Developer-Program-中被除名。" class="headerlink" title="2.5.3 如果 app 传输的病毒、文件、计算机代码或程序会对操作系统和/或硬件功能 (包括推送通知和 Game Center) 的正常运行造成负面影响或导致其中断，则该 app 会被拒绝。屡教不改或恶劣的违规行为会导致开发者从 Apple Developer Program 中被除名。"></a>2.5.3 如果 app 传输的病毒、文件、计算机代码或程序会对操作系统和/或硬件功能 (包括推送通知和 Game Center) 的正常运行造成负面影响或导致其中断，则该 app 会被拒绝。屡教不改或恶劣的违规行为会导致开发者从 Apple Developer Program 中被除名。</h3><h3 id="2-5-4-多任务处理-app-只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果-app-使用定位后台模式，请提醒用户，这么做会大幅缩短电池使用时间。"><a href="#2-5-4-多任务处理-app-只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果-app-使用定位后台模式，请提醒用户，这么做会大幅缩短电池使用时间。" class="headerlink" title="2.5.4 多任务处理 app 只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果 app 使用定位后台模式，请提醒用户，这么做会大幅缩短电池使用时间。"></a>2.5.4 多任务处理 app 只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果 app 使用定位后台模式，请提醒用户，这么做会大幅缩短电池使用时间。</h3><h3 id="2-5-5-我们将在-IPv6-网络上进行审核。如果您的-app-无法与-IPv6-寻址功能兼容，则可能无法通过审核。"><a href="#2-5-5-我们将在-IPv6-网络上进行审核。如果您的-app-无法与-IPv6-寻址功能兼容，则可能无法通过审核。" class="headerlink" title="2.5.5 我们将在 IPv6 网络上进行审核。如果您的 app 无法与 IPv6 寻址功能兼容，则可能无法通过审核。"></a>2.5.5 我们将在 IPv6 网络上进行审核。如果您的 app 无法与 IPv6 寻址功能兼容，则可能无法通过审核。</h3><h3 id="2-5-6-如果-app-会浏览网页，则必须使用相应的-WebKit-框架和-WebKit-Javascript。"><a href="#2-5-6-如果-app-会浏览网页，则必须使用相应的-WebKit-框架和-WebKit-Javascript。" class="headerlink" title="2.5.6 如果 app 会浏览网页，则必须使用相应的 WebKit 框架和 WebKit Javascript。"></a>2.5.6 如果 app 会浏览网页，则必须使用相应的 WebKit 框架和 WebKit Javascript。</h3><h3 id="2-5-7-基于蜂窝移动网络且超过-10-分钟的视频流内容必须使用-HTTP-实时流化，并包含一个-192-kbps-为底线的-HTTP-实时流化。"><a href="#2-5-7-基于蜂窝移动网络且超过-10-分钟的视频流内容必须使用-HTTP-实时流化，并包含一个-192-kbps-为底线的-HTTP-实时流化。" class="headerlink" title="2.5.7 基于蜂窝移动网络且超过 10 分钟的视频流内容必须使用 HTTP 实时流化，并包含一个 192 kbps 为底线的 HTTP 实时流化。"></a>2.5.7 基于蜂窝移动网络且超过 10 分钟的视频流内容必须使用 HTTP 实时流化，并包含一个 192 kbps 为底线的 HTTP 实时流化。</h3><h3 id="2-5-8-如果-app-会创建替代的桌面-主屏幕环境，或者模拟多-app-插件体验，则该-app-会遭到拒绝。"><a href="#2-5-8-如果-app-会创建替代的桌面-主屏幕环境，或者模拟多-app-插件体验，则该-app-会遭到拒绝。" class="headerlink" title="2.5.8 如果 app 会创建替代的桌面/主屏幕环境，或者模拟多 app 插件体验，则该 app 会遭到拒绝。"></a>2.5.8 如果 app 会创建替代的桌面/主屏幕环境，或者模拟多 app 插件体验，则该 app 会遭到拒绝。</h3><h3 id="2-5-9-如果-app-会改变或停用标准开关-如调高-调低音量和铃声-静音开关-的功能，或者改变或停用其他的原生用户界面元素或行为，则该-app-会遭到拒绝。例如，app-不应屏蔽转向其他-app-的链接，或用户希望以某种特定方式运行的功能。进一步了解如何正确处理链接。"><a href="#2-5-9-如果-app-会改变或停用标准开关-如调高-调低音量和铃声-静音开关-的功能，或者改变或停用其他的原生用户界面元素或行为，则该-app-会遭到拒绝。例如，app-不应屏蔽转向其他-app-的链接，或用户希望以某种特定方式运行的功能。进一步了解如何正确处理链接。" class="headerlink" title="2.5.9 如果 app 会改变或停用标准开关 (如调高/调低音量和铃声/静音开关) 的功能，或者改变或停用其他的原生用户界面元素或行为，则该 app 会遭到拒绝。例如，app 不应屏蔽转向其他 app 的链接，或用户希望以某种特定方式运行的功能。进一步了解如何正确处理链接。"></a>2.5.9 如果 app 会改变或停用标准开关 (如调高/调低音量和铃声/静音开关) 的功能，或者改变或停用其他的原生用户界面元素或行为，则该 app 会遭到拒绝。例如，app 不应屏蔽转向其他 app 的链接，或用户希望以某种特定方式运行的功能。进一步了解如何正确处理链接。</h3><h3 id="2-5-10-不得提交包含空白广告横幅或测试广告的-app。"><a href="#2-5-10-不得提交包含空白广告横幅或测试广告的-app。" class="headerlink" title="2.5.10 不得提交包含空白广告横幅或测试广告的 app。"></a>2.5.10 不得提交包含空白广告横幅或测试广告的 app。</h3><h3 id="2-5-11-SiriKit-和快捷方式"><a href="#2-5-11-SiriKit-和快捷方式" class="headerlink" title="2.5.11 SiriKit 和快捷方式"></a>2.5.11 SiriKit 和快捷方式</h3><p>(i) 集成 SiriKit 和快捷方式的 app 只能登记无需其他 app 支持便可处理的意图，而且这个意图应当与用户对所述功能的预期相符。例如，如果您的 app 属于膳食计划 app，则不应融入开始体能训练的意图，即使这个 app 共享了与健身 app 的集成也不可以。<br>(ii) 确保 plist 中的词汇和短语与您的 app 及它所登记意图的 Siri 功能相符。别名必须与您的 app 或公司名称直接相关，不得使用通用术语或者包含第三方 app 名称或服务。<br>(iii) 以最直接的方式解析 Siri 请求或快捷方式，不要在请求与实现之间插入任何广告或其他市场营销信息。只有在完成相关任务需要时 (例如让用户指定特定类型的体能训练时)，才可以要求解疑。</p>
<h3 id="2-5-12-利用-CallKit-或包含-SMS-Fraud-扩展的-app-应该只拦截已确认用于发送垃圾信息的电话号码。具有通话、短信或彩信拦截功能或垃圾信息识别功能的-app-必须在营销文本中清楚标识这些功能，并且说明归入拦截列表和垃圾信息列表的标准。通过这些工具获得的数据不得用于与运行或改进您的-app-或扩展没有直接关联的任何其他目的-例如，不得出于跟踪或创建用户资料等目的来使用、共享或销售这些数据-。"><a href="#2-5-12-利用-CallKit-或包含-SMS-Fraud-扩展的-app-应该只拦截已确认用于发送垃圾信息的电话号码。具有通话、短信或彩信拦截功能或垃圾信息识别功能的-app-必须在营销文本中清楚标识这些功能，并且说明归入拦截列表和垃圾信息列表的标准。通过这些工具获得的数据不得用于与运行或改进您的-app-或扩展没有直接关联的任何其他目的-例如，不得出于跟踪或创建用户资料等目的来使用、共享或销售这些数据-。" class="headerlink" title="2.5.12 利用 CallKit 或包含 SMS Fraud 扩展的 app 应该只拦截已确认用于发送垃圾信息的电话号码。具有通话、短信或彩信拦截功能或垃圾信息识别功能的 app 必须在营销文本中清楚标识这些功能，并且说明归入拦截列表和垃圾信息列表的标准。通过这些工具获得的数据不得用于与运行或改进您的 app 或扩展没有直接关联的任何其他目的 (例如，不得出于跟踪或创建用户资料等目的来使用、共享或销售这些数据)。"></a>2.5.12 利用 CallKit 或包含 SMS Fraud 扩展的 app 应该只拦截已确认用于发送垃圾信息的电话号码。具有通话、短信或彩信拦截功能或垃圾信息识别功能的 app 必须在营销文本中清楚标识这些功能，并且说明归入拦截列表和垃圾信息列表的标准。通过这些工具获得的数据不得用于与运行或改进您的 app 或扩展没有直接关联的任何其他目的 (例如，不得出于跟踪或创建用户资料等目的来使用、共享或销售这些数据)。</h3><h3 id="2-5-13-若有可能，使用人脸识别进行帐户验证的-app-必须使用-LocalAuthentication-英文-而非-ARKit-或其他人脸识别技术-，且必须对未满-13-岁的用户使用备用身份验证方式。"><a href="#2-5-13-若有可能，使用人脸识别进行帐户验证的-app-必须使用-LocalAuthentication-英文-而非-ARKit-或其他人脸识别技术-，且必须对未满-13-岁的用户使用备用身份验证方式。" class="headerlink" title="2.5.13 若有可能，使用人脸识别进行帐户验证的 app 必须使用 LocalAuthentication (英文) (而非 ARKit 或其他人脸识别技术)，且必须对未满 13 岁的用户使用备用身份验证方式。"></a>2.5.13 若有可能，使用人脸识别进行帐户验证的 app 必须使用 LocalAuthentication (英文) (而非 ARKit 或其他人脸识别技术)，且必须对未满 13 岁的用户使用备用身份验证方式。</h3><h3 id="2-5-14-在录像、记录日志或以其他方式记录用户活动时，app-必须征得用户的明确同意，而且要提供清晰的视觉指示。这还包括任何对设备摄像头、麦克风或其他用户输入方式的使用。"><a href="#2-5-14-在录像、记录日志或以其他方式记录用户活动时，app-必须征得用户的明确同意，而且要提供清晰的视觉指示。这还包括任何对设备摄像头、麦克风或其他用户输入方式的使用。" class="headerlink" title="2.5.14 在录像、记录日志或以其他方式记录用户活动时，app 必须征得用户的明确同意，而且要提供清晰的视觉指示。这还包括任何对设备摄像头、麦克风或其他用户输入方式的使用。"></a>2.5.14 在录像、记录日志或以其他方式记录用户活动时，app 必须征得用户的明确同意，而且要提供清晰的视觉指示。这还包括任何对设备摄像头、麦克风或其他用户输入方式的使用。</h3><h3 id="2-5-15-能够让用户查看和选择文件的-app-应包含“文件”app-中的项目和用户的-iCloud-文稿。"><a href="#2-5-15-能够让用户查看和选择文件的-app-应包含“文件”app-中的项目和用户的-iCloud-文稿。" class="headerlink" title="2.5.15 能够让用户查看和选择文件的 app 应包含“文件”app 中的项目和用户的 iCloud 文稿。"></a>2.5.15 能够让用户查看和选择文件的 app 应包含“文件”app 中的项目和用户的 iCloud 文稿。</h3><h1 id="3-业务"><a href="#3-业务" class="headerlink" title="3. 业务"></a>3. 业务</h1><p>在 App Store 中，您可以通过多种方式让自己的 app 实现盈利。如果您的业务模式并不显而易见，请务必在其元数据和 App Review 备注中加以说明。如果我们无法理解 app 的工作方式，或者 App 内购买项目不是那么一目了然，则审核会有所延误，并可能会导致 app 被拒绝。尽管价格由您决定，但是我们不会分发要价明显过高的 app 和 App 内购买项目。对于试图以不合常理的高昂价格欺骗用户的 app，我们将予以拒绝。</p>
<p>如果我们发现您试图操纵评论，通过付费、提供奖励、经过筛选或伪造反馈来提高排名，或者要求第三方服务代您这样做，我们会采取相应措施以维护 App Store 的公正诚信。采取的措施可能包括将您从 Apple Developer Program 中除名。</p>
<h2 id="3-1-付款"><a href="#3-1-付款" class="headerlink" title="3.1 付款"></a>3.1 付款</h2><h3 id="3-1-1-App-内购买项目："><a href="#3-1-1-App-内购买项目：" class="headerlink" title="3.1.1 App 内购买项目："></a>3.1.1 App 内购买项目：</h3><p>如果您想要在 app 内解锁特性或功能 (解锁方式有：订阅、游戏内货币、游戏关卡、优质内容的访问权限或解锁完整版等)，则必须使用 App 内购买项目。App 不得使用自身机制来解锁内容或功能，如许可证密钥、增强现实标记、二维码等。App 及对应元数据不得包含指引客户使用非 App 内购买项目机制进行购买的按钮、外部链接或其他行动号召用语。<br>App 可以提供 App 内购买货币，供客户在 app 内“打赏”数字内容提供商。<br>通过 App 内购买项目购买的所有点数和游戏货币不得过期，并且您应确保为所有可恢复的 App 内购买项目设计一套恢复机制。<br>请务必指定正确的可购买类型，否则您的 app 将被拒绝。<br>App 不得直接或间接地将 App 内购买项目内容、功能或消耗品赠予他人。<br>通过 Mac App Store 分发的 app 可托管基于非 App Store 机制的插件或扩展。<br>提供“战利品箱”或其他随机虚拟物品购买机制的 app 必须在客户购买前，向客户披露每种类型物品的获取几率。<br>非订阅型 app 在提供完整解锁选项前可以提供按时间计算的免费试用期，方法是在“价格等级 0”中设置非消耗型 IAP 项目，并按照命名约定“XX 天试用”来命名。在开始试用之前，app 必须清楚指明试用期时长、试用期结束后不再能访问的内容或服务，以及用户为获得完整功能而需要支付的任何后续费用。进一步了解如何使用收据 (英文) 和设备检查 (英文) 来管理内容访问权限和试用期时长。</p>
<h3 id="3-1-2-订阅：无论属于-App-Store-上哪一类别，app-都可以提供自动续订的-App-内购买订阅。在-app-内集成可自动续订的订阅时，请务必遵循下述指导原则。"><a href="#3-1-2-订阅：无论属于-App-Store-上哪一类别，app-都可以提供自动续订的-App-内购买订阅。在-app-内集成可自动续订的订阅时，请务必遵循下述指导原则。" class="headerlink" title="3.1.2 订阅：无论属于 App Store 上哪一类别，app 都可以提供自动续订的 App 内购买订阅。在 app 内集成可自动续订的订阅时，请务必遵循下述指导原则。"></a>3.1.2 订阅：无论属于 App Store 上哪一类别，app 都可以提供自动续订的 App 内购买订阅。在 app 内集成可自动续订的订阅时，请务必遵循下述指导原则。</h3><h3 id="3-1-2-a-允许的用途：如果您提供自动续订订阅，则必须为客户提供持续的价值，订阅期必须持续至少七天，并且能够在用户的所有设备上访问。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的-app；对媒体内容的大型合集或持续更新的访问权限；软件即服务-SAAS-；以及云服务支持。此外："><a href="#3-1-2-a-允许的用途：如果您提供自动续订订阅，则必须为客户提供持续的价值，订阅期必须持续至少七天，并且能够在用户的所有设备上访问。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的-app；对媒体内容的大型合集或持续更新的访问权限；软件即服务-SAAS-；以及云服务支持。此外：" class="headerlink" title="3.1.2(a) 允许的用途：如果您提供自动续订订阅，则必须为客户提供持续的价值，订阅期必须持续至少七天，并且能够在用户的所有设备上访问。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的 app；对媒体内容的大型合集或持续更新的访问权限；软件即服务 (SAAS)；以及云服务支持。此外："></a>3.1.2(a) 允许的用途：如果您提供自动续订订阅，则必须为客户提供持续的价值，订阅期必须持续至少七天，并且能够在用户的所有设备上访问。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的 app；对媒体内容的大型合集或持续更新的访问权限；软件即服务 (SAAS)；以及云服务支持。此外：</h3><p>订阅可与单点式服务一起提供。例如，您可以提供整个影片库的订阅，以及单部影片购买或租赁。<br>您可以在您的多个 app 和服务中提供跨 app 的订阅项目，但这些订阅不可扩展到第三方的 app 或服务。游戏订阅中提供的游戏必须由该开发者拥有或已受独家许可 (例如：非属于游戏发布平台的一部分)。所有游戏都必须直接从 App Store 下载。游戏须避免订阅用户的重复支付，且不应损害非订阅用户的利益。<br>订阅必须适用于可使用该 app 的所有用户设备。进一步了解在您的多个 app 之间共享订阅项目 (英文)。<br>App 不得强制要求用户为 app 评级或点评、下载其他 app，或执行其他类似操作，然后才能访问该 app 的功能、内容或者使用该 app。<br>与所有 app 一样，此类服务订阅应当允许用户直接获得付费购买的项目而无需执行额外任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。<br>订阅可以包含消耗性的积分、宝石或游戏内货币等。您也可以提供包含消耗性商品打折权益的订阅 (例如能以优惠价购买宝石包的高级会员资格)。<br>如果要将现有 app 更改为基于订阅的业务模式，您不得减掉现有用户已付费购买的主要功能。例如，针对新客户引入订阅模式后，已购买“完整游戏解锁”的客户应能够继续访问完整版游戏。<br>支持自动续期订阅的 app 可以通过提供 App Store Connect 中规定的相关信息，来为客户提供免费试用期。如果您的 app 试图通过虚假信息诱骗用户购买订阅或涉及“诱购”行为，这个 app 会被从 App Store 中移除，您也可能会被从开发者帐户中除名。进一步了解订阅免费试用期。</p>
<h3 id="3-1-2-b-升级和降级：用户应能获得无缝的升级-降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的最佳做法-英文-。"><a href="#3-1-2-b-升级和降级：用户应能获得无缝的升级-降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的最佳做法-英文-。" class="headerlink" title="3.1.2(b) 升级和降级：用户应能获得无缝的升级/降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的最佳做法 (英文)。"></a>3.1.2(b) 升级和降级：用户应能获得无缝的升级/降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的最佳做法 (英文)。</h3><h3 id="3-1-2-c-订阅信息：在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？务必清晰地传达“协议、税务和银行业务”下“Apple-Developer-Program-许可协议”的“附件-2”中所述的要求。"><a href="#3-1-2-c-订阅信息：在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？务必清晰地传达“协议、税务和银行业务”下“Apple-Developer-Program-许可协议”的“附件-2”中所述的要求。" class="headerlink" title="3.1.2(c) 订阅信息：在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？务必清晰地传达“协议、税务和银行业务”下“Apple Developer Program 许可协议”的“附件 2”中所述的要求。"></a>3.1.2(c) 订阅信息：在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？务必清晰地传达“协议、税务和银行业务”下“Apple Developer Program 许可协议”的“附件 2”中所述的要求。</h3><h3 id="3-1-3-a-“阅读器”App：App-可以允许用户访问先前购买的内容或内容订阅-具体包括：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如课堂管理-app-，前提是您同意不会直接或间接引导-iOS-用户使用非-App-内购买项目机制进行购买，并且在您介绍其他购买方式的普通沟通中没有刻意阻止用户使用-App-内购买项目。"><a href="#3-1-3-a-“阅读器”App：App-可以允许用户访问先前购买的内容或内容订阅-具体包括：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如课堂管理-app-，前提是您同意不会直接或间接引导-iOS-用户使用非-App-内购买项目机制进行购买，并且在您介绍其他购买方式的普通沟通中没有刻意阻止用户使用-App-内购买项目。" class="headerlink" title="3.1.3(a)“阅读器”App：App 可以允许用户访问先前购买的内容或内容订阅 (具体包括：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如课堂管理 app)，前提是您同意不会直接或间接引导 iOS 用户使用非 App 内购买项目机制进行购买，并且在您介绍其他购买方式的普通沟通中没有刻意阻止用户使用 App 内购买项目。"></a>3.1.3(a)“阅读器”App：App 可以允许用户访问先前购买的内容或内容订阅 (具体包括：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如课堂管理 app)，前提是您同意不会直接或间接引导 iOS 用户使用非 App 内购买项目机制进行购买，并且在您介绍其他购买方式的普通沟通中没有刻意阻止用户使用 App 内购买项目。</h3><h3 id="3-1-3-b-多平台服务：跨平台运行的-app-可以允许用户访问用户在别处获取的内容、订阅或功能，包括多平台游戏中的消耗品，前提是这些项目也在-app-中以-App-内购买项目的形式提供。您不得直接或间接引导-iOS-用户使用非-App-内购买机制进行购买，在您关于其他购买方式的一般说明中亦不可刻意阻止用户使用-App-内购买项目。"><a href="#3-1-3-b-多平台服务：跨平台运行的-app-可以允许用户访问用户在别处获取的内容、订阅或功能，包括多平台游戏中的消耗品，前提是这些项目也在-app-中以-App-内购买项目的形式提供。您不得直接或间接引导-iOS-用户使用非-App-内购买机制进行购买，在您关于其他购买方式的一般说明中亦不可刻意阻止用户使用-App-内购买项目。" class="headerlink" title="3.1.3(b) 多平台服务：跨平台运行的 app 可以允许用户访问用户在别处获取的内容、订阅或功能，包括多平台游戏中的消耗品，前提是这些项目也在 app 中以 App 内购买项目的形式提供。您不得直接或间接引导 iOS 用户使用非 App 内购买机制进行购买，在您关于其他购买方式的一般说明中亦不可刻意阻止用户使用 App 内购买项目。"></a>3.1.3(b) 多平台服务：跨平台运行的 app 可以允许用户访问用户在别处获取的内容、订阅或功能，包括多平台游戏中的消耗品，前提是这些项目也在 app 中以 App 内购买项目的形式提供。您不得直接或间接引导 iOS 用户使用非 App 内购买机制进行购买，在您关于其他购买方式的一般说明中亦不可刻意阻止用户使用 App 内购买项目。</h3><h3 id="3-1-4-硬件相关内容：在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app-可在不使用-App-内购买项目的情况下解锁相应功能-例如，天文-app-会在与望远镜同步后增加功能-。与经过批准的实际产品-如玩具-配合使用的可选-app-功能可在不使用-App-内购买项目的情况下解锁特定功能，前提是它同时也提供-App-内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁-app-功能。"><a href="#3-1-4-硬件相关内容：在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app-可在不使用-App-内购买项目的情况下解锁相应功能-例如，天文-app-会在与望远镜同步后增加功能-。与经过批准的实际产品-如玩具-配合使用的可选-app-功能可在不使用-App-内购买项目的情况下解锁特定功能，前提是它同时也提供-App-内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁-app-功能。" class="headerlink" title="3.1.4 硬件相关内容：在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app 可在不使用 App 内购买项目的情况下解锁相应功能 (例如，天文 app 会在与望远镜同步后增加功能)。与经过批准的实际产品 (如玩具) 配合使用的可选 app 功能可在不使用 App 内购买项目的情况下解锁特定功能，前提是它同时也提供 App 内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁 app 功能。"></a>3.1.4 硬件相关内容：在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app 可在不使用 App 内购买项目的情况下解锁相应功能 (例如，天文 app 会在与望远镜同步后增加功能)。与经过批准的实际产品 (如玩具) 配合使用的可选 app 功能可在不使用 App 内购买项目的情况下解锁特定功能，前提是它同时也提供 App 内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁 app 功能。</h3><h3 id="3-1-5-a-App-之外的商品和服务：如果-app-允许用户购买将在-app-之外使用的商品或服务，则必须使用-App-内购买项目以外的购买方式来收取相应款项，如-Apple-Pay-或传统的信用卡入口。"><a href="#3-1-5-a-App-之外的商品和服务：如果-app-允许用户购买将在-app-之外使用的商品或服务，则必须使用-App-内购买项目以外的购买方式来收取相应款项，如-Apple-Pay-或传统的信用卡入口。" class="headerlink" title="3.1.5 (a) App 之外的商品和服务：如果 app 允许用户购买将在 app 之外使用的商品或服务，则必须使用 App 内购买项目以外的购买方式来收取相应款项，如 Apple Pay 或传统的信用卡入口。"></a>3.1.5 (a) App 之外的商品和服务：如果 app 允许用户购买将在 app 之外使用的商品或服务，则必须使用 App 内购买项目以外的购买方式来收取相应款项，如 Apple Pay 或传统的信用卡入口。</h3><h3 id="3-1-5-b-加密货币："><a href="#3-1-5-b-加密货币：" class="headerlink" title="3.1.5 (b) 加密货币："></a>3.1.5 (b) 加密货币：</h3><p>(i) 钱包：App 可以协助虚拟货币储值，前提是它们由组织类别帐户的开发者提供。<br>(ii) 挖矿：App 不可参与虚拟货币挖矿，除非处理过程是在设备外进行的 (例如，云端挖矿)。<br>(iii) 兑换：App 可以通过经批准的交易所协助加密货币交易或传输，前提是它们是由交易所本身提供的。<br>(iv) 首次代币发行：App 如支持首次代币发行 (“ICO”)、数字加密货币期货交易以及其他数字加密证券或准证券交易，发布方须为已创立的银行、证券公司、期货经纪商 (“FCM”) 或其他经批准的金融机构，并遵守所有相关法律。<br>(v) 加密货币 app 不可通过完成任务来提供货币，如下载其他 app、鼓励其他用户下载，以及在社交网络发帖等。</p>
<h3 id="3-1-6-Apple-Pay：如果-app-使用-Apple-Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用-Apple-Pay-品牌和用户界面元素，具体要求可参考“Apple-Pay-识别标志指南-英文-”和“Human-Interface-Guidelines-英文-”。使用-Apple-Pay-提供重复付款服务的-app-至少需要披露以下信息："><a href="#3-1-6-Apple-Pay：如果-app-使用-Apple-Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用-Apple-Pay-品牌和用户界面元素，具体要求可参考“Apple-Pay-识别标志指南-英文-”和“Human-Interface-Guidelines-英文-”。使用-Apple-Pay-提供重复付款服务的-app-至少需要披露以下信息：" class="headerlink" title="3.1.6 Apple Pay：如果 app 使用 Apple Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用 Apple Pay 品牌和用户界面元素，具体要求可参考“Apple Pay 识别标志指南 (英文)”和“Human Interface Guidelines (英文)”。使用 Apple Pay 提供重复付款服务的 app 至少需要披露以下信息："></a>3.1.6 Apple Pay：如果 app 使用 Apple Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用 Apple Pay 品牌和用户界面元素，具体要求可参考“Apple Pay 识别标志指南 (英文)”和“Human Interface Guidelines (英文)”。使用 Apple Pay 提供重复付款服务的 app 至少需要披露以下信息：</h3><p>续订周期的时长；除非被取消，否则续订将会继续<br>每个周期中会提供哪些服务<br>将向客户收取的实际费用<br>如何取消</p>
<h3 id="3-1-7-广告：App-内显示的广告必须与-app-的年龄分级相符，允许用户查看用于引导至这个广告的所有信息-不要求用户离开-app-，并且不可涉及基于敏感用户数据的定向或行为广告。敏感的用户数据包括健康-医疗数据-如来自-HealthKit-API-的数据-、学校和课堂数据-如来自-ClassKit-的数据-，或儿童的数据-如来自儿童类别的-app-的数据-，等等。插播广告、会中断或阻止用户体验的广告必须清楚地表明它们属于广告，不得操纵或欺骗用户轻点它们，并且必须提供可以轻松访问和清晰可见的关闭-跳过按钮，按钮大小要足以让用户轻松解除广告。"><a href="#3-1-7-广告：App-内显示的广告必须与-app-的年龄分级相符，允许用户查看用于引导至这个广告的所有信息-不要求用户离开-app-，并且不可涉及基于敏感用户数据的定向或行为广告。敏感的用户数据包括健康-医疗数据-如来自-HealthKit-API-的数据-、学校和课堂数据-如来自-ClassKit-的数据-，或儿童的数据-如来自儿童类别的-app-的数据-，等等。插播广告、会中断或阻止用户体验的广告必须清楚地表明它们属于广告，不得操纵或欺骗用户轻点它们，并且必须提供可以轻松访问和清晰可见的关闭-跳过按钮，按钮大小要足以让用户轻松解除广告。" class="headerlink" title="3.1.7 广告：App 内显示的广告必须与 app 的年龄分级相符，允许用户查看用于引导至这个广告的所有信息 (不要求用户离开 app)，并且不可涉及基于敏感用户数据的定向或行为广告。敏感的用户数据包括健康/医疗数据 (如来自 HealthKit API 的数据)、学校和课堂数据 (如来自 ClassKit 的数据)，或儿童的数据 (如来自儿童类别的 app 的数据)，等等。插播广告、会中断或阻止用户体验的广告必须清楚地表明它们属于广告，不得操纵或欺骗用户轻点它们，并且必须提供可以轻松访问和清晰可见的关闭/跳过按钮，按钮大小要足以让用户轻松解除广告。"></a>3.1.7 广告：App 内显示的广告必须与 app 的年龄分级相符，允许用户查看用于引导至这个广告的所有信息 (不要求用户离开 app)，并且不可涉及基于敏感用户数据的定向或行为广告。敏感的用户数据包括健康/医疗数据 (如来自 HealthKit API 的数据)、学校和课堂数据 (如来自 ClassKit 的数据)，或儿童的数据 (如来自儿童类别的 app 的数据)，等等。插播广告、会中断或阻止用户体验的广告必须清楚地表明它们属于广告，不得操纵或欺骗用户轻点它们，并且必须提供可以轻松访问和清晰可见的关闭/跳过按钮，按钮大小要足以让用户轻松解除广告。</h3><h2 id="3-2-其他业务模式问题"><a href="#3-2-其他业务模式问题" class="headerlink" title="3.2 其他业务模式问题"></a>3.2 其他业务模式问题</h2><p>下方列表并非详尽清单，并且您提交的 app 可能会导致我们的政策有所更改或更新，但这里有一些额外的应做事宜和勿做事宜需要您谨记在心：</p>
<h3 id="3-2-1-可以接受"><a href="#3-2-1-可以接受" class="headerlink" title="3.2.1 可以接受"></a>3.2.1 可以接受</h3><p>(i) 在您的 app 中，出于购买或促销目的而展示您的其他 app，只要您的 app 不只是简单地罗列其他 app。<br>(ii) 显示或推荐专为经批准的特定需求而设计的第三方 app (如健康管理、航空以及辅助功能等)。您的 app 应能提供持续不断的编辑内容，这样 app 才不会看起来像是个摆设。<br>(iii) 在租借期限结束后，禁止访问经批准的特定租借内容 (例如电影、电视节目、音乐、图书)；所有其他项目服务不得存在过期时间。<br>(iv) 钱包凭证可用于付款或接收付款、传输交易或是提供身份验证 (例如电影票、优惠券和 VIP 凭据)。如将钱包凭证用作其他用途，则可能会导致 app 被拒，钱包凭据也有可能被撤销。<br>(v) 保险类 app 必须免费提供，并且必须遵守 app 发布地区的相关法律，且不得使用 App 内购买项目。<br>(vi) 经批准的非营利组织可以在他们持有的 App 或第三方 app 内进行筹款活动，前提是这些筹款活动必须遵守所有的 App Review 准则并提供 Apple Pay 支持。这类 app 必须披露资金的计划用途，遵守所有必要的当地和联邦政府法律，并且确保向捐款人提供相应的报税收据。在被要求时，还应向 App Review 团队提供其他信息。向捐款人介绍其他非营利组织的非营利组织平台必须确保 app 中列出的每一家非营利组织都已通过非营利组织批准流程。进一步了解如何成为受批准的非营利组织 (英文)。<br>(vii) App 可允许个人用户使用非 App 内购买项目机制向另一位个人送赠货币式礼物，前提为：a) 送赠方拥有决定是否进行送赠的完全自主权，b) 获赠方收取 100% 的礼物金额。然而，礼物若在任何时间点对应或包含接收任何数字内容或服务，则必须使用 App 内购买项目。<br>(viii) App 如用于金融交易，投资或资金管理，发布方应为执行此类服务的金融机构，或必须使用由相应机构根据自身条款与条件提供的公共 API。</p>
<h3 id="3-2-2-不可接受"><a href="#3-2-2-不可接受" class="headerlink" title="3.2.2 不可接受"></a>3.2.2 不可接受</h3><p>(i) 创建与 App Store 类似且用于显示第三方 app、扩展或插件的界面，或将其作为热门 app 的合集。<br>(ii) 通过由硬件或操作系统提供的内置功能 (诸如推送通知、照相机或陀螺仪) 或 Apple 服务 (如 Apple Music 访问或 iCloud 存储) 获利。<br>(iii) 人为地刷广告展示次数或者广告点进次数的 app，以及主要设计目的在于显示广告的 app。<br>(iv) 在 app 内为慈善机构和募款方筹集资金，除非您是经批准的非营利组织或依上文 3.2.1 (vi) 规定获得了许可。出于以上目的筹集资金的 app 必须在 App Store 上提供免费下载，并只能在 app 之外筹集，例如通过 Safari 浏览器或短信。<br>(v) 强行限制 app 的用户群，例如限制特定地区或运营商。<br>(vi) App 应当允许用户直接获得付费购买的项目而无需执行额外的任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。App 不得要求用户必须先为 app 评分或点评、观看视频、下载其他 app、点击广告或进行其他类似操作，然后才能访问 app 的功能、内容或使用 app，或者接受现金或其他补偿。<br>(vii) 人为操纵用户在其他服务中的可见性、状态或排名，除非相关服务的条款和条件允许这样做。<br>(viii) App Store 中不允许分发协助进行二元期权交易的 app。请考虑使用网页版 app。App 如支持差价合约或其他金融衍生工具 (如外汇) 交易，则必须在提供服务的所有司法管辖区获得相应的许可。<br>(ix) App 不得强制要求用户为 app 评级或点评、下载其他 app，或执行其他类似操作，然后才能访问 app 的功能、内容或者使用 app。</p>
<h1 id="4-设计"><a href="#4-设计" class="headerlink" title="4. 设计"></a>4. 设计</h1><p>Apple 客户非常看重简洁、雅致、创新且易于使用的产品，这也正是我们希望在 App Store 上看到的。您可尽情提供各种优秀设计，但在 App Store 上被获准发布的 app 至少需要满足以下标准。另请记住，即使在 app 获得批准之后，您也应当对其进行更新，确保 app 能正常工作并持续吸引新客户和现有客户。停止服务或体验下降的 app 随时可能会从 App Store 中被移除。</p>
<h2 id="4-1-抄袭者"><a href="#4-1-抄袭者" class="headerlink" title="4.1 抄袭者"></a>4.1 抄袭者</h2><p>请拿出您自己的想法。我们知道您有自己的奇思妙想，那么请将它们付诸实际。请不要简单照搬 App Store 上的热门 app，或只是细微修改其他 app 的名称或 UI，就将其挪为己用。这么做不但有引发知识产权侵权索赔的风险，更会加大在 App Store 中浏览的难度，而且对您的开发者同仁来说也不公平。</p>
<h2 id="4-2-最低功能要求"><a href="#4-2-最低功能要求" class="headerlink" title="4.2 最低功能要求"></a>4.2 最低功能要求</h2><p>App 应包含功能、内容和 UI，而不仅仅是一个经过重新包装的网站。如果 app 没有什么实用价值、毫无新意或者不太像是一个 app，那它就不适合出现在 App Store 中。如果 app 不能带来持久的娱乐价值，或只是让人感到毛骨悚然，则无法获得批准。如果 app 只是一首歌曲或一部影片，则应提交到 iTunes Store。如果 app 只是一本书籍或游戏指南，则应提交到 iBooks Store。</p>
<h3 id="4-2-1-使用-ARKit-的-app-应提供丰富而完整的增强现实体验，仅将模型放入-AR-视图或重播动画并不足够。"><a href="#4-2-1-使用-ARKit-的-app-应提供丰富而完整的增强现实体验，仅将模型放入-AR-视图或重播动画并不足够。" class="headerlink" title="4.2.1 使用 ARKit 的 app 应提供丰富而完整的增强现实体验，仅将模型放入 AR 视图或重播动画并不足够。"></a>4.2.1 使用 ARKit 的 app 应提供丰富而完整的增强现实体验，仅将模型放入 AR 视图或重播动画并不足够。</h3><h3 id="4-2-2-除了目录类-app-之外，app-不应只包含市场营销材料、广告、网络剪报、内容聚合或链接集合。"><a href="#4-2-2-除了目录类-app-之外，app-不应只包含市场营销材料、广告、网络剪报、内容聚合或链接集合。" class="headerlink" title="4.2.2 除了目录类 app 之外，app 不应只包含市场营销材料、广告、网络剪报、内容聚合或链接集合。"></a>4.2.2 除了目录类 app 之外，app 不应只包含市场营销材料、广告、网络剪报、内容聚合或链接集合。</h3><h3 id="4-2-3"><a href="#4-2-3" class="headerlink" title="4.2.3"></a>4.2.3</h3><p>(i) App 应能独立工作，无需安装其他 app。<br>(ii) 确保 app 发布时在其二进制文件中包含有正常运行所需的充足内容。<br>(iii) 如果 app 需要下载其他资源，请披露下载大小并在下载之前提醒用户。现有 app 在 2019 年 1 月 1 日后提交的所有更新都必须遵循这一准则。</p>
<h3 id="4-2-4-与表盘类似的-Apple-Watch-app-可能会令人感到困惑，因为用户会认为这些-app-能与各种设备功能-如轻扫、通知和第三方功能栏-配合使用。将创意性的时间表现方式用作-app-界面是个好点子-例如，供冲浪者使用的潮汐时钟-，但是如果您的-app-与表盘过于相像，则可能会被我们拒绝。"><a href="#4-2-4-与表盘类似的-Apple-Watch-app-可能会令人感到困惑，因为用户会认为这些-app-能与各种设备功能-如轻扫、通知和第三方功能栏-配合使用。将创意性的时间表现方式用作-app-界面是个好点子-例如，供冲浪者使用的潮汐时钟-，但是如果您的-app-与表盘过于相像，则可能会被我们拒绝。" class="headerlink" title="4.2.4 与表盘类似的 Apple Watch app 可能会令人感到困惑，因为用户会认为这些 app 能与各种设备功能 (如轻扫、通知和第三方功能栏) 配合使用。将创意性的时间表现方式用作 app 界面是个好点子 (例如，供冲浪者使用的潮汐时钟)，但是如果您的 app 与表盘过于相像，则可能会被我们拒绝。"></a>4.2.4 与表盘类似的 Apple Watch app 可能会令人感到困惑，因为用户会认为这些 app 能与各种设备功能 (如轻扫、通知和第三方功能栏) 配合使用。将创意性的时间表现方式用作 app 界面是个好点子 (例如，供冲浪者使用的潮汐时钟)，但是如果您的 app 与表盘过于相像，则可能会被我们拒绝。</h3><h3 id="4-2-5-主要用作-iCloud-和-iCloud-云盘文件管理器的-app-需要包含更多的-app-功能，才能获得批准。"><a href="#4-2-5-主要用作-iCloud-和-iCloud-云盘文件管理器的-app-需要包含更多的-app-功能，才能获得批准。" class="headerlink" title="4.2.5 主要用作 iCloud 和 iCloud 云盘文件管理器的 app 需要包含更多的 app 功能，才能获得批准。"></a>4.2.5 主要用作 iCloud 和 iCloud 云盘文件管理器的 app 需要包含更多的 app 功能，才能获得批准。</h3><h3 id="4-2-6-利用商业化模板或-app-生成服务创建的-app-将被拒绝，除非这个-app-由相应内容的提供商直接提交。这些模板服务若要为不同的客户提供差异化的用户体验，可提供工具来帮助客户自行创建创新的-app，但不应代表客户提交-app。模板提供商也可以考虑创建单一的二进制文件，以汇总或“选取”的模型托管所有客户端内容-例如：在搜索餐厅的-app-里为每个客户餐厅定制独立的条目或页面，或在聚会活动-app-里为每个客户的活动创建单独的条目-。"><a href="#4-2-6-利用商业化模板或-app-生成服务创建的-app-将被拒绝，除非这个-app-由相应内容的提供商直接提交。这些模板服务若要为不同的客户提供差异化的用户体验，可提供工具来帮助客户自行创建创新的-app，但不应代表客户提交-app。模板提供商也可以考虑创建单一的二进制文件，以汇总或“选取”的模型托管所有客户端内容-例如：在搜索餐厅的-app-里为每个客户餐厅定制独立的条目或页面，或在聚会活动-app-里为每个客户的活动创建单独的条目-。" class="headerlink" title="4.2.6 利用商业化模板或 app 生成服务创建的 app 将被拒绝，除非这个 app 由相应内容的提供商直接提交。这些模板服务若要为不同的客户提供差异化的用户体验，可提供工具来帮助客户自行创建创新的 app，但不应代表客户提交 app。模板提供商也可以考虑创建单一的二进制文件，以汇总或“选取”的模型托管所有客户端内容 (例如：在搜索餐厅的 app 里为每个客户餐厅定制独立的条目或页面，或在聚会活动 app 里为每个客户的活动创建单独的条目)。"></a>4.2.6 利用商业化模板或 app 生成服务创建的 app 将被拒绝，除非这个 app 由相应内容的提供商直接提交。这些模板服务若要为不同的客户提供差异化的用户体验，可提供工具来帮助客户自行创建创新的 app，但不应代表客户提交 app。模板提供商也可以考虑创建单一的二进制文件，以汇总或“选取”的模型托管所有客户端内容 (例如：在搜索餐厅的 app 里为每个客户餐厅定制独立的条目或页面，或在聚会活动 app 里为每个客户的活动创建单独的条目)。</h3><h3 id="4-2-7-远程-App-镜像：如果您的远程桌面-app-用作特定软件或服务的镜像，而不是主机设备的普通镜像，则必须符合以下规定："><a href="#4-2-7-远程-App-镜像：如果您的远程桌面-app-用作特定软件或服务的镜像，而不是主机设备的普通镜像，则必须符合以下规定：" class="headerlink" title="4.2.7 远程 App 镜像：如果您的远程桌面 app 用作特定软件或服务的镜像，而不是主机设备的普通镜像，则必须符合以下规定："></a>4.2.7 远程 App 镜像：如果您的远程桌面 app 用作特定软件或服务的镜像，而不是主机设备的普通镜像，则必须符合以下规定：</h3><p>(a) 主机设备是归用户所有的个人电脑，并且主机和客户端必须通过本地局域网连接。<br>(b) 客户端中显示的任何软件或服务应在主机设备屏幕上完整呈现，并且不可使用超出远程桌面传输所需的 API 或平台功能。<br>(c) 所有帐户的创建和管理均必须从主机设备发起。<br>(d) 客户端上显示的 UI 不与 iOS 或 App Store 视图类似，不提供商店类界面，也不能供用户浏览、选择或购买用户尚未拥有或授权的软件。为明确起见，在镜像的软件中发生的交易不需要使用 App 内购买，前提是这些交易是在主机设备上处理的。</p>
<h2 id="4-3-重复-App"><a href="#4-3-重复-App" class="headerlink" title="4.3 重复 App"></a>4.3 重复 App</h2><p>请不要为同一个 app 创建多个套装 ID。如果您的 app 针对特定位置、运动队、大学等存在不同版本，请考虑提交单个 app，并提供 App 内购买项目以提供不同的功能。同时，请避免继续在已有大量类似 app 的类别下进行开发；App Store 上已经有太多模拟放屁、打嗝声音的 app，以及手电筒和爱经 app。上传大量相似版本 app 的开发者会遭到 Apple Developer Program 的除名。</p>
<h2 id="4-4-扩展"><a href="#4-4-扩展" class="headerlink" title="4.4 扩展"></a>4.4 扩展</h2><p>托管或包含扩展的 app 必须遵循“App 扩展编程指南 (英文)”或“Safari 浏览器扩展开发指南 (英文)”，如果可行，还应包含诸如帮助屏幕和设置界面在内的一系列功能。您应当在 app 的市场营销文本中清晰且准确地披露提供了哪些扩展，扩展中不可包含营销、广告或 App 内购买项目。</p>
<h3 id="4-4-1-Keyboard-扩展还需要遵循一些额外的规则。"><a href="#4-4-1-Keyboard-扩展还需要遵循一些额外的规则。" class="headerlink" title="4.4.1 Keyboard 扩展还需要遵循一些额外的规则。"></a>4.4.1 Keyboard 扩展还需要遵循一些额外的规则。</h3><p>它们必须：</p>
<p>提供键盘输入功能 (如可输入字符)；<br>如果键盘中含有图像或表情符号，请遵循贴纸准则；<br>提供切换到下一个键盘的方法；<br>在没有网络连接和不要求完全访问权限的情况下仍能使用；<br>收集用户活动数据只是为了改进其 Keyboard 扩展在 iOS 设备上的性能。<br>它们不得：</p>
<p>启动“设置”之外的其他 app；或者<br>将键盘按键用于其他行为，例如按住 return 键来启动相机等。</p>
<h3 id="4-4-2-Safari-浏览器扩展必须在-macOS-上的最新版-Safari-浏览器上运行。它们不得干扰系统和-Safari-浏览器-UI-元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到-Apple-Developer-Program-除名。除了正常工作所必需的网站，Safari-浏览器扩展不得要求访问更多网站。"><a href="#4-4-2-Safari-浏览器扩展必须在-macOS-上的最新版-Safari-浏览器上运行。它们不得干扰系统和-Safari-浏览器-UI-元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到-Apple-Developer-Program-除名。除了正常工作所必需的网站，Safari-浏览器扩展不得要求访问更多网站。" class="headerlink" title="4.4.2 Safari 浏览器扩展必须在 macOS 上的最新版 Safari 浏览器上运行。它们不得干扰系统和 Safari 浏览器 UI 元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到 Apple Developer Program 除名。除了正常工作所必需的网站，Safari 浏览器扩展不得要求访问更多网站。"></a>4.4.2 Safari 浏览器扩展必须在 macOS 上的最新版 Safari 浏览器上运行。它们不得干扰系统和 Safari 浏览器 UI 元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到 Apple Developer Program 除名。除了正常工作所必需的网站，Safari 浏览器扩展不得要求访问更多网站。</h3><h3 id="4-4-3-表情贴纸"><a href="#4-4-3-表情贴纸" class="headerlink" title="4.4.3 表情贴纸"></a>4.4.3 表情贴纸</h3><p>表情贴纸是让“信息”变得更动态、更有趣的绝佳方式，让人们能够以更巧妙、有趣、有意义的方式表达自我。无论您的 app 是含有 Sticker 扩展，还是您要创建单独的表情贴纸包，其内容均不得冒犯用户、造成负面体验或违反相关法律。</p>
<p>(i) 通常，不适合在 App Store 上发布的内容也不适合放入表情贴纸内。<br>(ii) 考虑地区敏感性，不要在难以接受或者会违反当地法律的国家/地区提供您的表情贴纸包。<br>(iii) 如果您的表情贴纸含义不易理解，请在审核备注中附上清晰的说明，从而避免导致审核流程的延误。<br>(iv) 确保您的表情贴纸在您的朋友与家人之外具有相关性；它们不应特定于个人活动、群体或关系。<br>(v) 您必须对表情贴纸中的内容，持有所有必要的著作权、商标权和形象权及授权许可，不得提交任何未经授权的内容。请记住，您必须能够在要求时提供可核实的文件。若 app 内含有您无权使用的表情贴纸内容，该 app 将从 App Store 中去除，屡次侵权者将从开发者帐户中除名。如果您认为自己的内容遭到其他提供商侵权，请点击此处提交申诉。</p>
<h2 id="4-5-Apple-站点和服务"><a href="#4-5-Apple-站点和服务" class="headerlink" title="4.5 Apple 站点和服务"></a>4.5 Apple 站点和服务</h2><h3 id="4-5-1-App-可以使用获批的-Apple-RSS-Feed-如-iTunes-Store-RSS-Feed-，但不能抹除-Apple-站点-如-apple-com、iTunes-Store、App-Store、App-Store-Connect、开发者门户等-的任何信息，也不能使用这类信息进行排名。"><a href="#4-5-1-App-可以使用获批的-Apple-RSS-Feed-如-iTunes-Store-RSS-Feed-，但不能抹除-Apple-站点-如-apple-com、iTunes-Store、App-Store、App-Store-Connect、开发者门户等-的任何信息，也不能使用这类信息进行排名。" class="headerlink" title="4.5.1 App 可以使用获批的 Apple RSS Feed (如 iTunes Store RSS Feed)，但不能抹除 Apple 站点 (如 apple.com、iTunes Store、App Store、App Store Connect、开发者门户等) 的任何信息，也不能使用这类信息进行排名。"></a>4.5.1 App 可以使用获批的 Apple RSS Feed (如 iTunes Store RSS Feed)，但不能抹除 Apple 站点 (如 apple.com、iTunes Store、App Store、App Store Connect、开发者门户等) 的任何信息，也不能使用这类信息进行排名。</h3><h3 id="4-5-2-Apple-Music"><a href="#4-5-2-Apple-Music" class="headerlink" title="4.5.2 Apple Music"></a>4.5.2 Apple Music</h3><p>(i) MusicKit API 可以让客户在使用您的 app 时访问自己的订阅。它们旨在为 Apple Music 订阅用户提供轻松简便的音乐播放体验。用户必须能够发起 Apple Music 流媒体播放，并且能够使用“播放”、“暂停”和“跳过”等标准媒体控件来浏览音乐内容。此外，您的 app 不得要求用户通过付款或间接的货币化方式来获取 Apple Music 服务的访问权限 (如 App 内购买项目、广告、要求使用用户信息等)。请勿下载、上传或分享源自 MusicKit API 的音乐文件，除非 MusicKit (英文)文稿中已明确允许。<br>(ii) 使用 MusicKit API 并不能取代为获得更深入或更复杂的音乐集成而可能需要的授权许可。例如，如果您希望您的 app 在特定时刻播放特定的歌曲，或者创建可以在社交媒体上分享的音频或视频文件，您需要直接联系版权持有人来获得许可 (如同步或改编权利) 和资源。封面插图和其他元数据仅可用于与音乐播放或播放列表相关的用途 (包括展示 app 功能的 App Store 屏幕快照)，未经版权持有人明确授权，不得用于任何市场营销或广告目的。在 app 中集成 Apple Music 服务时，请务必遵循“Apple Music 识别标志指南 (英文)”。<br>(iii) 访问 Apple Music 用户数据 (如播放列表和个人收藏) 的 app 必须在用途字符串中清楚披露这类访问行为。收集的任何数据均不得与第三方分享，也不得用于除支持或改进 app 体验之外的任何其他用途。这类数据不得用于识别用户身份或设备，也不得用于广告定向宣传目的。</p>
<h3 id="4-5-3-不得使用-Apple-服务-包括-Game-Center-或推送通知等-发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家-ID、别名以及通过-Game-Center-获得的其他信息。否则将会遭到-Apple-Developer-Program-的除名。"><a href="#4-5-3-不得使用-Apple-服务-包括-Game-Center-或推送通知等-发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家-ID、别名以及通过-Game-Center-获得的其他信息。否则将会遭到-Apple-Developer-Program-的除名。" class="headerlink" title="4.5.3 不得使用 Apple 服务 (包括 Game Center 或推送通知等) 发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家 ID、别名以及通过 Game Center 获得的其他信息。否则将会遭到 Apple Developer Program 的除名。"></a>4.5.3 不得使用 Apple 服务 (包括 Game Center 或推送通知等) 发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家 ID、别名以及通过 Game Center 获得的其他信息。否则将会遭到 Apple Developer Program 的除名。</h3><h3 id="4-5-4-App-不得将推送通知列为必需条件，并不能将这项功能用于广告、推广或直接营销用途，或者用来发送敏感的个人或机密信息。不当使用这些服务可能会导致撤销您的权限。"><a href="#4-5-4-App-不得将推送通知列为必需条件，并不能将这项功能用于广告、推广或直接营销用途，或者用来发送敏感的个人或机密信息。不当使用这些服务可能会导致撤销您的权限。" class="headerlink" title="4.5.4 App 不得将推送通知列为必需条件，并不能将这项功能用于广告、推广或直接营销用途，或者用来发送敏感的个人或机密信息。不当使用这些服务可能会导致撤销您的权限。"></a>4.5.4 App 不得将推送通知列为必需条件，并不能将这项功能用于广告、推广或直接营销用途，或者用来发送敏感的个人或机密信息。不当使用这些服务可能会导致撤销您的权限。</h3><h3 id="4-5-5-仅以-Game-Center-团队批准的方式使用-Game-Center-玩家-ID，并不得在-app-中显示或向任何第三方显示。"><a href="#4-5-5-仅以-Game-Center-团队批准的方式使用-Game-Center-玩家-ID，并不得在-app-中显示或向任何第三方显示。" class="headerlink" title="4.5.5 仅以 Game Center 团队批准的方式使用 Game Center 玩家 ID，并不得在 app 中显示或向任何第三方显示。"></a>4.5.5 仅以 Game Center 团队批准的方式使用 Game Center 玩家 ID，并不得在 app 中显示或向任何第三方显示。</h3><h3 id="4-5-6-App-可以在自身和-app-元数据中使用会呈现为-Apple-表情符号的-Unicode-字符。Apple-表情符号不可在其他平台中使用，也不可直接嵌入到您的-app-二进制文件中。"><a href="#4-5-6-App-可以在自身和-app-元数据中使用会呈现为-Apple-表情符号的-Unicode-字符。Apple-表情符号不可在其他平台中使用，也不可直接嵌入到您的-app-二进制文件中。" class="headerlink" title="4.5.6 App 可以在自身和 app 元数据中使用会呈现为 Apple 表情符号的 Unicode 字符。Apple 表情符号不可在其他平台中使用，也不可直接嵌入到您的 app 二进制文件中。"></a>4.5.6 App 可以在自身和 app 元数据中使用会呈现为 Apple 表情符号的 Unicode 字符。Apple 表情符号不可在其他平台中使用，也不可直接嵌入到您的 app 二进制文件中。</h3><h2 id="4-6-备选-App-图标"><a href="#4-6-备选-App-图标" class="headerlink" title="4.6 备选 App 图标"></a>4.6 备选 App 图标</h2><p>App 可以使用自定图标以传达特定信息 (例如表达对某个运动团队的喜爱)，前提是每次更改都由用户发起，并且 app 中应包含恢复至原始图标的设置。所有图标变体必须与 app 的内容相关，并且更改内容在所有系统资源之间应保持一致，以便“设置”和“通知”等位置中显示的图标与新的 Springboard 图标相吻合。这项功能不可用于动态、自动或连续性更改，例如用于反映最新天气信息和日历通知等。</p>
<h2 id="4-7-HTML5-游戏与聊天机器人-Bot-等"><a href="#4-7-HTML5-游戏与聊天机器人-Bot-等" class="headerlink" title="4.7 HTML5 游戏与聊天机器人 (Bot) 等"></a>4.7 HTML5 游戏与聊天机器人 (Bot) 等</h2><p>App 可包含或运行未嵌入二进制文件的代码 (如基于 HTML5 的游戏和聊天机器人等)，前提是 app 的主要目的并非代码分发，代码亦没有在商店界面或类似商店的界面中提供，而且相关软件 (1) 为免费软件或需通过 App 内购买项目进行购买；(2) 仅使用标准 WebKit 视图中提供的功能 (例如，它必须在 Safari 浏览器中原生打开和运行，且无需修改也无需其他软件)；您的 app 必须使用 WebKit 和 JavaScript Core 来运行第三方软件，且不得试图扩展或披露原生平台 API 给第三方软件；(3) 由已加入 Apple Developer Program 且签署“Apple Developer Program 许可协议”的开发者提供；并且 (4) 遵守各个 App Review 指南中的条款 (例如，不含令人反感的内容；使用 App 内购买项目解锁特性和功能)。在被要求时，您必须提供 app 中所含软件和元数据的索引信息。它必须包含软件提供商的 Apple Developer Program 团队 ID，以及可供 App Review 团队用于确认软件符合上述要求的 URL。</p>
<h1 id="5-法律"><a href="#5-法律" class="headerlink" title="5. 法律"></a>5. 法律</h1><p>只要 app 向某个地区的用户提供，那么就必须遵守该地区的所有法律要求 (如果您不太确定，请与律师联系)。我们知道这些东西非常复杂，但除了下方所列准则以外，同时理解所有本地法律，并确保您的 app 能满足所有法律要求，是您必须承担的责任。当然，如果 app 存在唆使、宣传或鼓励犯罪的行为或明显不负责任的行为，则会被拒绝。在发现涉及如方便人口贩卖和/或剥削儿童的 app 的极端情况下，我们将通知有关当局。</p>
<h2 id="5-1-隐私"><a href="#5-1-隐私" class="headerlink" title="5.1 隐私"></a>5.1 隐私</h2><p>在 Apple 生态体系中，保护用户隐私总是第一要务。您要在处理个人数据时小心谨慎，以确保遵守了隐私保护最佳做法 (英文)、适用的法律和“Apple Developer Program 许可协议 (英文)”中的条款，并满足客户的期望。尤其是：</p>
<h3 id="5-1-1-数据收集和存储"><a href="#5-1-1-数据收集和存储" class="headerlink" title="5.1.1 数据收集和存储"></a>5.1.1 数据收集和存储</h3><p>(i) 隐私政策：所有 app 必须在 App Store Connect 元数据栏位和 app 内部包含可轻松访问的隐私政策链接。隐私政策必须明确而清楚地：<br>指明 app/服务所收集的数据 (若有)、收集数据的方式，以及这些数据的所有用途。<br>确认与 app 共享用户数据 (遵从这些准则) 的任何第三方 (例如，分析工具、广告网络和第三方 SDK，以及能够访问用户数据的任何母公司、子公司或其他相关实体) 会提供与 app 隐私政策所述及这些准则所要求相同或等同的用户数据保护措施。<br>解释数据保留/删除政策，并且说明用户可以如何撤销同意和/或请求删除用户数据。<br>(ii) 许可：收集用户数据或使用数据的 app 必须征得用户的同意。付费功能不得依赖于或要求用户授予访问这些数据的权限。App 还必须为客户提供简单易懂且易于操作的方式来撤销同意。确保您在用途说明中清楚且完整地阐述您对数据的使用。如果 app 依据欧盟《一般数据保护条例》(“GDPR”) 或类似法规，出于合法权益而不经事先同意就收集数据，则必须遵循此类法律的所有条款。进一步了解请求许可 (英文)。<br>(iii) 数据最少化：App 仅可请求访问与 app 核心功能相关的数据，并且仅可收集和使用完成相关任务所需的数据。若有可能，请使用进程外选取器或共享列表，而不要请求“照片”或“通讯录”等受保护资源的完整访问权限。<br>(iv) 访问权限：App 必须尊重用户的权限设置，不得操纵、欺骗或强迫用户同意不必要的数据访问。例如，可发布照片到社交网络的 app 不得在允许用户上传照片前要求麦克风访问权限。若有可能，请为不同意的用户提供替代解决方案。例如，如果用户拒绝共享位置，请提供手动输入地址的功能。<br>(v) 帐户登录：如果 app 不包含基于帐户的重要功能，请允许用户在不登录的情况下使用。App 不得要求用户提供个人信息才能正常使用，除非个人信息与 app 的核心功能直接相关，或是法律要求时。如果您的核心 app 功能与特定的社交网络 (如 Facebook、微信、微博或 Twitter 等) 不相关，您必须提供无需登录或其他类似机制的访问权限。调取基本档案信息、分享到社交网络或邀请朋友使用 app 等不视为核心 app 功能。App 还必须包含用于撤销社交网络凭证的机制，以及从 app 内停用 app 与社交网络之间数据访问的机制。App 不可在设备外存储社交网络的凭证或令牌，而且只能使用此类凭证或令牌来在 app 使用期间从 app 本身直接连接社交网络。<br>(vi) 如果开发者开发的 app 试图暗中收集用户密码或其他用户私人数据，那么开发者会被从 Apple Developer Program 中除名。<br>(iv) 必须使用 SafariViewContoller 在显著位置向用户显示信息；不得隐藏这个控制器，也不能被其他视图或图层遮挡。此外，未经用户的知情和同意，app 不得私下利用 Safari 浏览器 ViewController 来追踪用户。</p>
<h3 id="5-1-2-数据使用和共享"><a href="#5-1-2-数据使用和共享" class="headerlink" title="5.1.2 数据使用和共享"></a>5.1.2 数据使用和共享</h3><p>(i) 除非法律另有许可，否则您不得未经他人允许而使用、传输或共享他们的个人数据。您必须提供相应的信息，说明以何种方式在哪里使用这些数据。App 收集的数据只有在为了改进 app 或用于广告投放用途 (在遵守 Apple Developer Program 许可协议 (英文)) 的前提下，才能与第三方共享。如果 app 在未经用户同意或未能符合数据隐私保护法律的情况下共享用户数据，则 app 可能会被从销售名单中移除，并且可能会导致您被从 Apple Developer Program 中除名。<br>(ii) 除非法律另有明确许可，否则未经用户的额外同意，为一个用途而收集的数据不可用于其他用途。<br>(iii) App 不得试图暗中基于收集的数据构建用户资料，也不得尝试、协助或鼓励他人根据从 Apple 提供的 API 收集的数据，或您所谓以“匿名”、“汇总”或其他不可识别的方式收集的数据来识别匿名用户的身份或重建用户资料。<br>(iv) 请勿使用来自“通讯录”、“照片”或能访问用户数据的其他 API 的信息来构建联系人数据库，以供自己使用或出售/分发给第三方，也不要收集关于用户设备上安装有哪些 app 的信息，以用于分析或投放广告/市场营销。<br>(v) 请勿使用通过“通讯录”或“照片”收集的信息来联系用户，除非用户以个人方式明确主动发起联系；请勿包含“全部选择”选项，也不要默认选中所有联系人。在信息发送之前，您必须向用户清楚说明这个信息会如何呈现给收件人 (例如，信息中包含什么内容？发件人显示为谁？)。<br>(vi) 从 HomeKit API、HealthKit、消费者健康记录 API、MovementDisorder API、ClassKit 或深度图和/或面谱绘制工具 (例如 ARKit、相机 API 或照片 API) 收集的数据，不得用于市场营销、投放广告或基于使用情况进行其他数据挖掘，包括第三方在内。进一步了解实施 CallKit (英文)、HealthKit (英文)、ClassKit (英文) 和 ARKit (英文) 的最佳做法。<br>(vii) 使用 Apple Pay 的 app 只能与第三方共享通过 Apple Pay 获得的用户数据，以帮助或改进商品或服务的交付。</p>
<h3 id="5-1-3-健康和健康研究"><a href="#5-1-3-健康和健康研究" class="headerlink" title="5.1.3 健康和健康研究"></a>5.1.3 健康和健康研究</h3><p>健康、健身和医疗数据特别敏感，涵盖这些领域的 app 必须满足额外的规则，并确保客户隐私受到保护：</p>
<p>(i) App 仅能在获得批准的情况下，出于改进健康管理或健康研究的目的，使用在健康、健身和医疗研究背景下收集的数据 (包括从临床健康记录 API、HealthKit API、“运动与健身”或健康领域人体研究中收集的数据) 或将它披露给第三方，不得用于广告投放、市场营销或基于使用情况进行其他数据挖掘。<br>(ii) App 不得将虚假或错误数据写入 HealthKit 或其他任何医疗研究/健康管理 App，不得在 iCloud 中存储个人健康信息。<br>(iii) 开展健康领域人体研究的 app 必须获得参与人员提供的知情同意书，如果涉及未成年人，则必须获得由其家长或监护人提供的知情同意书。上述知情同意书必须涵盖以下内容：(a) 研究的性质、目的和时长；(b) 具体规程，给参与人员带来的风险和益处；(c) 关于保密和数据处理 (包括与第三方共享信息的情况) 的信息；(d) 用于回答参与人员问题的联系人；以及 (e) 退出流程。<br>(iv) 用于开展健康领域人体研究的 app 必须获得一家独立伦理审查委员会的批准。一经要求，必须提供此类批准的证明。</p>
<h3 id="5-1-4-儿童"><a href="#5-1-4-儿童" class="headerlink" title="5.1.4 儿童"></a>5.1.4 儿童</h3><p>出于诸多原因，您在处理儿童的个人数据时必须小心谨慎。我们建议您仔细阅读所有要求，以遵循相关法律，如《儿童在线隐私保护法》(“COPPA”)、和欧盟《一般数据保护条例》(“GDPR”) 和其他国际上适用的同等法律。</p>
<p>App 只能出于遵守适用儿童隐私法规的目的要求用户提供出生日期或家长联系信息，但必须提供一些适用于各年龄层用户的实用功能或娱乐价值。</p>
<p>此外，“儿童类别”中的 app，以及向未成年人收集个人信息 (例如姓名、地址、电子邮件、位置、照片、视频、图画、能否聊天、其他个人数据，或是将永久标识符与以上任何信息组合使用)、传输此类信息或能够共享此类信息的 app，则必须拥有隐私政策，且必须遵守适用的儿童隐私保护法规。为了清楚起见，“儿童类别”的家长监控要求，通常并不完全等同于在这些隐私法规下征得家长的同意后收集个人数据。</p>
<h3 id="5-1-5-定位服务"><a href="#5-1-5-定位服务" class="headerlink" title="5.1.5 定位服务"></a>5.1.5 定位服务</h3><p>只有在定位服务与 app 提供的功能和服务直接相关时，才能在 app 中使用定位服务。基于位置的 API 不得用于提供紧急服务，不得对汽车、飞机和其他设备进行自主控制 (小型设备，如轻量无人机和玩具除外)，不得遥控汽车防盗系统等。在收集、传输或使用位置数据之前，务必进行通知并获得用户同意。如果 app 会使用定位服务，请务必在 app 中说明相应的原因；请参考“Human Interface Guidelines (英文)”，了解相应的最佳做法。</p>
<h2 id="5-2-知识产权￼"><a href="#5-2-知识产权￼" class="headerlink" title="5.2 知识产权￼"></a>5.2 知识产权￼</h2><p>请确保 app 只包含由您创建或拥有使用许可的内容。如果您已越线并在未经许可的情况下使用了内容，您的 app 可能会被移除。当然，这也意味着如果他人抄袭了您的作品，则他们的 app 也可能会被移除。如果您认为自己的知识产权在 App Store 上受到了其他开发者的侵犯，请通过此网页表格提交权利主张。各个国家/地区的法律互不相同，但请务必避免以下常见错误：</p>
<h3 id="5-2-1-一般性：不得在未经授权的情况下，在-app-中使用受保护的第三方材料-例如商标、版权作品、专利设计-；也不得在-app-套装或开发者名称中包含虚假、抄袭或误导性的演示、名称或元数据。App-提交方应当是拥有或获授权使用知识产权和其他相关权利的个人或法律实体，并且应对提供-app-中的任何服务负责。"><a href="#5-2-1-一般性：不得在未经授权的情况下，在-app-中使用受保护的第三方材料-例如商标、版权作品、专利设计-；也不得在-app-套装或开发者名称中包含虚假、抄袭或误导性的演示、名称或元数据。App-提交方应当是拥有或获授权使用知识产权和其他相关权利的个人或法律实体，并且应对提供-app-中的任何服务负责。" class="headerlink" title="5.2.1 一般性：不得在未经授权的情况下，在 app 中使用受保护的第三方材料 (例如商标、版权作品、专利设计)；也不得在 app 套装或开发者名称中包含虚假、抄袭或误导性的演示、名称或元数据。App 提交方应当是拥有或获授权使用知识产权和其他相关权利的个人或法律实体，并且应对提供 app 中的任何服务负责。"></a>5.2.1 一般性：不得在未经授权的情况下，在 app 中使用受保护的第三方材料 (例如商标、版权作品、专利设计)；也不得在 app 套装或开发者名称中包含虚假、抄袭或误导性的演示、名称或元数据。App 提交方应当是拥有或获授权使用知识产权和其他相关权利的个人或法律实体，并且应对提供 app 中的任何服务负责。</h3><h3 id="5-2-2-第三方站点-服务：如果您的-app-会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。"><a href="#5-2-2-第三方站点-服务：如果您的-app-会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。" class="headerlink" title="5.2.2 第三方站点/服务：如果您的 app 会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。"></a>5.2.2 第三方站点/服务：如果您的 app 会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。</h3><h3 id="5-2-3-音频-视频下载：app-不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源-如-Apple-Music、YouTube、SoundCloud、Vimeo-保存、转换或下载媒体资源的能力。视频-音频内容流也有可能触犯使用条款，所以请务必在-app-访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。"><a href="#5-2-3-音频-视频下载：app-不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源-如-Apple-Music、YouTube、SoundCloud、Vimeo-保存、转换或下载媒体资源的能力。视频-音频内容流也有可能触犯使用条款，所以请务必在-app-访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。" class="headerlink" title="5.2.3 音频/视频下载：app 不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源 (如 Apple Music、YouTube、SoundCloud、Vimeo) 保存、转换或下载媒体资源的能力。视频/音频内容流也有可能触犯使用条款，所以请务必在 app 访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。"></a>5.2.3 音频/视频下载：app 不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源 (如 Apple Music、YouTube、SoundCloud、Vimeo) 保存、转换或下载媒体资源的能力。视频/音频内容流也有可能触犯使用条款，所以请务必在 app 访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。</h3><h3 id="5-2-4-Apple-认可：不得误导或暗示-Apple-是-app-的来源或提供商，或者-Apple-以任何形式表示认可其质量或功能。如果您的-app-被选为“编辑选荐”，Apple-将自动显示相应徽章。"><a href="#5-2-4-Apple-认可：不得误导或暗示-Apple-是-app-的来源或提供商，或者-Apple-以任何形式表示认可其质量或功能。如果您的-app-被选为“编辑选荐”，Apple-将自动显示相应徽章。" class="headerlink" title="5.2.4 Apple 认可：不得误导或暗示 Apple 是 app 的来源或提供商，或者 Apple 以任何形式表示认可其质量或功能。如果您的 app 被选为“编辑选荐”，Apple 将自动显示相应徽章。"></a>5.2.4 Apple 认可：不得误导或暗示 Apple 是 app 的来源或提供商，或者 Apple 以任何形式表示认可其质量或功能。如果您的 app 被选为“编辑选荐”，Apple 将自动显示相应徽章。</h3><h3 id="5-2-5-Apple-产品：不得创建与现有-Apple-产品、界面-如-Finder-、app-如-App-Store、iTunes-Store-或“信息”-或广告主题外观相似或容易混淆的-app。App-和扩展-包括第三方键盘和贴纸包-不得含有-Apple-表情符号。iTunes-音乐预览内容不得用于其娱乐价值-如用作照片拼贴画的背景音乐或游戏配音-或其他未获授权的方式。如果-app-显示健身记录圆环，则不应以类似于“健身记录”控件的方式展示“活动”，“锻炼”或“站立”数据。请参考“Human-Interface-Guidelines-英文-”以了解关于如何使用健身记录圆环的更多信息。"><a href="#5-2-5-Apple-产品：不得创建与现有-Apple-产品、界面-如-Finder-、app-如-App-Store、iTunes-Store-或“信息”-或广告主题外观相似或容易混淆的-app。App-和扩展-包括第三方键盘和贴纸包-不得含有-Apple-表情符号。iTunes-音乐预览内容不得用于其娱乐价值-如用作照片拼贴画的背景音乐或游戏配音-或其他未获授权的方式。如果-app-显示健身记录圆环，则不应以类似于“健身记录”控件的方式展示“活动”，“锻炼”或“站立”数据。请参考“Human-Interface-Guidelines-英文-”以了解关于如何使用健身记录圆环的更多信息。" class="headerlink" title="5.2.5 Apple 产品：不得创建与现有 Apple 产品、界面 (如 Finder)、app (如 App Store、iTunes Store 或“信息”) 或广告主题外观相似或容易混淆的 app。App 和扩展 (包括第三方键盘和贴纸包) 不得含有 Apple 表情符号。iTunes 音乐预览内容不得用于其娱乐价值 (如用作照片拼贴画的背景音乐或游戏配音) 或其他未获授权的方式。如果 app 显示健身记录圆环，则不应以类似于“健身记录”控件的方式展示“活动”，“锻炼”或“站立”数据。请参考“Human Interface Guidelines (英文)”以了解关于如何使用健身记录圆环的更多信息。"></a>5.2.5 Apple 产品：不得创建与现有 Apple 产品、界面 (如 Finder)、app (如 App Store、iTunes Store 或“信息”) 或广告主题外观相似或容易混淆的 app。App 和扩展 (包括第三方键盘和贴纸包) 不得含有 Apple 表情符号。iTunes 音乐预览内容不得用于其娱乐价值 (如用作照片拼贴画的背景音乐或游戏配音) 或其他未获授权的方式。如果 app 显示健身记录圆环，则不应以类似于“健身记录”控件的方式展示“活动”，“锻炼”或“站立”数据。请参考“Human Interface Guidelines (英文)”以了解关于如何使用健身记录圆环的更多信息。</h3><h2 id="5-3-游戏、赌博和彩票"><a href="#5-3-游戏、赌博和彩票" class="headerlink" title="5.3 游戏、赌博和彩票"></a>5.3 游戏、赌博和彩票</h2><p>赌博、游戏和彩票的管理难度大，是 App Store 上受到最多管制的 app 类别之一。只有全面核实了即将发布您的 app 的所有国家/地区的相关法律要求后，才能包含此功能，并且要做好准备此功能的审核流程需要更长的时间。您需要谨记以下事项：</p>
<h3 id="5-3-1-抽奖和比赛必须由-app-的开发者赞助。"><a href="#5-3-1-抽奖和比赛必须由-app-的开发者赞助。" class="headerlink" title="5.3.1 抽奖和比赛必须由 app 的开发者赞助。"></a>5.3.1 抽奖和比赛必须由 app 的开发者赞助。</h3><h3 id="5-3-2-抽奖、比赛和抽彩的正式规则必须在-app-中注明，并且必须明确表示-Apple-不是赞助者，也没有以任何形式参与活动。"><a href="#5-3-2-抽奖、比赛和抽彩的正式规则必须在-app-中注明，并且必须明确表示-Apple-不是赞助者，也没有以任何形式参与活动。" class="headerlink" title="5.3.2 抽奖、比赛和抽彩的正式规则必须在 app 中注明，并且必须明确表示 Apple 不是赞助者，也没有以任何形式参与活动。"></a>5.3.2 抽奖、比赛和抽彩的正式规则必须在 app 中注明，并且必须明确表示 Apple 不是赞助者，也没有以任何形式参与活动。</h3><h3 id="5-3-3-App-不得通过-App-内购买项目购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在-app-内进行资金转账。"><a href="#5-3-3-App-不得通过-App-内购买项目购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在-app-内进行资金转账。" class="headerlink" title="5.3.3 App 不得通过 App 内购买项目购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在 app 内进行资金转账。"></a>5.3.3 App 不得通过 App 内购买项目购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在 app 内进行资金转账。</h3><h3 id="5-3-4-提供真实货币游戏-例如体育下注、扑克、赌场游戏、赛马-或彩票的-app-必须在使用该-app-的地区获得必要的许可和批准，且只能在这些地区发布，此类-app-在-App-Store-中必须免费提供。App-Store-上不允许发布非法的赌博辅助工具，包括记牌器。彩票-app-必须有报酬、几率及奖品。"><a href="#5-3-4-提供真实货币游戏-例如体育下注、扑克、赌场游戏、赛马-或彩票的-app-必须在使用该-app-的地区获得必要的许可和批准，且只能在这些地区发布，此类-app-在-App-Store-中必须免费提供。App-Store-上不允许发布非法的赌博辅助工具，包括记牌器。彩票-app-必须有报酬、几率及奖品。" class="headerlink" title="5.3.4 提供真实货币游戏 (例如体育下注、扑克、赌场游戏、赛马) 或彩票的 app 必须在使用该 app 的地区获得必要的许可和批准，且只能在这些地区发布，此类 app 在 App Store 中必须免费提供。App Store 上不允许发布非法的赌博辅助工具，包括记牌器。彩票 app 必须有报酬、几率及奖品。"></a>5.3.4 提供真实货币游戏 (例如体育下注、扑克、赌场游戏、赛马) 或彩票的 app 必须在使用该 app 的地区获得必要的许可和批准，且只能在这些地区发布，此类 app 在 App Store 中必须免费提供。App Store 上不允许发布非法的赌博辅助工具，包括记牌器。彩票 app 必须有报酬、几率及奖品。</h3><h2 id="5-4-VPN-App"><a href="#5-4-VPN-App" class="headerlink" title="5.4 VPN App"></a>5.4 VPN App</h2><p>提供 VPN 服务的 app 必须利用 NEVPNManager API (英文)，并且仅可由登记为企业的开发者提供。您必须清楚地声明会收集哪些用户数据，以及将如何使用这些数据。VPN app 不得违反当地法律，如果您选择在需要 VPN 许可证的地区发布，则必须在 App Review 注释栏位中提供您的许可证信息。</p>
<h2 id="5-5-开发者行为准则"><a href="#5-5-开发者行为准则" class="headerlink" title="5.5 开发者行为准则"></a>5.5 开发者行为准则</h2><p>请尊重每一个人，无论是在 App Store 中回复用户评论、回应客户支持请求时，还是与 Apple 沟通时 (包括您在解决方案中心的回复)，都应做到这一点。请勿涉及任何形式的骚扰、歧视、恐吓或霸凌行为，也不要鼓励他人实施任何上述行为。</p>
<p>客户的信任是 App Store 获得成功的基石。App 不得存在以下行为：掠夺用户或试图勒索用户；诱导用户进行非自愿的购买；强迫用户共享不必要的数据；以欺骗的方式抬高价格；针对未交付的功能或内容收取费用；或者在 app 内部或外部实施任何其他操纵行为。</p>
<p>最后更新日期：2018 年 6 月 4 日</p>
<p>提交之后<br>在 App Store Connect 中提交 app 和元数据之后，您随即就会进入审核流程。请谨记以下几点：</p>
<p>时间：App Review 团队会尽快检查您的 app。不过，如果 app 比较复杂或者存在新的问题，则可能需要更深入的审查和考量。也请记住，如果 app 因为违反同一准则而一再被拒绝，或者您曾经试图操纵 App Review 流程，您的 app 将需要更长时间才能完成审核。进一步了解 App Review。<br>状态更新：App 的当前状态会反映在 App Store Connect 中，所以请多留意此处。<br>加急请求：如果您遇到了严重的时间问题，可以申请加急审核 (英文)。请仅在您真的需要加快审核时才提出申请，以便其他开发者的加急请求不受影响。如果我们发现您滥用此系统，从此以后我们可能都会拒绝您的申请。<br>发布日期：如果您设定在未来某个日期发布 app，在此日期到来之前，即使这个 app 已获得 App Review 团队的批准，也不会显示在 App Store 上。请注意，您的 app 可能需要长达 24 小时才能显示在所有选定的商店中。<br>拒绝：我们的目标是公平、持续地遵循这些准则，但是人无完人。如果您的 app 被拒绝，但您存在疑问，或希望提供其他信息，请使用解决方案中心，以与 App Review 团队直接沟通。这样可以帮助您的 app 出现在商店中，也可帮助我们改进 App Review 流程，并在我们的政策中发现需要阐明的部分。如果您仍对结果不满意，请提交申诉 (英文)。<br>我们期待看到您开发出更多优秀作品！</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS审核</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-WKWebView与JS交互</title>
    <url>/iOS-WKWebView%E4%B8%8EJS%E4%BA%A4%E4%BA%92.html</url>
    <content><![CDATA[<h3 id="一、WK协议"><a href="#一、WK协议" class="headerlink" title="一、WK协议"></a>一、WK协议</h3><h4 id="1-1-WKScriptMessageHandler协议"><a href="#1-1-WKScriptMessageHandler协议" class="headerlink" title="1.1 WKScriptMessageHandler协议"></a>1.1 WKScriptMessageHandler协议</h4><p>WKScriptMessageHandler其实就是一个遵循的协议，它能让网页通过JS把消息发送给OC。其中协议方法。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*! @abstract Invoked when a script message is received from a webpage.</span></span><br><span class="line"><span class="comment"> @param userContentController The user content controller invoking the</span></span><br><span class="line"><span class="comment"> delegate method.</span></span><br><span class="line"><span class="comment"> @param message The script message received.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">userContentController</span><span class="selector-pseudo">:(WKUserContentController</span> *)<span class="selector-tag">userContentController</span> <span class="selector-tag">didReceiveScriptMessage</span><span class="selector-pseudo">:(WKScriptMessage</span> *)<span class="selector-tag">message</span>;</span><br></pre></td></tr></table></figure>
<p>从协议中我们可以看出这里使用了两个类WKUserContentController和WKScriptMessage。WKUserContentController可以理解为调度器，WKScriptMessage则是携带的数据。</p>
<h4 id="1-2-WKUserContentController"><a href="#1-2-WKUserContentController" class="headerlink" title="1.2 WKUserContentController"></a>1.2 WKUserContentController</h4><p>WKUserContentController有两个核心方法，也是它的核心功能。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addUserScript:(<span class="built_in">WKUserScript</span> *)userScript;: js注入，即向网页中注入我们的js方法，这是一个非常强大的功能，开发中要慎用。</span><br><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;：添加供js调用oc的桥梁。这里的name对应<span class="built_in">WKScriptMessage</span>中的name，多数情况下我们认为它就是方法名。</span><br></pre></td></tr></table></figure>
<h4 id="1-3-WKScriptMessage"><a href="#1-3-WKScriptMessage" class="headerlink" title="1.3 WKScriptMessage"></a>1.3 WKScriptMessage</h4><p>WKScriptMessage就是js通知oc的数据。其中有两个核心属性用的很多。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; ：对应- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;添加的name。</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> body;：携带的核心数据。</span><br></pre></td></tr></table></figure>
<p>js调用时只需</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.webkit</span><span class="selector-class">.messageHandlers</span>.&lt;<span class="selector-tag">name</span>&gt;<span class="selector-class">.postMessage</span>(&lt;<span class="selector-tag">messageBody</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>这里的name就是我们添加的name。</p>
<h3 id="二、JS调OC代码"><a href="#二、JS调OC代码" class="headerlink" title="二、JS调OC代码"></a>二、JS调OC代码</h3><p>JS代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color: white;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">jsCallNative</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="built_in">window</span>.webkit.messageHandlers.callNativeAndSend.postMessage(<span class="string">'callcallcall'</span>);</span></span><br><span class="line">           alert(callNative);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"jsCallNative()"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：window.webkit.messageHandlers.callNativeAndSend.postMessage(‘callcallcall’);这行代码才是调用oc的方法，方法名：callNativeAndSend 参数就是：callcallcall</p>
<p>OC代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKUserContentController</span> *userContentController = [[<span class="built_in">WKUserContentController</span> alloc] init];</span><br><span class="line">       [userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"callNativeAndSend"</span>];</span><br><span class="line">       [userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"NativeObject.shareString"</span>];</span><br><span class="line">       <span class="comment">// WKWebView的配置</span></span><br><span class="line">       <span class="built_in">WKWebViewConfiguration</span> *configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">       configuration.userContentController   = userContentController;</span><br><span class="line">       <span class="comment">//创建WKWebView</span></span><br><span class="line">       </span><br><span class="line">       _webView = [[<span class="built_in">WKWebView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, ScreenWidth, ScreenHeight) configuration:configuration];</span><br></pre></td></tr></table></figure>
<p>上面代码，是创建webView，并且告诉JS有哪些方法。</p>
<p>Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.<br>译：添加名称名称的脚本消息处理程序会导致在所有使用用户内容控制器的Web视图的所有框架中定义JavaScript函数window.webkit.messageHandlers.name.postMessage（messageBody）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure>
<p>但是 [userContentController addScriptMessageHandler:self name:@”NativeObject.shareString”];亲测是无效的，其只能像[userContentController addScriptMessageHandler:self name:@”callNativeAndSend”];添加这种。</p>
<p>当JS调用OC方法后，会执行以下回调，name是方法名，可以用其作区分判断，body是参数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"\n body:%@ \n name:%@"</span>,<span class="params">message</span>.<span class="params">body</span>,<span class="params">message</span>.<span class="params">name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一种注入JS的方式：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addUserScript:<span class="params">(WKUserScript *)</span>userScript;: js注入，即向网页中注入我们的js方法，这是一个非常强大的功能，开发中要慎用。</span><br></pre></td></tr></table></figure>
<p><strong>注意：在UIWebview中，当我们第一次给h5注入js方法后，在后续的页面操作过程中可能会丢失这个方法，也就是js不再能拿到这个方法。可能原因是：在h5页面操作过程中，创建了两个window，而我们加的js方法仍在第一个window上，在新的window上就拿不到了。在WKWebview中，丢失方法是因为js调用方法调早了，而我们还没有注入；js延迟调用问题不存在了。</strong> <strong>在WKWebview中用上述方式注入代码后会避免此问题出现*！！！</strong></p>
<h3 id="三、OC调JS代码"><a href="#三、OC调JS代码" class="headerlink" title="三、OC调JS代码"></a>三、OC调JS代码</h3><figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">[webView evaluateJavaScript:@<span class="string">"globalObject.nativeCallJS('abc')"</span> completionHandler:^(<span class="name"><span class="builtin-name">id</span></span> _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">        if (<span class="name">error</span>) &#123;</span><br><span class="line">            NSLog(@<span class="string">"error:%@"</span>,error)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>abc是传递给JS的参数，globalObject是JS中全局属性，nativeCallJS是其下的方法。</p>
<h3 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h3><p>[userContentController addScriptMessageHandler:self name:@”callNativeAndSend”]<br>当我们添加注入方法时，以上代码会强引用self，即当前控制器，会导致再dealloc的时候self不会释放，解决办法是创建一个新类，并实现WKScriptMessageHandler代理方法。代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">WeakScriptMessageDelegate.h</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakScriptMessageDelegate</span> : <span class="title">NSObject</span>&lt;<span class="title">WKScriptMessageHandler</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt; scriptDelegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">WeakScriptMessageDelegate.m</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WeakScriptMessageDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakScriptMessageDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _scriptDelegate = scriptDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>尽管如此，在self里还是要在dealloc的时候移除方法：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[[<span class="name">_wkWebView</span> configuration].userContentController removeScriptMessageHandlerForName:@<span class="string">"jsCallNative"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>执行上述代码之后，self和WeakScriptMessageDelegate都能安全释放。</p>
<p>推荐一个强大的苹果官方库，JavaScriptCore 以及 <a href="https://www.ericlife.top/2017/11/14/iOS-JavaScriptCore%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">iOS JavaScriptCore使用</a>。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
        <tag>js</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-JavaScriptCore使用</title>
    <url>/iOS-JavaScriptCore%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>JavaScriptCore是apple推出的为了解决ios与js交互的框架，功能强大而实用。</p>
<h2 id="一、JavaScriptCore中主要的类"><a href="#一、JavaScriptCore中主要的类" class="headerlink" title="一、JavaScriptCore中主要的类"></a>一、JavaScriptCore中主要的类</h2><h3 id="1-1、JSContext-—-在OC中创建JavaScript运行的上下文环境"><a href="#1-1、JSContext-—-在OC中创建JavaScript运行的上下文环境" class="headerlink" title="1.1、JSContext — 在OC中创建JavaScript运行的上下文环境"></a>1.1、JSContext — 在OC中创建JavaScript运行的上下文环境</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">init</span>; <span class="comment">// 创建JSContext对象，获得JavaScript运行的上下文环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的对象空间上创建JSContext对象，获得JavaScript运行的上下文环境</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithVirtualMachine</span><span class="selector-pseudo">:(JSVirtualMachine</span> *)<span class="selector-tag">virtualMachine</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段js代码，输出结果为JSValue类型</span></span><br><span class="line"><span class="selector-tag">-</span> (JSValue *)<span class="selector-tag">evaluateScript</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">script</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 8.0以后可以调用此方法</span></span><br><span class="line"><span class="selector-tag">-</span> (JSValue *)<span class="selector-tag">evaluateScript</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">script</span> <span class="selector-tag">withSourceURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">sourceURL</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前正在运行的JavaScript上下文环境</span></span><br><span class="line">+ (JSContext *)<span class="selector-tag">currentContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果当前执行的js函数 function () &#123; [native code] &#125; ，iOS 8.0以后可以调用此方法</span></span><br><span class="line"> + (JSValue *)<span class="selector-tag">currentCallee</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回结果当前方法的调用者[object Window]</span></span><br><span class="line"> + (JSValue *)<span class="selector-tag">currentThis</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回结果为当前被调用方法的参数</span></span><br><span class="line"> + (NSArray *)<span class="selector-tag">currentArguments</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// js的全局变量 [object Window]</span></span><br><span class="line"> @<span class="selector-tag">property</span> (readonly, strong) <span class="selector-tag">JSValue</span> *<span class="selector-tag">globalObject</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-2、JSValue-—-JavaScript中的变量和方法，可以转成OC数据类型-每个JSValue都和JSContext相关联并且强引用context"><a href="#1-2、JSValue-—-JavaScript中的变量和方法，可以转成OC数据类型-每个JSValue都和JSContext相关联并且强引用context" class="headerlink" title="1.2、JSValue — JavaScript中的变量和方法，可以转成OC数据类型,每个JSValue都和JSContext相关联并且强引用context"></a>1.2、JSValue — JavaScript中的变量和方法，可以转成OC数据类型,每个JSValue都和JSContext相关联并且强引用context</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">   oc与js类型对照：</span><br><span class="line">      @textblock</span><br><span class="line">     Objective-C <span class="keyword">type</span>  |   JavaScript <span class="keyword">type</span></span><br><span class="line">   <span class="comment">--------------------+---------------------</span></span><br><span class="line">           nil         |     undefined</span><br><span class="line">          NSNull       |        <span class="keyword">null</span></span><br><span class="line">         NSString      |       string</span><br><span class="line">         NSNumber      |   number, <span class="type">boolean</span></span><br><span class="line">       NSDictionary    |   <span class="keyword">Object</span> <span class="keyword">object</span></span><br><span class="line">         NSArray       |    <span class="keyword">Array</span> <span class="keyword">object</span></span><br><span class="line">          NSDate       |     <span class="type">Date</span> <span class="keyword">object</span></span><br><span class="line">         NSBlock (<span class="number">1</span>)   |   <span class="keyword">Function</span> <span class="keyword">object</span> (<span class="number">1</span>)</span><br><span class="line">            id (<span class="number">2</span>)     |   <span class="keyword">Wrapper</span> <span class="keyword">object</span> (<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">Class</span> (<span class="number">3</span>)    | Constructor <span class="keyword">object</span> (<span class="number">3</span>)</span><br><span class="line">      @/textblock</span><br><span class="line"></span><br><span class="line">  //此方法会转换self为JS对象，但是self中必须实现指定的方法和协议</span><br><span class="line">  + (JSValue *)valueWithObject:(id)<span class="keyword">value</span> inContext:(JSContext *)context;</span><br><span class="line"></span><br><span class="line">  // 在context创建<span class="type">BOOL</span>的JS变量</span><br><span class="line">  + (JSValue *)valueWithBool:(<span class="type">BOOL</span>)<span class="keyword">value</span> inContext:(JSContext *)context;</span><br><span class="line"></span><br><span class="line">  // 将JS变量转换成OC中的<span class="type">BOOL</span>类型</span><br><span class="line">  - (<span class="type">BOOL</span>)toBool;</span><br><span class="line"></span><br><span class="line">  // 修改JS对象的属性的值</span><br><span class="line">  - (<span class="type">void</span>)setValue:(id)<span class="keyword">value</span> forProperty:(NSString *)property;</span><br><span class="line"></span><br><span class="line">  // JS中是否有这个对象</span><br><span class="line">  @property (readonly) <span class="type">BOOL</span> isUndefined;</span><br><span class="line"></span><br><span class="line">  // 比较两个JS对象是否相等</span><br><span class="line">  - (<span class="type">BOOL</span>)isEqualToObject:(id)<span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">  // 调用者JSValue为JS中的方法，arguments为参数，执行调用者JSValue，并传递参数arguments,@[@"a",@"b"@"c"]</span><br><span class="line">  - (JSValue *)callWithArguments:(NSArray *)arguments;</span><br><span class="line"></span><br><span class="line"> // 调用者JSValue为JS中的全局对象名称，<span class="keyword">method</span>为全局对象的方法名称，arguments为参数</span><br><span class="line">  - (JSValue *)invokeMethod:(NSString *)<span class="keyword">method</span> withArguments:(NSArray *)arguments;</span><br><span class="line"></span><br><span class="line"> // JS中的结构体类型转换为OC</span><br><span class="line">  + (JSValue *)valueWithPoint:(CGPoint)<span class="type">point</span> inContext:(JSContext *)context;</span><br><span class="line">JSExport <span class="comment">--- JS调用OC中的方法和属性写在继承自JSExport的协议当中，OC对象实现自定义的协议</span></span><br><span class="line"> // textFunction <span class="comment">-- JS方法</span></span><br><span class="line"> // - (<span class="type">void</span>) ocTestFunction:(NSNumber *)<span class="keyword">value</span> sec:(NSNumber *)number <span class="comment">-- OC方法</span></span><br><span class="line"> JSExportAs (textFunction,- (<span class="type">void</span>) ocTestFunction:(NSNumber *)<span class="keyword">value</span> sec:(NSNumber *)number);</span><br><span class="line">JSManagedValue <span class="comment">--- JS和OC对象的内存管理辅助对象,主要用来保存JSValue对象,解决OC对象中存储js的值，导致的循环引用问题</span></span><br><span class="line"></span><br><span class="line"> JSManagedValue *_jsManagedValue = [JSManagedValue managedValueWithValue:jsValue];</span><br><span class="line">[_context.virtualMachine addManagedReference:_jsManagedValue];</span><br><span class="line">JSManagedValue本身只弱引用js值，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine中，这样如果JavaScript能够找到该JSValue的Objective-C <span class="keyword">owner</span>，该JSValue的引用就不会被释放。</span><br><span class="line">JSVirtualMachine <span class="comment">--- JS运行的虚拟机，有独立的堆空间和垃圾回收机制，运行在不同虚拟机环境的JSContext可以通过此类通信。</span></span><br></pre></td></tr></table></figure>
<p>下面记录一下使用方法：</p>
<h2 id="二、简单的情况，JS中点击事件直接调用方法方式"><a href="#二、简单的情况，JS中点击事件直接调用方法方式" class="headerlink" title="二、简单的情况，JS中点击事件直接调用方法方式"></a>二、简单的情况，JS中点击事件直接调用方法方式</h2><h3 id="2-1-JS代码如下："><a href="#2-1-JS代码如下：" class="headerlink" title="2.1 JS代码如下："></a>2.1 JS代码如下：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color: white;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nativeCallJS = <span class="function"><span class="keyword">function</span><span class="params">(parameter)</span> </span>&#123;</span></span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"jsCallNative('jsParameter')"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-oc代码如下："><a href="#2-2-oc代码如下：" class="headerlink" title="2.2 oc代码如下："></a>2.2 oc代码如下：</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.jsContext = [_webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="keyword">self</span>.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"出现异常，异常信息：%@"</span>,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//oc调用js</span></span><br><span class="line">    JSValue * nativeCallJS = <span class="keyword">self</span>.jsContext[<span class="string">@"nativeCallJS"</span>];</span><br><span class="line">    [nativeCallJS callWithArguments:@[<span class="string">@"hello word"</span>]];<span class="comment">//调用了js中方法"nativeCallJS",并且传参数@"hello word"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在本地生成js方法，供js调用</span></span><br><span class="line">    <span class="keyword">self</span>.jsContext[<span class="string">@"jsCallNative"</span>] = ^(<span class="built_in">NSString</span> *paramer)&#123;</span><br><span class="line">        JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">        JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">        <span class="built_in">NSArray</span> *currentParamers = [JSContext currentArguments];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"js传过来：%@"</span>,paramer);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"JS paramer is %@"</span>,paramer);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentThis is %@"</span>,[currentThis toString]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentCallee is %@"</span>,[currentCallee toString]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentParamers is %@"</span>,currentParamers);</span><br><span class="line">    &#125;;<span class="comment">//生成native的js方法，方法名：@"jsCallNative",js可直接调用此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">13</span><span class="string">:30:37.715810+0800</span> <span class="string">WebView+image[2940:337555]</span> <span class="string">js传过来：jsParameter</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">13</span><span class="string">:30:37.715759+0800</span> <span class="string">WebView+image[2940:337892]</span> <span class="string">JS</span> <span class="string">paramer</span> <span class="string">is</span> <span class="string">jsParameter</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">13</span><span class="string">:30:37.716007+0800</span> <span class="string">WebView+image[2940:337892]</span> <span class="string">currentThis</span> <span class="string">is</span> <span class="string">[object</span> <span class="string">Window]</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">13</span><span class="string">:30:37.716337+0800</span> <span class="string">WebView+image[2940:337892]</span> <span class="string">currentCallee</span> <span class="string">is</span> <span class="string">function</span> <span class="string">()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">[native</span> <span class="string">code]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">13</span><span class="string">:30:37.716743+0800</span> <span class="string">WebView+image[2940:337892]</span> <span class="string">currentParamers</span> <span class="string">is</span> <span class="string">(</span></span><br><span class="line">    <span class="string">jsParameter</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
<p>以上就是简单的调用。</p>
<h2 id="三、复杂调用，JS中，点击事件等事件通过调用全局对象的方法调用方法，JS和Native代码的互调如下："><a href="#三、复杂调用，JS中，点击事件等事件通过调用全局对象的方法调用方法，JS和Native代码的互调如下：" class="headerlink" title="三、复杂调用，JS中，点击事件等事件通过调用全局对象的方法调用方法，JS和Native代码的互调如下："></a>三、复杂调用，JS中，点击事件等事件通过调用全局对象的方法调用方法，JS和Native代码的互调如下：</h2><h3 id="3-1-JS代码如下："><a href="#3-1-JS代码如下：" class="headerlink" title="3.1 JS代码如下："></a>3.1 JS代码如下：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color: white;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        globalObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></span><br><span class="line">        globalObject.name = 100;</span><br><span class="line"><span class="actionscript">        globalObject.nativeCallJS = <span class="function"><span class="keyword">function</span> <span class="params">(parameter)</span> </span>&#123;</span></span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"NativeObject.jsCallNative()"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"NativeObject.shareString('jsParameter')"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码并传参数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-oc代码如下："><a href="#3-2-oc代码如下：" class="headerlink" title="3.2 oc代码如下："></a>3.2 oc代码如下：</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明的协议，当前viewController必须遵守</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JSObjcDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)jsCallNative;</span><br><span class="line">- (<span class="keyword">void</span>)shareString:(<span class="built_in">NSString</span> *)shareString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法实现，在webViewDidFinishLoad中调用</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.jsContext = [_webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="keyword">self</span>.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"出现异常，异常信息：%@"</span>,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//oc调用js</span></span><br><span class="line">    JSValue * jsObj = <span class="keyword">self</span>.jsContext[<span class="string">@"globalObject"</span>];<span class="comment">//拿到js中要调用方法的全局对象</span></span><br><span class="line">    <span class="comment">//jsObj执行其方法nativeCallJS</span></span><br><span class="line">    JSValue * returnValue = [jsObj invokeMethod:<span class="string">@"nativeCallJS"</span> withArguments:@[<span class="string">@"hello word"</span>]];</span><br><span class="line">   <span class="comment">//调用了js中方法"nativeCallJS",并且传参数@"hello word",这里returnValue是调用之后的返回值，可能为nil</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"returnValue:%@"</span>,returnValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写法1</span></span><br><span class="line">    JSValue * jsCallNative = [JSValue valueWithObject:<span class="keyword">self</span> inContext:<span class="keyword">self</span>.jsContext];<span class="comment">//此方法会转换self为JS对象，但是self中必须实现指定的方法和协议</span></span><br><span class="line">    <span class="keyword">self</span>.jsContext[<span class="string">@"NativeObject"</span>] = jsCallNative;</span><br><span class="line">    <span class="comment">//写法2</span></span><br><span class="line">    <span class="comment">//self.jsContext[@"NativeObject"] = self;</span></span><br><span class="line">    <span class="comment">//注：写法1和写法2效果相同，推荐写法1，毕竟系统方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)jsCallNative&#123;<span class="comment">//在本地生成js方法，供js调用</span></span><br><span class="line">    </span><br><span class="line">    JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">    JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">    <span class="built_in">NSArray</span> *currentParamers = [JSContext currentArguments];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThis is %@"</span>,[currentThis toString]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentCallee is %@"</span>,[currentCallee toString]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentParamers is %@"</span>,currentParamers);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)shareString:(<span class="built_in">NSString</span> *)shareString&#123;<span class="comment">//在本地生成js方法，供js调用</span></span><br><span class="line">    </span><br><span class="line">    JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">    JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">    <span class="built_in">NSArray</span> *currentParamers = [JSContext currentArguments];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"js传过来：%@"</span>,shareString);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JS paramer is %@"</span>,shareString);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThis is %@"</span>,[currentThis toString]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentCallee is %@"</span>,[currentCallee toString]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentParamers is %@"</span>,currentParamers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的log：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">2017-11-15</span> <span class="selector-tag">14</span><span class="selector-pseudo">:02</span><span class="selector-pseudo">:18.695352+0800</span> <span class="selector-tag">WebView</span>+<span class="selector-tag">image</span><span class="selector-attr">[3257:377010]</span> <span class="selector-tag">currentThis</span> <span class="selector-tag">is</span> <span class="selector-attr">[object SecondViewController]</span></span><br><span class="line"><span class="selector-tag">2017-11-15</span> <span class="selector-tag">14</span><span class="selector-pseudo">:02</span><span class="selector-pseudo">:18.695745+0800</span> <span class="selector-tag">WebView</span>+<span class="selector-tag">image</span><span class="selector-attr">[3257:377010]</span> <span class="selector-tag">currentCallee</span> <span class="selector-tag">is</span> <span class="selector-tag">function</span> () &#123;</span><br><span class="line">    <span class="selector-attr">[native code]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">2017-11-15</span> <span class="selector-tag">14</span><span class="selector-pseudo">:02</span><span class="selector-pseudo">:18.695936+0800</span> <span class="selector-tag">WebView</span>+<span class="selector-tag">image</span><span class="selector-attr">[3257:377010]</span> <span class="selector-tag">currentParamers</span> <span class="selector-tag">is</span> (</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">14</span><span class="string">:02:50.904847+0800</span> <span class="string">WebView+image[3257:376893]</span> <span class="string">js传过来：jsParameter</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">14</span><span class="string">:02:50.904842+0800</span> <span class="string">WebView+image[3257:377010]</span> <span class="string">JS</span> <span class="string">paramer</span> <span class="string">is</span> <span class="string">jsParameter</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">14</span><span class="string">:02:50.905124+0800</span> <span class="string">WebView+image[3257:377010]</span> <span class="string">currentThis</span> <span class="string">is</span> <span class="string">[object</span> <span class="string">SecondViewController]</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">14</span><span class="string">:02:50.905607+0800</span> <span class="string">WebView+image[3257:377010]</span> <span class="string">currentCallee</span> <span class="string">is</span> <span class="string">function</span> <span class="string">()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">[native</span> <span class="string">code]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-15</span> <span class="number">14</span><span class="string">:02:50.906052+0800</span> <span class="string">WebView+image[3257:377010]</span> <span class="string">currentParamers</span> <span class="string">is</span> <span class="string">(</span></span><br><span class="line">    <span class="string">jsParameter</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
<h2 id="四，特殊要求"><a href="#四，特殊要求" class="headerlink" title="四，特殊要求"></a>四，特殊要求</h2><h3 id="4-1-、JS中对象已经生成，需要OC生成对应的方法实现，JS去调用"><a href="#4-1-、JS中对象已经生成，需要OC生成对应的方法实现，JS去调用" class="headerlink" title="4.1 、JS中对象已经生成，需要OC生成对应的方法实现，JS去调用"></a>4.1 、JS中对象已经生成，需要OC生成对应的方法实现，JS去调用</h3><p>JS代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color: white;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        globalObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></span><br><span class="line">        globalObject.name = 100;</span><br><span class="line"><span class="actionscript">        globalObject.nativeCallJS = <span class="function"><span class="keyword">function</span> <span class="params">(parameter)</span> </span>&#123;</span></span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> callBack = <span class="function"><span class="keyword">function</span><span class="params">(parameter)</span></span>&#123;</span></span><br><span class="line">            alert(parameter);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"NativeObject.jsCallNative()"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"NativeObject.shareString('jsParameter')"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:30px;"</span>/&gt;</span>调用OC代码并传参数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span> = <span class="string">"globalObject.creatJSMethod('jsParameter')"</span> <span class="attr">style</span>=<span class="string">"width:100%;height:30px;"</span>/&gt;</span>oc生成JS方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上JS中globalObject对象已经存在，但是在没有实现creatJSMethod方法，在按钮”oc生成JS方法”却调用了此方法。<br><strong>OC代码：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.jsContext = [_webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="keyword">self</span>.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"出现异常，异常信息：%@"</span>,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//oc调用js</span></span><br><span class="line">    JSValue * jsObj = <span class="keyword">self</span>.jsContext[<span class="string">@"globalObject"</span>];<span class="comment">//拿到JS中已经存在的对象</span></span><br><span class="line">    <span class="comment">//为jsObj对应的方法提供方法实现</span></span><br><span class="line">    jsObj[<span class="string">@"creatJSMethod"</span>] = ^(<span class="built_in">NSString</span> * parameter)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"方法生成成功：%@"</span>,parameter);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>log：</strong><br>2017-11-15 14:47:08.126160+0800 WebView+image[3661:435044] 方法生成成功：jsParameter</p>
<h3 id="4-2、oc重写js本地的方法，与生成一样，上面的代码："><a href="#4-2、oc重写js本地的方法，与生成一样，上面的代码：" class="headerlink" title="4.2、oc重写js本地的方法，与生成一样，上面的代码："></a>4.2、oc重写js本地的方法，与生成一样，上面的代码：</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">jsObj[@<span class="string">"creatJSMethod"</span>] = ^(NSString * <span class="keyword">parameter</span>)&#123;</span><br><span class="line">   NSLog(@<span class="string">"方法生成成功：%@"</span>,<span class="keyword">parameter</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>既能生成，也能重写。</p>
<p>这些基本就是全部的情况了，当然还有一些线程问题等，等有需要再总结。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>oc与js交互，先看js是调oc还是oc调用js，再看js中方法是全局方法还是全局属性方法（可能说的不是很准确）。清楚了这些就好实现了！！！</p>
<p><a href="https://www.ericlife.top/2017/11/15/iOS-WKWebView%E4%B8%8EJS%E4%BA%A4%E4%BA%92/" target="_blank" rel="noopener">iOS WKWebView与JS交互</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>C指针详解(经典,非常详细)</title>
    <url>/C%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3-%E7%BB%8F%E5%85%B8-%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86.html</url>
    <content><![CDATA[<h2 id="前言-复杂类型说明"><a href="#前言-复杂类型说明" class="headerlink" title="前言:复杂类型说明"></a>前言:复杂类型说明</h2><p>要了解指针,多多少少会出现一些比较复杂的类型,所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单,一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,所以我总结了一下其原则:从变量名处起,根据运算符优先级结合,一步一步分析.下面让我们先从简单的类型开始慢慢分析吧:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="built_in">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="number">2.</span>  <span class="built_in">int</span> *p;  <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="number">3.</span>  <span class="built_in">int</span> p[<span class="number">3</span>];  <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="number">4.</span>  <span class="built_in">int</span> *p[<span class="number">3</span>];   <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="number">5.</span>  <span class="built_in">int</span> b(*p)[<span class="number">3</span>];  <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="number">6.</span>  <span class="built_in">int</span> **p;  <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="number">7.</span>  <span class="built_in">int</span> p(<span class="built_in">int</span>);  <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line"><span class="number">8.</span>  Int (*p)(<span class="built_in">int</span>);  <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="number">9.</span>  <span class="built_in">int</span> *(*p(<span class="built_in">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>
<p>说到这里也就差不多了,我们的任务也就这么多,理解了这几个类型,其它的类型对我们来说也是小菜了,不过我们一般不会用太复杂的类型,那样会大大减小程序的可读性,请慎用,这上面的几种类型已经足够我们用了.</p>
<h3 id="一、细说指针"><a href="#一、细说指针" class="headerlink" title="一、细说指针"></a>一、细说指针</h3><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。</p>
<p>先声明几个指针放着做例子：<br>例一：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="built_in">int</span>*ptr;  </span><br><span class="line">(<span class="number">2</span>)char*ptr;  </span><br><span class="line">(<span class="number">3</span>)<span class="built_in">int</span>**ptr;  </span><br><span class="line">(<span class="number">4</span>)<span class="built_in">int</span>(*ptr)[<span class="number">3</span>];  </span><br><span class="line">(<span class="number">5</span>)<span class="built_in">int</span>*(*ptr)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h4 id="1-指针的类型"><a href="#1-指针的类型" class="headerlink" title="1.指针的类型"></a>1.指针的类型</h4><p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)int*ptr;<span class="comment">//指针的类型是int*</span></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)char*ptr;<span class="comment">//指针的类型是char*</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)int**ptr;<span class="comment">//指针的类型是int**</span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)int<span class="comment">(*ptr)[3];//指针的类型是int(*)</span>[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)int*<span class="comment">(*ptr)[4];//指针的类型是int*(*)</span>[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>怎么样？找出指针的类型的方法是不是很简单？</p>
<h4 id="2-指针所指向的类型"><a href="#2-指针所指向的类型" class="headerlink" title="2.指针所指向的类型"></a>2.指针所指向的类型</h4><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>
<p>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="built_in">int</span> *ptr; <span class="comment">//指针所指向的类型是int</span></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)char *ptr; <span class="comment">//指针所指向的的类型是char</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)<span class="built_in">int</span> **ptr; <span class="comment">//指针所指向的的类型是int*</span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="built_in">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是int()[3]</span></span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)<span class="built_in">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是int*()[4]</span></span><br></pre></td></tr></table></figure>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。</p>
<h4 id="3-指针的值—-或者叫指针所指向的内存区或地址"><a href="#3-指针的值—-或者叫指针所指向的内存区或地址" class="headerlink" title="3.指针的值—-或者叫指针所指向的内存区或地址"></a>3.指针的值—-或者叫指针所指向的内存区或地址</h4><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
<p> <strong>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）</strong> </p>
<h4 id="4-指针本身所占据的内存区"><a href="#4-指针本身所占据的内存区" class="headerlink" title="4 指针本身所占据的内存区"></a>4 指针本身所占据的内存区</h4><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
<h2 id="二、指针的算术运算"><a href="#二、指针的算术运算" class="headerlink" title="二、指针的算术运算"></a>二、指针的算术运算</h2><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：</p>
<p>例二：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  char a[<span class="number">20</span>];</span><br><span class="line"><span class="number">2.</span>  <span class="built_in">int</span> *ptr=(<span class="built_in">int</span>*)a; <span class="comment">//强制类型转换并不会改变a 的类型</span></span><br><span class="line"><span class="number">3.</span>  ptr++;</span><br></pre></td></tr></table></figure>
<p>在上例中，指针ptr的类型是int* ,它指向的类型是 int ，它被初始化为指向整型变量a。接下来的第3句中，指针 ptr 被加了1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int) ，在 32 位程序中，是被加上了4，因为在32 位程序中，int 占4个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：</p>
<p>例三：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;  </span><br><span class="line"><span class="built_in">int</span> *ptr=<span class="built_in">array</span>;  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*ptr)++;  </span><br><span class="line">    ptr++；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<p>再看例子：</p>
<p>例四：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> a[<span class="number">20</span>]=<span class="string">"You_are_a_girl"</span>;  </span><br><span class="line"><span class="built_in">int</span> *<span class="keyword">ptr</span>=(<span class="built_in">int</span> *)a;  </span><br><span class="line"><span class="keyword">ptr</span>+=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的ptr 所指向的地址比起加5 后的ptr 所指向的地址来说，向高地址方向移动了20 个字节。<br>在这个例子中，没加5 前的ptr 指向数组a 的第0 号单元开始的四个字节，加5 后，ptr 已经指向了数组a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过ptr 的值是被减去5 乘sizeof(int)，新的ptr 指向的地址将比原来的ptr 所指向的地址向低地址方向移动了20 个字节。<br>下面请允许我再举一个例子:(一个误区)</p>
<p>例五:</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="built_in">int</span> main()  </span><br><span class="line">&#123;  </span><br><span class="line">    char a[<span class="number">20</span>]=<span class="string">" You_are_a_girl"</span><span class="comment">;  </span></span><br><span class="line">    char *p=a<span class="comment">;  </span></span><br><span class="line">    char **<span class="built_in">ptr</span>=&amp;p<span class="comment">;  </span></span><br><span class="line">    //printf(<span class="string">"p=%d\n"</span>,p)<span class="comment">;  </span></span><br><span class="line">    //printf(<span class="string">"ptr=%d\n"</span>,<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">    //printf(<span class="string">"*ptr=%d\n"</span>,*<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">    printf(<span class="string">"**ptr=%c\n"</span>,**<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">    <span class="built_in">ptr</span>++<span class="comment">;  </span></span><br><span class="line">    //printf(<span class="string">"ptr=%d\n"</span>,<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">    //printf(<span class="string">"*ptr=%d\n"</span>,*<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">    printf(<span class="string">"**ptr=%c\n"</span>,**<span class="built_in">ptr</span>)<span class="comment">;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>误区一、</strong></p>
<p>输出答案为Y 和o</p>
<p>误解:ptr 是一个char 的二级指针,当执行ptr++;时,会使指针加一个sizeof(char),所以输出如上结果,这个可能只是少部分人的结果.</p>
<p><strong>误区二、</strong></p>
<p>输出答案为Y 和a误解:ptr 指向的是一个char* 类型,当执行ptr++;时,会使指针加一个sizeof(char* )(有可能会有人认为这个值为1,那就会得到误区一的答案,这个值应该是4,参考前面内容), 即&amp;p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元素了吗?答案是否定的.</p>
<p><strong>正解:</strong> </p>
<p>ptr 的类型是char<em>* ,指向的类型是一个char</em> 类型,该指向的地址就是p的地址(&amp;p),当执行ptr++;时,会使指针加一个sizeof(char<em>),即&amp;p+4;那</em>(&amp;p+4)指向哪呢,这个你去问上帝吧,或者他会告诉你在哪?所以最后的输出会是一个随机的值,或许是一个非法操作.</p>
<p><strong>总结一下:</strong></p>
<p>一个指针ptrold 加(减)一个整数n 后，结果是一个新的指针ptrnew，ptrnew 的类型和ptrold 的类型相同，ptrnew 所指向的类型和ptrold所指向的类型也相同。ptrnew 的值将比ptrold 的值增加(减少)了n 乘sizeof(ptrold 所指向的类型)个字节。就是说，ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了n 乘sizeof(ptrold 所指向的类型)个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。</p>
<h3 id="三、运算符-amp-和"><a href="#三、运算符-amp-和" class="headerlink" title="三、运算符&amp;和*"></a>三、运算符&amp;和*</h3><p>这里&amp;是取地址运算符，* 是间接运算符。</p>
<p>&amp;a 的运算结果是一个指针，指针的类型是a 的类型加个* ，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。</p>
<p>然而 * p 的运算结果就五花八门了。总之 * p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。</p>
<p>例六：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">12</span>; <span class="built_in">int</span> b; <span class="built_in">int</span> *p; <span class="built_in">int</span> **ptr;  </span><br><span class="line">p=&amp;a; <span class="comment">//&amp;a 的结果是一个指针，类型是int*，指向的类型是  </span></span><br><span class="line"><span class="comment">//int，指向的地址是a 的地址。  </span></span><br><span class="line">*p=<span class="number">24</span>; <span class="comment">//*p 的结果，在这里它的类型是int，它所占用的地址是  </span></span><br><span class="line"><span class="comment">//p 所指向的地址，显然，*p 就是变量a。  </span></span><br><span class="line">ptr=&amp;p; <span class="comment">//&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，  </span></span><br><span class="line"><span class="comment">//在这里是int **。该指针所指向的类型是p 的类型，这  </span></span><br><span class="line"><span class="comment">//里是int*。该指针所指向的地址就是指针p 自己的地址。  </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针  </span></span><br><span class="line"><span class="comment">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋  </span></span><br><span class="line"><span class="comment">//值就是毫无问题的了。  </span></span><br><span class="line">**ptr=<span class="number">34</span>; <span class="comment">//*ptr 的结果是ptr 所指向的东西，在这里是一个指针，  </span></span><br><span class="line"><span class="comment">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span></span><br></pre></td></tr></table></figure>
<h2 id="四、指针表达式"><a href="#四、指针表达式" class="headerlink" title="四、指针表达式"></a>四、指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p>
<p>下面是一些指针表达式的例子：</p>
<p>例七：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a,b;  </span><br><span class="line"><span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="built_in">int</span> *pa;  </span><br><span class="line">pa=&amp;a; <span class="comment">//&amp;a 是一个指针表达式。  </span></span><br><span class="line">Int **ptr=&amp;pa; <span class="comment">//&amp;pa 也是一个指针表达式。  </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 和&amp;b 都是指针表达式。  </span></span><br><span class="line">pa=<span class="built_in">array</span>;  </span><br><span class="line">pa++; <span class="comment">//这也是指针表达式。</span></span><br></pre></td></tr></table></figure>

<p>例八：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">char</span> **parr=arr; <span class="comment">//如果把arr 看作指针的话，arr 也是指针表达式  </span></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span>;  </span><br><span class="line"><span class="keyword">str</span>=*parr; <span class="comment">//*parr 是指针表达式  </span></span><br><span class="line"><span class="keyword">str</span>=*(parr+<span class="number">1</span>); <span class="comment">//*(parr+1)是指针表达式  </span></span><br><span class="line"><span class="keyword">str</span>=*(parr+<span class="number">2</span>); <span class="comment">//*(parr+2)是指针表达式</span></span><br></pre></td></tr></table></figure>

<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。* ptr 是一个左值，因为* ptr 这个指针已经占据了内存，其实* ptr 就是指针pa，既然pa 已经在内存中有了自己的位置，那么* ptr 当然也有了自己的位置。</p>
<h3 id="五、数组和指针的关系"><a href="#五、数组和指针的关系" class="headerlink" title="五、数组和指针的关系"></a>五、数组和指针的关系</h3><p>数组的数组名其实可以看作一个指针。看下例：</p>
<p>例九：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;  </span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">//也可写成：value=*array;  </span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">3</span>]; <span class="comment">//也可写成：value=*(array+3);  </span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">4</span>]; <span class="comment">//也可写成：value=*(array+4);</span></span><br></pre></td></tr></table></figure>

<p>上例中，一般而言数组名array 代表数组本身，类型是int[10]，但如果把array 看做指针的话，它指向数组的第0 个单元，类型是int* 所指向的类型是数组单元的类型即int。因此 * array 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第3 个单元的指针，所以 * (array+3)等于3。其它依此类推。</p>
<p>例十：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span>[<span class="number">3</span>]=&#123;  </span><br><span class="line">    <span class="string">"Hello,thisisasample!"</span>,  </span><br><span class="line">    <span class="string">"Hi,goodmorning."</span>,  </span><br><span class="line">    <span class="string">"Helloworld"</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">char</span> s[<span class="number">80</span>]；  </span><br><span class="line">strcpy(s,<span class="keyword">str</span>[<span class="number">0</span>]); <span class="comment">//也可写成strcpy(s,*str);  </span></span><br><span class="line">strcpy(s,<span class="keyword">str</span>[<span class="number">1</span>]); <span class="comment">//也可写成strcpy(s,*(str+1));  </span></span><br><span class="line">strcpy(s,<span class="keyword">str</span>[<span class="number">2</span>]); <span class="comment">//也可写成strcpy(s,*(str+2));</span></span><br></pre></td></tr></table></figure>

<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str 当作一个指针的话，它指向数组的第0 号单元，它的类型是char **，它指向的类型是char *。</p>
<p>那 * str 也是一个指针，它的类型是char* ，它所指向的类型是char，它指向的地址是字符串”Hello,thisisasample!”的第一个字符的地址，即’H’的地址。注意:字符串相当于是一个数组,在内存中以数组的形式储存,只不过字符串是一个数组常量,内容不可改变,且只能是右值.如果看成指针的话,他即是常量指针,也是指针常量.</p>
<p>str+1 也是一个指针，它指向数组的第1 号单元，它的类型是char<em>* ，它指向的类型是char</em> 。</p>
<p>然而，* (str+1)也是一个指针，它的类型是char* ，它所指向的类型是char，它指向”Hi,goodmorning.”的第一个字符’H’</p>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<p>声明了一个数组TYPE array[n]，则数组名称array 就有了两重含义：</p>
<p>第一，它代表整个数组，它的类型是TYPE[n]；</p>
<p>第二，它是一个常量指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0 号单元，该指针自己占有单独的内存区，注意它和数组第0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array 可以扮演不同的角色。在表达式sizeof(array)中，数组名array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。</p>
<p>在表达式* array 中，array 扮演的是指针，因此这个表达式的结果就是数组第0 号单元的值。sizeof(* array)测出的是数组单元的大小。</p>
<p>表达式array+n（其中n=0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是TYPE * ，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。在32 位程序中结果是4</p>
<p>例十一:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="built_in">int</span> (*ptr)[<span class="number">10</span>];  </span><br><span class="line">ptr=&amp;<span class="built_in">array</span>;：</span><br></pre></td></tr></table></figure>

<p>上例中ptr 是一个指针，它的类型是int( * )[10]，他指向的类型是int[10] ，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array 代表数组本身。</p>
<p>本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？</p>
<p>答案是前者。例如：</p>
<p>int( * ptr)[10];</p>
<p>则在32 位程序中，有：</p>
<p>sizeof(int( * )[10])==4</p>
<p>sizeof(int[10])==40</p>
<p>sizeof(ptr)==4</p>
<p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h3 id="六、指针和结构类型的关系"><a href="#六、指针和结构类型的关系" class="headerlink" title="六、指针和结构类型的关系"></a>六、指针和结构类型的关系</h3><p>可以声明一个指向结构类型对象的指针。</p>
<p>例十二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">int</span> b;  </span><br><span class="line">    <span class="keyword">int</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span>=&#123;</span><span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;  </span><br><span class="line"><span class="comment">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span>=&amp;<span class="title">ss</span>;</span>  </span><br><span class="line"><span class="comment">//声明了一个指向结构对象ss 的指针。它的类型是  </span></span><br><span class="line"><span class="comment">//MyStruct *,它指向的类型是MyStruct。  </span></span><br><span class="line"><span class="keyword">int</span> *pstr=(<span class="keyword">int</span>*)&amp;ss;  </span><br><span class="line"><span class="comment">//声明了一个指向结构对象ss 的指针。但是pstr 和  </span></span><br><span class="line"><span class="comment">//它被指向的类型ptr 是不同的。</span></span><br></pre></td></tr></table></figure>

<p><strong>请问怎样通过指针ptr 来访问ss 的三个成员变量？<br>答案：</strong></p>
<p>ptr-&gt;a; //指向运算符，或者可以这们( * ptr).a,建议使用前者</p>
<p>ptr-&gt;b;</p>
<p>ptr-&gt;c;</p>
<p><strong>又请问怎样通过指针pstr 来访问ss 的三个成员变量？<br>答案：</strong></p>
<p>-&gt; * pstr； //访问了ss 的成员a。</p>
<p>-&gt; * (pstr+1); //访问了ss 的成员b。</p>
<p>-&gt; * (pstr+2) //访问了ss 的成员c。</p>
<p>虽然我在我的MSVC++6.0 上调式过上述代码，但是要知道，这样使用pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p>
<p>例十三：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">array</span>[<span class="number">3</span>]=&#123;<span class="number">35</span>,<span class="number">56</span>,<span class="number">37</span>&#125;;  </span><br><span class="line"><span class="built_in">int</span> *pa=<span class="built_in">array</span>;  </span><br><span class="line"><span class="comment">//通过指针pa 访问数组array 的三个单元的方法是：  </span></span><br><span class="line">*pa; <span class="comment">//访问了第0 号单元  </span></span><br><span class="line">*(pa+<span class="number">1</span>); <span class="comment">//访问了第1 号单元  </span></span><br><span class="line">*(pa+<span class="number">2</span>); <span class="comment">//访问了第2 号单元</span></span><br></pre></td></tr></table></figure>

<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。</p>
<p>所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<p>所以，在例十二中，即使* pstr 访问到了结构对象ss 的第一个成员变量a，也不能保证* (pstr+1)就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定* (pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。</p>
<p>不过指针访问结构成员的正确方法应该是象例十二中使用指针ptr 的方法。</p>
<h3 id="七、指针和函数的关系"><a href="#七、指针和函数的关系" class="headerlink" title="七、指针和函数的关系"></a>七、指针和函数的关系</h3><p>可以把一个指针声明成为一个指向函数的指针。</p>
<p>int fun1(char *,int);</p>
<p>int ( * pfun1)(char * ,int);</p>
<p>pfun1=fun1;</p>
<p>int a=( * pfun1)(“abcdefg”,7); //通过函数指针调用函数。</p>
<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<p>例十四：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">int <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> *);  </span><br><span class="line">inta;  </span><br><span class="line">char str[]=<span class="string">"abcdefghijklmn"</span>;  </span><br><span class="line">a=<span class="function"><span class="keyword">fun</span>(<span class="title">str</span></span>);  </span><br><span class="line">int <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> *s)  </span><br><span class="line">&#123;  </span><br><span class="line">    int num=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num+=*s;s++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p>
<h3 id="八、指针类型转换"><a href="#八、指针类型转换" class="headerlink" title="八、指针类型转换"></a>八、指针类型转换</h3><p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<p>例十五：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">float <span class="attribute">f</span>=12.3;  </span><br><span class="line">float <span class="number">*f</span><span class="attribute">ptr</span>=&amp;f;  </span><br><span class="line">int *p;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，假如我们想让指针p 指向实数f，应该怎么办？</p>
<p>是用下面的语句吗？</p>
<p>p=&f;</p>
<p>不对。因为指针p 的类型是int *，它指向的类型是int。表达式&amp;f 的结果是一个指针，指针的类型是float *,它指向的类型是float。</p>
<p>两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行”强制类型转换”：</p>
<p>p=(int*)&f;</p>
<p>如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP *TYPE， 那么语法格式是： (TYPE *)p；</p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE *，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。</p>
<p>而原来的指针p 的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换</p>
<p>例十六：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span>*);  </span><br><span class="line">int a=<span class="number">125</span>,b;  </span><br><span class="line"><span class="function"><span class="keyword">fun</span>((<span class="title">char</span></span>*)&amp;a);  </span><br><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span>*s)  </span><br><span class="line">&#123;  </span><br><span class="line">    charc;  </span><br><span class="line">    c=*(s+<span class="number">3</span>);*(s+<span class="number">3</span>)=*(s+<span class="number">0</span>);*(s+<span class="number">0</span>)=c;  </span><br><span class="line">    c=*(s+<span class="number">2</span>);*(s+<span class="number">2</span>)=*(s+<span class="number">1</span>);*(s+<span class="number">1</span>)=c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参&amp;a 的结果是一个指针，它的类型是int * ，它指向的类型是int。形参这个指针的类型是char * ，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int * 类型到char * 类型的转换。</p>
<p><strong>结合这个例子，我们可以这样来</strong></p>
<p>想象编译器进行转换的过程：编译器先构造一个临时指针char * temp，然后执行temp=(char * )&amp;a，最后再把temp 的值传递给s。所以最后的结果是：s 的类型是char * ,它指向的类型是char，它指向的地址就是a 的首地址。</p>
<p>我们已经知道，指针的值就是指针指向的地址，在32 位程序中，指针的值其实是一个32 位整数。</p>
<p>那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">unsigned <span class="built_in">int</span> a;  </span><br><span class="line"><span class="built_in">TYPE</span> *ptr; //<span class="built_in">TYPE</span> 是<span class="built_in">int</span>，<span class="built_in">char</span> 或结构类型等等类型。  </span><br><span class="line">a=<span class="number">20345686</span>;  </span><br><span class="line">ptr=<span class="number">20345686</span>; //我们的目的是要使指针ptr 指向地址<span class="number">20345686</span>  </span><br><span class="line">  </span><br><span class="line">ptr=a; //我们的目的是要使指针ptr 指向地址<span class="number">20345686</span>  </span><br><span class="line">//编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：  </span><br><span class="line">unsigned <span class="built_in">int</span> a;  </span><br><span class="line"><span class="built_in">TYPE</span> *ptr; //<span class="built_in">TYPE</span> 是<span class="built_in">int</span>，<span class="built_in">char</span> 或结构类型等等类型。  </span><br><span class="line">a=<span class="built_in">N</span> //<span class="built_in">N</span> 必须代表一个合法的地址；  </span><br><span class="line">ptr=(<span class="built_in">TYPE</span>*)a； //呵呵，这就可以了。</span><br></pre></td></tr></table></figure>

<p>严格说来这里的(TYPE * )和指针类型转换中的(TYPE * )还不一样。这里的(TYPE * )的意思是把无符号整数a 的值当作一个地址来看待。上面强调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<p>例十七：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">123</span>,b;  </span><br><span class="line"><span class="keyword">int</span> *ptr=&amp;a;  </span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span>;  </span><br><span class="line">b=(<span class="keyword">int</span>)ptr; <span class="comment">//把指针ptr 的值当作一个整数取出来。  </span></span><br><span class="line"><span class="keyword">str</span>=(<span class="keyword">char</span>*)b; <span class="comment">//把这个整数的值当作一个地址赋给指针str。</span></span><br></pre></td></tr></table></figure>

<p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<h3 id="九、指针的安全问题"><a href="#九、指针的安全问题" class="headerlink" title="九、指针的安全问题"></a>九、指针的安全问题</h3><p>看下面的例子：</p>
<p>例十八：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">char s=<span class="string">'a'</span><span class="comment">;  </span></span><br><span class="line"><span class="built_in">int</span> *<span class="built_in">ptr</span><span class="comment">;  </span></span><br><span class="line"><span class="built_in">ptr</span>=(<span class="built_in">int</span> *)&amp;s<span class="comment">;  </span></span><br><span class="line">*<span class="built_in">ptr</span>=<span class="number">1298</span>；</span><br></pre></td></tr></table></figure>
<p>指针ptr 是一个int * 类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。</p>
<p>让我们再来看一例：</p>
<p>例十九：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> a;  </span><br><span class="line"><span class="built_in">int</span> *<span class="keyword">ptr</span>=&amp;a;  </span><br><span class="line"><span class="keyword">ptr</span>++;  </span><br><span class="line">*<span class="keyword">ptr</span>=<span class="number">115</span>;</span><br></pre></td></tr></table></figure>
<p>该例子完全可以通过编译，并能执行。但是看到没有？第3 句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。</p>
<p>而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。</p>
<p>在指针的强制类型转换：ptr1=(TYPE * )ptr2 中，如果sizeof(ptr2的类型)大于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C指针--函数形参int * p与int * * p的区别</title>
    <url>/C%E6%8C%87%E9%92%88-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82int-p%E4%B8%8Eint-p%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p>首先看代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">void fun(<span class="name">int</span> * p) ;</span><br><span class="line">int * pBuf = NULL<span class="comment">;                                    //****************(1)</span></span><br><span class="line">fun(<span class="name">pBuf</span>)<span class="comment">;                                            //****************(2)</span></span><br><span class="line">void fun(<span class="name">int</span> * p)                                     //****************(3)</span><br><span class="line">&#123;</span><br><span class="line">      p = (int*)malloc(<span class="number">10</span>*sizeof(int));               //****************(4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分析一下在每行代码中都发生了什么：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">在 (<span class="number">1</span>) 中，声明pBuf为<span class="built_in">int</span> * 类型，指向<span class="built_in">int</span>类型。此时，pBuf 是指针，其是有值的，即有内存地址(假如是：<span class="number">0x00007fff5fbff620</span>)，但其指向的内存却为空NULL。</span><br><span class="line"></span><br><span class="line">在 (<span class="number">2</span>)  (<span class="number">3</span>)中，pBuf 作为实参传入函数 **fun(<span class="built_in">int</span> * p)**中**(p为形参，此时p为 <span class="built_in">int</span> * 类型，指向<span class="built_in">int</span>类型)**。p =pBuf，亦为<span class="number">0x00007fff5fbff620</span>，具有相同地址。</span><br><span class="line"></span><br><span class="line">在 (<span class="number">4</span>) 中，malloc申请一块内存，并返回指向此内存的地址，并给了p，此时 p 指向了malloc申请的内存，p有了新的地址，与pBuf不再相等，不再为<span class="number">0x00007fff5fbff620</span>。而此时pBuf却没有改变，依然是<span class="number">0x00007fff5fbff620</span>。</span><br></pre></td></tr></table></figure>

<p>所有这种方法并不会为pBuf改变什么，仍然指向NULL。但是pBuf是有内存地址的(初始化的时候就有),却指向NULL，即并没有开辟内存，所有不能对pBuf进行赋值，因为其没有内存存储值。</p>
<p>再看另一种方式：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> ** p) ;</span><br><span class="line">int * pBuf = NULL;                                     <span class="regexp">//</span>****************(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span>(<span class="title">&amp;</span></span>pBuf);                                            <span class="regexp">//</span>****************(<span class="number">2</span>)</span><br><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> ** p)                                     /<span class="regexp">/****************(3)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">      *p = (int*)malloc(10*sizeof(int));               /</span><span class="regexp">/****************(4)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>同样的分析一下上面每行代码中都发生了什么：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">在 (<span class="number">1</span>) 中，与第一段代码没什么区别。假如：pBuf = <span class="number">0x00007fff5fbff620</span>，&amp;pBuf=<span class="number">0x00007fffaaae0f70</span>，* pBuf = NULL。</span><br><span class="line"></span><br><span class="line">在 (<span class="number">2</span>) (<span class="number">3</span>)中，&amp;pBuf作为实参传入函数 fun(<span class="built_in">int</span> ** p) 中 (p为形参，此时p为<span class="built_in">int</span> ** 类型，即为指针的指针)，p=&amp;pBuf(<span class="number">0x00007fffaaae0f70</span>)。指向 (<span class="built_in">int</span> * ) 类型，即指向了指针，这个指针其实就是pBuf，即 p 指向了 pBuf ，所以  * p其实就是 pBuf (<span class="number">0x00007fff5fbff620</span>)。此时别忘记，<span class="number">0x00007fff5fbff620</span> 是指向NULL的。</span><br><span class="line"></span><br><span class="line">在 (<span class="number">4</span>) 中，malloc申请一块内存，并返回指向此内存的地址，并给了 * p，此时 * p 指向了malloc申请的内存。此时 p依然没有改变，与&amp;pBuf相等(<span class="number">0x00007fffaaae0f70</span>)，但是p指向的地址却改变了，指向了一块新的内存。所以<span class="number">0x00007fffaaae0f70</span>指向的一个新的内存地址，而这个内存地址也指向的一块内存，不再是NULL。</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong><br>第一段代码，传入了指向空内存的地址，最后改变了形参p的地址，与传入的pBuf不再相等，所有没有对pBuf进行改变什么。<br>第二段代码，传入了指向指针pBuf的指针，最后改变的是p指向的地址，而p依然是指向指针pBuf的指针。最后其实是改变了传入的指针的指向，即改变了&amp;pBuf的指向，让其指向了新的地址。</p>
]]></content>
      <categories>
        <category>C开发</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO键值依赖</title>
    <url>/KVO%E9%94%AE%E5%80%BC%E4%BE%9D%E8%B5%96.html</url>
    <content><![CDATA[<p>** 一个属性与有限个属性关联，例如下面的totalAge与user1和user2的age息息相关，只要其中一个改变，totalAge就会改变。 **</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Person.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Walg on 2017/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 Walg. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> *pName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Person.m中未做任何处理！</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Card.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Walg on 2017/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 Walg. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Card</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">NSInteger</span> totalAge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)Person *user1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)Person *user2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Card.m</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Walg on 2017/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 Walg. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Card.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Card</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _user1 = [[Person alloc] init];</span><br><span class="line">        _user2 = [[Person alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSInteger</span>)totalAge&#123;</span><br><span class="line">    <span class="keyword">return</span> _user1.age+_user2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="built_in">NSArray</span> *moreKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"totalAge"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        moreKeyPaths = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"user1.age"</span>, <span class="string">@"user2.age"</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (moreKeyPaths)</span><br><span class="line">    &#123;</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:moreKeyPaths];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  键值依赖</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Walg on 2017/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 Walg. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Card.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)Card *userCard;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> NewAge()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> newAge = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> newAge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _userCard = [[Card alloc] init];</span><br><span class="line">    _userCard.user1.pName = <span class="string">@"a"</span>;</span><br><span class="line">    _userCard.user1.age = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.userCard addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"totalAge"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"keyPath:%@"</span>,keyPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"object:%@"</span>,object);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"change:%@"</span>,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">self</span>.userCard.user2.age = NewAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>** log： **</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">14</span>:<span class="number">07.100</span> 键值依赖[<span class="number">62587</span>:<span class="number">1948971</span>] keyPath:totalAge</span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">14</span>:<span class="number">07.101</span> 键值依赖[<span class="number">62587</span>:<span class="number">1948971</span>] object:&lt;Card: <span class="number">0x60800003dfa0</span>&gt;</span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">14</span>:<span class="number">07.101</span> 键值依赖[<span class="number">62587</span>:<span class="number">1948971</span>] change:&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">28</span>;</span><br><span class="line">    old = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>键值依赖</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发证书要点详解，ios证书详解</title>
    <url>/iOS%E5%BC%80%E5%8F%91%E8%AF%81%E4%B9%A6%E8%A6%81%E7%82%B9%E8%AF%A6%E8%A7%A3%EF%BC%8Cios%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<p>关于开发证书配置（Certificates&amp;Identifiers&amp;Provisioning Profiles），相信做iOS开发的同学没少被折腾。对于一个iOS开发小白、半吊子抑或老兵，或多或少会有以下不详、疑问、疑惑甚至困惑：</p>
<p>本文将对相关概念做个系统的梳理串烧。</p>
<p>首先，假设你使用过Apple设备（iMac/iPad/iPhone）且注册过Apple ID（Apple Account）。<br>其次，你必须加入苹果开发者计划（Enroll in iOS Developer Program to become a member），注册一个开发者账号。<br>只有拥有开发者账号，才可以申请开发/发布证书及相关配置授权文件，进而在iOS真机上开发调试Apps或发布到App Store。<br>开发者账号分为Individual和Company/Organization两种类型。如无特别交代，下文基于$99/Year的普通个人开发者（Individual）账号展开。</p>
<h4 id="一-App-ID（bundle-identifier）"><a href="#一-App-ID（bundle-identifier）" class="headerlink" title="一.App ID（bundle identifier）"></a>一.App ID（bundle identifier）</h4><p>App ID用于标识一个或者一组App，App ID应该和Xcode中的Bundle Identifier是一致的或匹配的。<br>App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed）。<br>App ID全名会被追加ApplicationIdentifierPrefix（一般为TeamID.），分为两类：<br>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的程序。<br>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如“<em>”（实际上是ApplicationIdentifierPrefix）表示所有应用程序；而“com.apple.</em>”可以表示以“com.apple.”开头的所有应用程序。</p>
<p>用户可在网站上删除（Delete）已注册的App IDs。App ID<strong>被配置到</strong>【XcodeTarget|Info|Bundle Identifier】下；对于Wildcard App ID，只要bundle identifier包含其作为Prefix/Seed即可。</p>
<h4 id="二-设备（Device）"><a href="#二-设备（Device）" class="headerlink" title="二.设备（Device）"></a>二.设备（Device）</h4><p>Device就是运行iOS系统用于开发调试App的设备，每台设备使用<strong>UDID</strong>来唯一标识。iOS设备连接Mac后，可通过iTunes-&gt;Summary或者Xcode-&gt;Window-&gt;Devices获取iPhone的UDID（identifier）。<br>Apple Member Center网站个人账号下的Devices中包含了注册过的所有可用于开发和<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>的设备。普通个人开发账号每年累计最多只能注册100个设备，用户可在网站上启用/禁用（Enable/Disable）已注册的Device。<br>Apps signed by you or your team run only on designated development devices.<br>Apps run only on the test devices you specify.</p>
<p>本文的Devices即<strong>连接到</strong>Xcode被授权用于开发测试的iOS设备（iPhone/iPad）。</p>
<h4 id="三-证书（Certificates）"><a href="#三-证书（Certificates）" class="headerlink" title="三.证书（Certificates）"></a>三.证书（Certificates）</h4><p>顾名思义，证书是用来证明内容（App的executalbe code）的合法性和完整性的。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证App内容是完整、未经篡改的。<br>证书分为两类：Development和Production（Distribution）。<br>Development证书用来开发和调试应用程序：A <strong><em>development certificate</em></strong> identifies you, as a team member, in a development provisioning profile that allows apps signed by you to <strong>*launch *</strong>on devices.<br>Production主要用来分发应用程序（根据证书种类有不同作用）：A <strong><em>distribution certificate</em></strong> identifies your team or organization in a distribution provisioning profile and allows you to <strong>*submit  *</strong>your app to the store. Only a team agent or an admin can create a distribution certificate.</p>
<p>普通个人开发账号最多可注册iOS Development/Distribution证书各2个，用户可在网站上删除（Revoke）已注册的Certificate。下文主要针对开发调试阶段的Development证书。<br>首先，iOS以及Mac OS X系统（在安装Xcode时）将自动安装AppleWWDRCA.cer<em>(Apple Worldwide Developer Relations Certification Authority)</em>这个中间证书（<strong>Intermediate Certificates）</strong>。它实际上就是iOS证书的CA，其公钥用于解密认证证书的可靠性。如果Mac Keychain Access证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-6915aad5088cce83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>通过Keychain证书助理<strong>手动申请</strong>开发证书时（也可通过Xcode自动请求生成），keychain将生成一个包含开发者身份信息的<strong>CSR</strong>（Certificate Signing Request）文件；同时，Keychain Access|Keys中将新增一对Public/Private <strong>Key Pair</strong>（This signing identity consists of a public-private key pair that Apple issues）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-51018fcd34ca6844?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>private key用于签名（CodeSign），始终保存在Mac OS的Keychain Access中；public key一般随证书散布出去，对签名进行校验认证。用户必须保护好本地Keychain中的private key，以防伪冒。<br>Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an <strong><em>entirely new</em></strong> identity to sign code.<br>Worse, if someone else has your private key, that person may be able to <strong>*impersonate *</strong>you.</p>
<p>在Apple开发网站上传该CSR文件，Apple证书颁发机构WWDRCA将使用private key对CSR中的public key和一些身份信息进行加密签名生成<strong>数字证书</strong>（ios_development.cer）并记录在案（Apple Member Center）。<br>从Apple Member Center网站下载证书到Mac上双击即可安装。证书安装成功后，在KeychainAccess|Keys中展开创建CSR时生成的Key Pair中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在Keychain Access|Certificates中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-43443ba9168bb1eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="http://upload-images.jianshu.io/upload_images/2647951-45d5cd4089552153?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>Certificate<strong>被配置到</strong>【Xcode Target|Build Settings|Code Signing|Code Signing Identity】下，下拉选择Identities from Profile “…”（一般先配置Provisioning Profile）。</p>
<h4 id="四-供应配置文件（Provisioning-Profiles）"><a href="#四-供应配置文件（Provisioning-Profiles）" class="headerlink" title="四.供应配置文件（Provisioning Profiles）"></a>四.供应配置文件（Provisioning Profiles）</h4><p><strong>Provisioning Profile文件包含了上述的所有内容：</strong>证书、App ID和设备**。<br>一个Provisioning Profile对应一个Explicit App ID或Wildcard App ID（一组相同Prefix/Seed的App IDs）。在网站上手动创建一个Provisioning Profile时，需要依次指定App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的ProvisioningProfiles。<br>Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。安装应用程序时，Provisioning Profile文件被拷贝到iOS设备中，运行该iOS App的设备也通过它来认证安装的程序。<br>如果要打包或者在真机上运行一个APP，一般要经历以下三步：<br>首先，需要证书对应的私钥来进行签名，用于标识这个APP是合法、安全、完整的；<br>其次，需要指明它的App ID，并且验证Bundle ID是否与其一致；<br>然后，如果是真机调试，需要确认这台设备是否授权运行该APP。</p>
<p>Provisioning Profile把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的Provisioning Profile文件就可以了。<br>Provisioning Profile也分为Development和Distribution两类，有效期同Certificate一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited）。App ID为Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。</p>
<p>Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录~/Library/MobileDevice/Provisioning Profiles下。<br>以下为典型供应配置文件<em>.mobileprovision的*</em>构成简析**：</p>
<p>（1）<strong><em>Name</em></strong>：该mobileprovision的文件名。</p>
<p>（2）<strong><em>UUID</em></strong>：该mobileprovision文件的真实文件名。</p>
<p>（3）<strong><em>TeamName</em></strong>：Apple ID账号名。</p>
<p>（4）<strong><em>TeamIdentifier</em></strong>：Team Identity。</p>
<p>（5）<strong><em>AppIDName</em></strong>：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。</p>
<p>（6）<strong><em>ApplicationIdentifierPrefix</em></strong>：完整App ID的前缀（TeamIdentifier.*）。</p>
<p>（7）<strong><em>DeveloperCertificates</em></strong>：包含了可以为使用该配置文件应用签名的所有证书<data><array>。</array></data></p>
<p>证书是基于Base64编码，符合PEM(PrivacyEnhanced Mail, RFC 1848)格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。</p>
<p>从DeveloperCertificates提取<data></data>之间的内容到文件cert.cer（cert.perm）：</p>
<p>—–BEGIN CERTIFICATE—–</p>
<p>将<data></data>之间的内容拷贝至此</p>
<p>—–END CERTIFICATE—–`</p>
<p>Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥KeyPair配对）应吻合；Windows下没有足够信息（WWDRCA.cer），无法验证该证书。</p>
<p>如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。</p>
<p>（8）<strong><em>Entitlements</em></strong>键<key>对应的<dict>：</dict></key></p>
<p><strong>keychain-access-groups</strong>：$(AppIdentifierPrefix)，参见<strong><em>Code Signing Entitlements</em></strong>(*.entitlements)。</p>
<p>每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的<strong>keychain</strong>，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。</p>
<p><strong>application-identifier</strong>：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。</p>
<p><strong>com.apple.security.application-groups</strong>：App Group ID（group. com.apple），参见<strong><em>Code Signing Entitlements</em></strong>(*.entitlements)。</p>
<p><strong>com.apple.developer.team-identifier</strong>：同Team Identifier。</p>
<p>（9）<strong><em>Provisioned Devices</em></strong>：该mobileprovision授权的开发设备的UDID <array>。</array></p>
<p>Provisioning Profile<strong>被配置到</strong>【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。</p>
<h4 id="五-开发组供应配置文件"><a href="#五-开发组供应配置文件" class="headerlink" title="五.开发组供应配置文件"></a>五.开发组供应配置文件</h4><p>（<strong>Team Provisioning Profiles</strong>）<strong>每个Apple开发者账号都对应一个唯一的</strong>Team ID，<strong>Xcode3.2.3预发布版本中加入了Team Provisioning Profile这项新功能。<br>在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑</strong>自动生成<em>*iOS Team Provisioning Profile（Managed by Xcode）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-478b680d2dd8b28a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(</em>)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个eam注册的所有设备上调试所有的应用程序（不管bundleidentifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOSTeam Provisioning Profile。<br>Team Provisioning Profile生成/更新时机：<br>Add an Apple ID account to Xcode<br>Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode<br>Assign Your App to a Team in Xcode project settings of General|Identity<br>Register new device on the apple development website or Xcode detected new device connected</p>
<p>利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。<br>Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也<strong>被配置到</strong>【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。</p>
<h4 id="六-App-Group-（ID）"><a href="#六-App-Group-（ID）" class="headerlink" title="六.App Group （ID）"></a>六.App Group （ID）</h4><p><strong>WWDC14除了发布了OS X v10.10和switf外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。<br>扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group <a href="http://lib.csdn.net/base/docker" target="_blank" rel="noopener">Container</a>。<br>用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。<br>Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范：<br>假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.*</strong>extImportRecording***”。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-59399d05ca6d0f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。<br>App Group会<strong>被配置到</strong>【Xcode Target|Build Settings|Code Signing|Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。</p>
<h3 id="七-证书与签名（Certificate-amp-Signature）"><a href="#七-证书与签名（Certificate-amp-Signature）" class="headerlink" title="七.证书与签名（Certificate&amp; Signature）"></a>七.证书与签名（Certificate&amp; Signature）</h3><p><img src="http://upload-images.jianshu.io/upload_images/2647951-4a248d32b62eff79?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>每个证书（其实是公钥）对应的<strong>私钥</strong>会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字<strong>签名</strong>（CodeSign）——使用哈希<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>生成内容<strong>摘要</strong>（digest）。上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。<br>iOS/Mac机上的ios_development.cer可以被AppleWWDRCA.cer中的 public key解密，从而获取每个开发证书中可信任的公钥。<br><strong>1.iOS/Mac设备（系统）使用CA证书</strong>（WWDRCA.cer）<strong>来判断App Provisioning Profile（Code Signing Identity）的合法性：</strong><br>若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信；<br>再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。</p>
<p><strong>2.iOS/Mac设备（系统）使用AppProvisioning Profile</strong>（Code Signing Identity）<strong>证书来判断App的合法性：</strong><br>若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信；<br>再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。</p>
<h3 id="八-在多台机器上实现开发账户-证书共享"><a href="#八-在多台机器上实现开发账户-证书共享" class="headerlink" title="八.在多台机器上实现开发账户/证书共享"></a>八.在多台机器上实现开发账户/证书共享</h3><p><strong>若在Xcode Preferences添加了该Accounts，选中Team条目|ViewDetails：可以查看Signing Identities和Provisioning Profiles。<br>选中欲导出的Account，点击+-之后的☸|ExportAccounts，可导出包含account/code signingidentity/provisioning profiles信息的*.</strong>developerprofile<strong>（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。<br>选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权exportkey “privateKey” from keychain，将导出</strong>Certificates.p12；<strong>或在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出</strong>Certificates.p12**。</p>
<p>其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件即可在iOS真机设备上开发调试。</p>
<h3 id="九-证书配置常见错误"><a href="#九-证书配置常见错误" class="headerlink" title="九.证书配置常见错误"></a>九.证书配置常见错误</h3><ol>
<li>Xcode Target|Genera|Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.”<br>Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioningprofile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！</li>
<li>Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioningprofile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain.<br>Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（<em>.developerprofile）或共享证书(</em>.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。</li>
<li>“Invalid application-identifier Entitlement”or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).”</li>
</ol>
<p><strong>（1）</strong>检查对应版本（Debug）指定的<em>.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。<br>*</em>（2）也可以将**Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。<br>4.Xcode配置反应有时候不那么及时，可刷新、重置相关配置项开关（若有）或重启Xcode试试。</p>
<p><strong>参考：</strong></p>
<p>《iPhone真机调试应用程序》《iOS Developer：真机测试》<br>《iOS Development–Certificates, Provisioning Profiles》<br>《关于Certificate、Provisioning Profile、App ID的介绍及其关系》</p>
<p>《iOS keyChain 研究》<br>《数字签名和数字证书》<br>《苹果开发者账号那些事儿》<br>《iOS Code Signing 学习笔记》<br>《代码签名探析/Inside Code Signing》<br>《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》<br>转载：<a href="http://blog.csdn.net/lw_chen/article/details/48709901" target="_blank" rel="noopener">iOS开发证书要点详解，ios证书详解</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-文字样式处理总结</title>
    <url>/iOS-%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p>在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。NSMuttableAttstring（带属性的字符串），可以灵活实现以上功能。 NSMutableParagraphStyle段落风格，设置行间距、段间距、缩进、对齐方式等。</p>
<h2 id="1-实例化方法和使用方法"><a href="#1-实例化方法和使用方法" class="headerlink" title="1. 实例化方法和使用方法"></a>1. 实例化方法和使用方法</h2><p>实例化方法：<br>使用字符串初始化</p>
<ul>
<li>(id)initWithString:(NSString *)str;//例：NSMutableAttributedString *AttributedStr = [[NSMutableAttributedStringalloc]initWithString:@”文字样式处理”];</li>
</ul>
<p>字典中存放一些属性名和属性值：</p>
<ul>
<li>(id)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//如:NSDictionary *attributeDict = [NSDictionarydictionaryWithObjectsAndKeys: [UIFontsystemFontOfSize:15.0],NSFontAttributeName, [UIColorredColor],NSForegroundColorAttributeName, NSUnderlineStyleAttributeName,NSUnderlineStyleSingle,nil];NSMutableAttributedString *AttributedStr = [[NSMutableAttributedStringalloc]initWithString:@”文字样式处理” attributes:attributeDict];</li>
</ul>
<p>使用NSAttributedString初始化，跟NSMutableString，NSString类似:</p>
<ul>
<li>(id)initWithAttributedString:(NSAttributedString *)attester;</li>
</ul>
<p>使用方法：<br>为某一范围内文字设置多个属性</p>
<ul>
<li>(void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;<br>为某一范围内文字添加某个属性</li>
<li>(void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range;<br>为某一范围内文字添加多个属性</li>
<li>(void)addAttributes:(NSDictionary *)attrs range:(NSRange)range;<br>移除某范围内的某个属性</li>
<li>(void)removeAttribute:(NSString *)name range:(NSRange)range;</li>
</ul>
<h2 id="2-常见的属性及说明"><a href="#2-常见的属性及说明" class="headerlink" title="2. 常见的属性及说明"></a>2. 常见的属性及说明</h2><p><strong>NSFontAttributeName</strong> //字体<br><strong>NSParagraphStyleAttributeName</strong> //段落格式<br><strong>NSForegroundColorAttributeName</strong> //字体颜色<br><strong>NSBackgroundColorAttributeName</strong> //背景颜色<br><strong>NSStrikethroughStyleAttributeName</strong> //删除线格式<br><strong>NSUnderlineStyleAttributeName</strong> //下划线格式<br><strong>NSStrokeColorAttributeName</strong> //删除线颜色<br><strong>NSStrokeWidthAttributeName</strong>//删除线宽度<br><strong>NSShadowAttributeName</strong> //阴影<br><strong>NSParagraphStyleAttributeName</strong>//段落的风格（设置首行，行间距，对齐方式什么的）</p>
<p>NSMutableParagraphStyle <em>paragraphStyle = [[NSMutableParagraphStyle alloc] init];<br>paragraphStyle.lineSpacing = 10;// 字体的行间距 paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进 paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然）<br>paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( “…wxyz” ,”abcd…” ,”ab…yz”)<br>paragraphStyle.headIndent = 20;//整体缩进(首行除外)<br>paragraphStyle.tailIndent = 20;//<br>paragraphStyle.minimumLineHeight = 10;//最低行高<br>paragraphStyle.maximumLineHeight = 20;//最大行高<br>paragraphStyle.paragraphSpacing = 15;//段与段之间的间距<br>paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/</em> Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. <em>/<br>paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共三种）<br>paragraphStyle.lineHeightMultiple = 15;//</em> Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. *//<br>paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">两个样式枚举</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">NSLineBreakMode</span>) &#123;/* <span class="type">What</span> to do with long lines */ </span><br><span class="line"><span class="type">NSLineBreakByWordWrapping</span> = 0, /* <span class="type">Wrap</span> at word boundaries, default */</span><br><span class="line"> <span class="type">NSLineBreakByCharWrapping</span>,/* <span class="type">Wrap</span> at character boundaries */ </span><br><span class="line"><span class="type">NSLineBreakByClipping</span>,/* <span class="type">Simply</span> clip */剪掉后面显示不了的部分 </span><br><span class="line"><span class="type">NSLineBreakByTruncatingHead</span>,/* <span class="type">Truncate</span> at head of line: "...wxyz" */头部分的内容以……方式省略 </span><br><span class="line"><span class="type">NSLineBreakByTruncatingTail</span>,/* <span class="type">Truncate</span> at tail of line: "abcd..." */结尾部分的内容以……方式省略 </span><br><span class="line"><span class="type">NSLineBreakByTruncatingMiddle</span>/* <span class="type">Truncate</span> middle of line: "ab...yz" */中间部分的内容以……方式省略 </span><br><span class="line">&#125; <span class="type">NS_ENUM_AVAILABLE_IOS</span>(6_0); </span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">NSWritingDirection</span>) &#123; </span><br><span class="line"><span class="type">NSWritingDirectionNatural</span> = -1, // <span class="type">Determines</span> direction using the <span class="type">Unicode</span> <span class="type">Bidi</span> <span class="type">Algorithm</span> rules <span class="type">P2</span> and <span class="type">P3</span>  </span><br><span class="line"><span class="type">NSWritingDirectionLeftToRight</span> = 0, // <span class="type">Left</span> to right writing direction 左到右的书写方向  </span><br><span class="line"><span class="type">NSWritingDirectionRightToLeft</span> = 1 // <span class="type">Right</span> to left writing direction 右到左的书写方向 </span><br><span class="line">&#125; <span class="type">NS_ENUM_AVAILABLE_IOS</span>(6_0);</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* NSFontAttributeName 字体大小 </span></span><br><span class="line"><span class="comment">NSParagraphStyleAttributeName 段落的风格（设置首行，行间距，对齐方式什么的） </span></span><br><span class="line"><span class="comment">NSKernAttributeName 字间距 */</span></span><br><span class="line"> NSDictionary *attributes = @&#123; </span><br><span class="line"><span class="string">NSFontAttributeName:</span>[UIFont <span class="string">systemFontOfSize:</span><span class="number">15</span>], </span><br><span class="line"><span class="string">NSParagraphStyleAttributeName:</span>paragraphStyle, </span><br><span class="line"><span class="string">NSKernAttributeName:</span>@(<span class="number">10</span>), </span><br><span class="line">&#125;; </span><br><span class="line">textView.attributedText = [[NSAttributedString alloc] <span class="string">initWithString:</span>textView.text <span class="string">attributes:</span>attributes];</span><br></pre></td></tr></table></figure>

<p>再来个实例</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随便定义一个字符串，做测试使用 </span></span><br><span class="line"><span class="built_in">NSString</span> *massageStr = <span class="string">@"\t北京乌托邦有限公司（以下简称“乌托邦”）在此特别提醒您（用户）在注册成为用户之前，请认真阅读本《用户协议》（以下简称“协议”），确保您充分理解本协议中各条款。请您审慎阅读并选择接受或不接受本协议。除非您接受本协议所有条款，否则您无权注册、登录或使用本协议所涉服务。您的注册、登录、使用等行为将视为对本协议的接受，并同意接受本协议各项条款的约束。\r\n \t本协议约定乌托邦与用户之间关于“乌托邦”软件服务（以下简称“服务”）的权利义务。“用户”是指注册、登录、使用本服务的个人。本协议可由乌托邦随时更新，更新后的协议条款一旦公布即代替原来的协议条款，恕不再另行通知，用户可在本网站查阅最新版协议条款。在乌托邦修改协议条款后，如果用户不接受修改后的条款，请立即停止使用乌托邦提供的服务，用户继续使用乌托邦提供的服务将被视为接受修改后的协议。"</span>; </span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *attributedString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:massageStr]; </span><br><span class="line"><span class="built_in">NSMutableParagraphStyle</span> *paragraphStyle = [[<span class="built_in">NSMutableParagraphStyle</span> alloc] init];</span><br><span class="line">[paragraphStyle setLineSpacing:<span class="number">20</span>];</span><br><span class="line"><span class="comment">//调整行间距</span></span><br><span class="line">[attributedString addAttribute:<span class="built_in">NSParagraphStyleAttributeName</span> value:paragraphStyle range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [<span class="keyword">self</span>.agreementText length])];</span><br><span class="line">[attributedString addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:</span><br><span class="line">[<span class="built_in">UIColor</span> redColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">12</span>)]; <span class="comment">// 0为起始位置 length是从起始位置开始 设置指定颜色的长度 </span></span><br><span class="line">[attributedString addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:[<span class="built_in">UIColor</span> blueColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">18</span>, <span class="number">3</span>)]; <span class="comment">//设置尺寸 </span></span><br><span class="line">[attributedString addAttribute:<span class="built_in">NSFontAttributeName</span> value:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">20</span>] range:<span class="built_in">NSMakeRange</span>(<span class="number">18</span>, <span class="number">3</span>)]; <span class="comment">// 0为起始位置 length是从起始位置开始 设置指定字体尺寸的长度</span></span><br></pre></td></tr></table></figure>

<p>根据字符串获取宽高<br>根据宽度求高度 content 计算的内容 width 计算的宽度 font字体大小</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">CGFloat</span>)getHeightWithContent:(<span class="built_in">NSString</span> *)content width:(<span class="built_in">CGFloat</span>)width font:(<span class="built_in">CGFloat</span>)font&#123; </span><br><span class="line"><span class="built_in">CGRect</span> rect = [content boundingRectWithSize:<span class="built_in">CGSizeMake</span>(width, <span class="number">999</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@&#123;</span><br><span class="line"><span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:font]&#125;  context:<span class="literal">nil</span>]; </span><br><span class="line"><span class="keyword">return</span> rect.size.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据高度度求宽度 content 计算的内容 Height 计算的高度 font字体大小</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">CGFloat</span>)getWidthWithContent:(<span class="built_in">NSString</span> *)content height:(<span class="built_in">CGFloat</span>)height font:(<span class="built_in">CGFloat</span>)font&#123; </span><br><span class="line"><span class="built_in">CGRect</span> rect = [content boundingRectWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">999</span>, height) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@&#123;</span><br><span class="line"><span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:font]&#125; context:<span class="literal">nil</span>]; </span><br><span class="line"><span class="keyword">return</span> rect.size.width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、更多属性"><a href="#3、更多属性" class="headerlink" title="3、更多属性"></a>3、更多属性</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">NSStrikethroughColorAttributeName 的时候，值也是这个枚举。</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlineStyleNone 不设置下划线／删除线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlineStyleSingle 设置下划线／删除线为细的单线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlineStyleThick 设置下划线／删除线为粗的单线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlineStyleDouble 设置下划线／删除线为细的双线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlinePatternSolid 设置下划线／删除线样式为连续的实线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlinePatternDot 设置下划线／删除线样式为点，也就是虚线，比如这样：－－－－－－</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlinePatterDash 设置下划线／删除线样式为破折号，比如这样：—— —— ——</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlinePatternDashDot 设置下划线／删除线样式为连续的破折号和点，比如这样：——－——－——－</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlinePatternDashDotDot 设置下划线／删除线样式为连续的破折号、点、点，比如：——－－——－－——－－</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSUnderlineByWord 在有空格的地方不设置下划线／删除线</span></span><br><span class="line">在设置以上属性时，可以以<span class="string">|分隔，同时设置多个属性</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发之多线程GCD</title>
    <url>/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD.html</url>
    <content><![CDATA[<h4 id="目前多线程主要分为三类："><a href="#目前多线程主要分为三类：" class="headerlink" title="目前多线程主要分为三类："></a>目前多线程主要分为三类：</h4><p> 1 NSThread<br> 2 NSOperation<br> 3 GCD<br>前面两种网上资料很多，本文就苹果推荐使用的GCD理一理。</p>
<h2 id="一、多线程相关概念"><a href="#一、多线程相关概念" class="headerlink" title="一、多线程相关概念"></a>一、多线程相关概念</h2><p>进程与线程的关系？</p>
<ul>
<li>进程：app打开的时候会打开相应的进程，一般情况下，一个App会有一个或多个进程，但是iOS的App一般只有一个进程（后台播放，IM除外）。在iOS系统中，打开一个新的App会挂起其他App的进程。一个进程会包含一个或多个线程。</li>
<li>线程：一个线程同时只可以执行一个任务，多线程就可以同时执行多个任务。一个进程可以包含多个线程。</li>
</ul>
<p>主线程和子线程（非主线程）到底有什么区别？</p>
<ul>
<li>主线程：iOS程序中，主线程（又叫作UI线程）主要任务是处理UI事件，显示和刷新UI，（只有主线程有直接修改UI的能力）耗时的操作放在子线程（又叫作后台线程、异步线程）。</li>
<li>子线程：在iOS中开子线程去处理耗时的操作，可以有效提高程序的执行效率，提高资源利用率。</li>
</ul>
<p>但是开启线程会占用一定的内存，（主线程的堆栈大小是1M，第二个线程开始都是512KB，并且该值不能通过编译器开关或线程API函数来更改）降低程序的性能。所以一般不要同时开很多线程。</p>
<p>注:查看当前线程信息用<strong>[NSThread currentThread]</strong>，而不要用<strong>[NSOperationQueue currentQueue]</strong>，因前者内容可以看到更全面的线程信息！</p>
<p>下面进入正题：</p>
<h2 id="二、GCD几个重要的关键字"><a href="#二、GCD几个重要的关键字" class="headerlink" title="二、GCD几个重要的关键字"></a>二、GCD几个重要的关键字</h2><h3 id="2-1、异步与同步"><a href="#2-1、异步与同步" class="headerlink" title="2.1、异步与同步"></a>2.1、异步与同步</h3><ul>
<li>异步执行：具备开新线程的能力，可以先绕过线程任务，回头再执行。</li>
<li>同步执行：不具备开新线程的能力，因此只能在当前线程中执行！任务执行必须按顺序执行（必须执行完当前任务才会继续走代码）。</li>
</ul>
<h3 id="2-2、并发队列与串行队列"><a href="#2-2、并发队列与串行队列" class="headerlink" title="2.2、并发队列与串行队列"></a>2.2、并发队列与串行队列</h3><ul>
<li>并发队列：队列中的任务同时执行(Concurrent Dispatch Queue)</li>
<li>串行队列：队列中的任务按添加任务顺序执行(Serial Dispatch Queue)</li>
</ul>
<p>注：这里说的任务就是GCD中block中的代码。</p>
<p>这里的关键字一般都是组合用，理解单个是没有意义的，组合后的效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-dbeb080ec6b0f86c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注：如果同步执行的时候，不放入新创建的线程中的话，就会在主线程执行。"></p>
<h3 id="2-3、同步的情况下需要注意"><a href="#2-3、同步的情况下需要注意" class="headerlink" title="2.3、同步的情况下需要注意"></a>2.3、同步的情况下需要注意</h3><p><strong>以下两种同步执行的情况都是在主线程执行的：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"abcd"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">//并发队列</span></span><br><span class="line"><span class="comment">//这里的abcd仅仅作为调试时用的标识符，打印线程属性时并不是name</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">10</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">11</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">12</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">13</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">54.797</span> 多线程GCD[<span class="number">80605</span>:<span class="number">13173361</span>] 执行：<span class="number">10</span> 线程信息：&lt;NSThread: <span class="number">0x600000073ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">57.342</span> 多线程GCD[<span class="number">80605</span>:<span class="number">13173361</span>] 执行：<span class="number">11</span> 线程信息：&lt;NSThread: <span class="number">0x600000073ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">59.681</span> 多线程GCD[<span class="number">80605</span>:<span class="number">13173361</span>] 执行：<span class="number">12</span> 线程信息：&lt;NSThread: <span class="number">0x600000073ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">39</span>:<span class="number">01.966</span> 多线程GCD[<span class="number">80605</span>:<span class="number">13173361</span>] 执行：<span class="number">13</span> 线程信息：&lt;NSThread: <span class="number">0x600000073ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"aa"</span>, DISPATCH_QUEUE_SERIAL);<span class="comment">//串行队列</span></span><br><span class="line"><span class="comment">//这里的DISPATCH_QUEUE_SERIAL等价于NULL</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">5</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">6</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">7</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> loadImage:@<span class="number">8</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">45</span>:<span class="number">30.928</span> 多线程GCD[<span class="number">81007</span>:<span class="number">13250389</span>] 执行：<span class="number">5</span> 线程信息：&lt;NSThread: <span class="number">0x600000065000</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">45</span>:<span class="number">37.232</span> 多线程GCD[<span class="number">81007</span>:<span class="number">13250389</span>] 执行：<span class="number">6</span> 线程信息：&lt;NSThread: <span class="number">0x600000065000</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">45</span>:<span class="number">39.713</span> 多线程GCD[<span class="number">81007</span>:<span class="number">13250389</span>] 执行：<span class="number">7</span> 线程信息：&lt;NSThread: <span class="number">0x600000065000</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">45</span>:<span class="number">42.314</span> 多线程GCD[<span class="number">81007</span>:<span class="number">13250389</span>] 执行：<span class="number">8</span> 线程信息：&lt;NSThread: <span class="number">0x600000065000</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正确的打开方式：</strong></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(<span class="string">"aa"</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;//串行队列</span></span><br><span class="line"></span><br><span class="line">dispatch_async(<span class="name">dispatch_queue_create</span>(<span class="string">"abcd"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">        [self loadImage:@<span class="number">5</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">        [self loadImage:@<span class="number">6</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">        [self loadImage:@<span class="number">7</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">        [self loadImage:@<span class="number">8</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">15.677</span> 多线程GCD[<span class="number">81128</span>:<span class="number">13270066</span>] 执行：<span class="number">5</span> 线程信息：&lt;NSThread: <span class="number">0x60800007e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">18.103</span> 多线程GCD[<span class="number">81128</span>:<span class="number">13270066</span>] 执行：<span class="number">6</span> 线程信息：&lt;NSThread: <span class="number">0x60800007e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">20.470</span> 多线程GCD[<span class="number">81128</span>:<span class="number">13270066</span>] 执行：<span class="number">7</span> 线程信息：&lt;NSThread: <span class="number">0x60800007e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">22.774</span> 多线程GCD[<span class="number">81128</span>:<span class="number">13270066</span>] 执行：<span class="number">8</span> 线程信息：&lt;NSThread: <span class="number">0x60800007e000</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上说的是同步的时候需要注意的，下面说一下异步的情况：</strong></p>
<h3 id="2-4、异步的情况下需要注意-1"><a href="#2-4、异步的情况下需要注意-1" class="headerlink" title="2.4、异步的情况下需要注意-1"></a>2.4、异步的情况下需要注意-1</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"aa"</span>, DISPATCH_QUEUE_SERIAL);<span class="comment">//串行队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">3</span>];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">14.498</span> 多线程GCD[<span class="number">81251</span>:<span class="number">13288476</span>] 执行：<span class="number">0</span> 线程信息：&lt;NSThread: <span class="number">0x600000262680</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">17.125</span> 多线程GCD[<span class="number">81251</span>:<span class="number">13288476</span>] 执行：<span class="number">1</span> 线程信息：&lt;NSThread: <span class="number">0x600000262680</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">19.599</span> 多线程GCD[<span class="number">81251</span>:<span class="number">13288476</span>] 执行：<span class="number">2</span> 线程信息：&lt;NSThread: <span class="number">0x600000262680</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">21.934</span> 多线程GCD[<span class="number">81251</span>:<span class="number">13288476</span>] 执行：<span class="number">3</span> 线程信息：&lt;NSThread: <span class="number">0x600000262680</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"abcd"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">//并发队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:@<span class="number">3</span>];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">06.805</span> 多线程GCD[<span class="number">81549</span>:<span class="number">13342819</span>] 执行：<span class="number">1</span> 线程信息：&lt;NSThread: <span class="number">0x608000072f80</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">06.805</span> 多线程GCD[<span class="number">81549</span>:<span class="number">13341379</span>] 执行：<span class="number">0</span> 线程信息：&lt;NSThread: <span class="number">0x60800007b200</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">06.805</span> 多线程GCD[<span class="number">81549</span>:<span class="number">13342821</span>] 执行：<span class="number">3</span> 线程信息：&lt;NSThread: <span class="number">0x6080000743c0</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">06.805</span> 多线程GCD[<span class="number">81549</span>:<span class="number">13342820</span>] 执行：<span class="number">2</span> 线程信息：&lt;NSThread: <span class="number">0x60000026a400</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>在串行队列异步执行过程中，会创建一个线程，按顺序执行当前线程中的任务。有阻塞！<br>在并发队列异步执行过程中，可能会创建多个线程，同时执行当前线程中的任务。没有阻塞！</p>
<h3 id="2-4、异步的情况下需要注意-2"><a href="#2-4、异步的情况下需要注意-2" class="headerlink" title="2.4、异步的情况下需要注意-2"></a>2.4、异步的情况下需要注意-2</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"aaa"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@0]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"bbb"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@1]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"ccc"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@2]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"ddd"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@3]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"eee"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@4]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">10.966</span> 多线程GCD[<span class="number">82282</span>:<span class="number">13469275</span>] 执行：<span class="number">2</span> 线程信息：&lt;NSThread: <span class="number">0x608000076100</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">10.966</span> 多线程GCD[<span class="number">82282</span>:<span class="number">13469905</span>] 执行：<span class="number">4</span> 线程信息：&lt;NSThread: <span class="number">0x6080000738c0</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">10.966</span> 多线程GCD[<span class="number">82282</span>:<span class="number">13469278</span>] 执行：<span class="number">3</span> 线程信息：&lt;NSThread: <span class="number">0x608000075b40</span>&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">10.966</span> 多线程GCD[<span class="number">82282</span>:<span class="number">13469331</span>] 执行：<span class="number">1</span> 线程信息：&lt;NSThread: <span class="number">0x600000076d00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">10.966</span> 多线程GCD[<span class="number">82282</span>:<span class="number">13469276</span>] 执行：<span class="number">0</span> 线程信息：&lt;NSThread: <span class="number">0x60800006dcc0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>以上会创建5个串行队列线程，而不是1个串行队列线程，因为不是同一个线程，所以执行顺序是同时执行，互相没有影响(对于并发队列是同样的)。<br>正确使用方法应该是1中创建的方式，对于并发队列，计算机会根据性能和需要创建合理的线程数量。保证系统高性能和流畅性。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"a"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@14]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"b"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@15]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"c"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@16]</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_queue_create(<span class="string">"d"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    <span class="selector-attr">[self loadImage:@17]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">51.193</span> 多线程GCD[<span class="number">82177</span>:<span class="number">13453338</span>] 执行：<span class="number">15</span> 线程信息：&lt;NSThread: <span class="number">0x608000263040</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">51.193</span> 多线程GCD[<span class="number">82177</span>:<span class="number">13449499</span>] 执行：<span class="number">14</span> 线程信息：&lt;NSThread: <span class="number">0x608000261580</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">51.193</span> 多线程GCD[<span class="number">82177</span>:<span class="number">13453339</span>] 执行：<span class="number">16</span> 线程信息：&lt;NSThread: <span class="number">0x608000272f00</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">51.193</span> 多线程GCD[<span class="number">82177</span>:<span class="number">13453340</span>] 执行：<span class="number">17</span> 线程信息：&lt;NSThread: <span class="number">0x60000026e740</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5、关键字-Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#2-5、关键字-Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="2.5、关键字 - Main Dispatch Queue/Global Dispatch Queue"></a>2.5、关键字 - Main Dispatch Queue/Global Dispatch Queue</h3><p>实际上不用特意生成Dispatch Queue，系统也会为我们准备几个。那就是Main Dispatch Queue和Global Dispatch Queue。</p>
<ul>
<li>Main Dispatch Queue就是主线程，因为主线程只有一个，所以Main Dispatch Queue是Serial Dispatch Queue。Main Dispatch Queue的处理在主线程的Runloop中执行。</li>
</ul>
<p>相应的，Global Dispatch Queue是系统为我们准备的Concurrent Dispatch Queue。Global Dispatch Queue有四个优先级，应根据需求使用对应优先级。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-8b89934a89887dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优先级.png"></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  high优先级的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t </span>globalHighQueue = <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, </span><span class="number">0</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  default优先级的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t </span>globalDefaultQueue = <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, </span><span class="number">0</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  low优先级的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t </span>globalLowQueue = <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, </span><span class="number">0</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  background优先级的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t </span>globalBackgroundQueue = <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, </span><span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>更改队列优先级：dispatch_set_target_queue(dispatch_object_t  _Nonnull object, dispatch_queue_t  _Nullable queue)</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t </span>serialQueue = <span class="keyword">dispatch_queue_create("aa", </span><span class="keyword">DISPATCH_QUEUE_SERIAL);//串行队列</span></span><br><span class="line"><span class="keyword"> </span>  </span><br><span class="line"><span class="keyword">dispatch_queue_t </span>globalBackgroundQueue = <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, </span><span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">dispatch_set_target_queue(serialQueue, </span>globalBackgroundQueue)<span class="comment">;将serialQueue指定为globalBackgroundQueue用。</span></span><br></pre></td></tr></table></figure>
<p>注：如果这里用函数dispatch_set_target_queue将多个Serial Dispatch Queue指定为同一个Serial Dispatch Queue，就会将原本并发的队列变更为串行队列。</p>
<h3 id="2-6、关键字-Dispatch-Group"><a href="#2-6、关键字-Dispatch-Group" class="headerlink" title="2.6、关键字 - Dispatch Group"></a>2.6、关键字 - Dispatch Group</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将原本在serialQueue中要执行的放在group里，后面可以加一个结束的回调（很多时候会有这种需求）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(<span class="keyword">group</span>, serialQueue, ^&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(<span class="keyword">group</span>, serialQueue, ^&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(<span class="keyword">group</span>, serialQueue, ^&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"done"</span>);<span class="comment">//执行完成后回调</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-7、关键字-dispatch-barrier-async-栅栏"><a href="#2-7、关键字-dispatch-barrier-async-栅栏" class="headerlink" title="2.7、关键字 - dispatch_barrier_async 栅栏"></a>2.7、关键字 - dispatch_barrier_async 栅栏</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(<span class="string">"abcd"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="regexp">//</span>并行队列</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [<span class="keyword">self</span> <span class="symbol">loadImage:</span><span class="variable">@0</span>];</span><br><span class="line">       /<span class="regexp">/读取数据0</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@1];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据1</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@2];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据2</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@3];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据3</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_barrier_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@4];</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/异步栅栏写入数据4</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_barrier_sync(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@4];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/同步栅栏写入数据4</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@5];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据5</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@6];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据6</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@7];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据7</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br><span class="line"><span class="regexp">   dispatch_async(concurrentQueue, ^&#123;</span></span><br><span class="line"><span class="regexp">       [self loadImage:@8];</span></span><br><span class="line"><span class="regexp">       /</span><span class="regexp">/读取数据8</span></span><br><span class="line"><span class="regexp">   &#125;);</span></span><br></pre></td></tr></table></figure>
<p>打印log：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">53.029</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543714</span>] 执行：<span class="number">2</span> 线程信息：&lt;NSThread: <span class="number">0x600000076d80</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">53.029</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543650</span>] 执行：<span class="number">0</span> 线程信息：&lt;NSThread: <span class="number">0x600000076d40</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">53.029</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543652</span>] 执行：<span class="number">1</span> 线程信息：&lt;NSThread: <span class="number">0x608000066940</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">53.029</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543715</span>] 执行：<span class="number">3</span> 线程信息：&lt;NSThread: <span class="number">0x608000071140</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">58.763</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13544668</span>] 异步栅栏执行：<span class="number">4</span> 线程信息：&lt;NSThread: <span class="number">0x6080000710c0</span>&gt;&#123;number = <span class="number">8</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">01.195</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13542941</span>] 同步栅栏执行：<span class="number">4</span> 线程信息：&lt;NSThread: <span class="number">0x600000066500</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">03.605</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543650</span>] 执行：<span class="number">7</span> 线程信息：&lt;NSThread: <span class="number">0x600000076d40</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">03.605</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13544677</span>] 执行：<span class="number">5</span> 线程信息：&lt;NSThread: <span class="number">0x608000074bc0</span>&gt;&#123;number = <span class="number">9</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">03.605</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13544668</span>] 执行：<span class="number">6</span> 线程信息：&lt;NSThread: <span class="number">0x6080000710c0</span>&gt;&#123;number = <span class="number">8</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-06</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">03.605</span> 多线程GCD[<span class="number">82699</span>:<span class="number">13543714</span>] 执行：<span class="number">8</span> 线程信息：&lt;NSThread: <span class="number">0x600000076d80</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>在读取数据时，有时候会出现数据竞争，数据安全问题，比如：当前的写入没有结束，读取操作就开始处理，导致数据错乱。或者读取正在进行，开始写入操作，导致程序崩溃等问题。<br>苹果为我们提供了一个便捷的参数：dispatch_barrier_async（栅栏）。<br><strong>作用</strong>：如上述代码中所表示，只有在1234操作完成时（无序），才会执行写入操作，只有当前写入操作结束后，才会继续向下执行。dispatch_barrier_sync也有同样的效果，但是如果不放入其他线程中的话，会在当前线程即主线程执行，会阻塞线程。</p>
<p><strong>注意</strong>：dispatch_barrier_async中如果使用全局队列的话，就相当于要等待全局队列里的所有并发任务执行完后，才会执行dispatch_barrier_async中的任务，这样会受其他在全局队列里任务的影响，达不到我们想要的效果。</p>
<h2 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h2><p> **<br>并发队列(Concurrent Dispatch Queue)  串行队列(Serial Dispatch Queue) ：<br>负责执行顺序！<br>异步执行 (dispatch_async)  同步执行 (dispatch_sync)：<br>负责选择线程执行！<br>**</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发系列-让你的应用“动”起来--Core-Animation</title>
    <url>/iOS%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97-%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%9C%E5%8A%A8%E2%80%9D%E8%B5%B7%E6%9D%A5-Core-Animation.html</url>
    <content><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>大家都知道在iOS中实现一个动画相当简单，只要调用UIView的块代码即可实现一个动画效果，这在其他系统开发中基本不可能实现。下面通过一个简单的UIView进行一个图片放大动画效果演示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"open2.png"</span>];</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">    imageView.frame=<span class="built_in">CGRectMake</span>(<span class="number">120</span>, <span class="number">140</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:imageView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两秒后开始一个持续一分钟的动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> delay:<span class="number">2</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:^&#123;</span><br><span class="line">        imageView.frame=<span class="built_in">CGRectMake</span>(<span class="number">80</span>, <span class="number">100</span>, <span class="number">160</span>, <span class="number">160</span>);</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用上面UIView封装的方法进行动画设置固然十分方便，但是具体动画如何实现我们是不清楚的，而且上面的代码还有一些问题是无法解决的，例如：如何控制动画的暂停？如何进行动画的组合？？？</p>
<p>这里就需要了解iOS的核心动画Core Animation（包含在Quartz Core框架中）。在iOS中核心动画分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-36092b5328dbce1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<blockquote>
<ul>
<li>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</li>
<li>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</li>
<li>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>CATransition：转场动画，主要通过滤镜进行动画效果设置。</li>
</ul>
</blockquote>
<ul>
<li>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</li>
</ul>
<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>
<h2 id="一、基础动画"><a href="#一、基础动画" class="headerlink" title="一、基础动画"></a>一、基础动画</h2><p>在开发过程中很多情况下通过基础动画就可以满足开发需求，前面例子中使用的UIView代码块进行图像放大缩小的演示动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>
<blockquote>
<ol>
<li>初始化动画并设置动画属性</li>
<li>设置动画属性初始值（可以省略）、结束值以及其他动画属性</li>
<li>给图层添加动画</li>
</ol>
</blockquote>
<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[<span class="built_in">CALayer</span> layer];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值和结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b9a0bf42a4083205.gif?imageMogr2/auto-orient/strip" alt></p>
<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置，当然是用UIView封装的方法是没有这个问题的。如何解决这个问题呢？</p>
<p>图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。当然解决这个问题方法比较多，这里不妨在动画完成之后重新设置它的位置。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()&lt;<span class="title">CAAnimationDelegate</span>&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值和结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation.delegate=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWithCGPoint:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 动画代理方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    _layer.position=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“KCBasicAnimationLocation”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。</p>
<p>如果运行上面的代码大家可能会发现另外一个问题，那就是动画运行完成后会重新从起始点运动到终点。这个问题产生的原因就是前面提到的，对于非根图层，设置图层的可动画属性（在动画结束后重新设置了position，而position是可动画属性）会产生动画效果。解决这个问题有两种办法：关闭图层隐式动画、设置动画图层为根图层。显然这里不能采取后者，因为根图层当前已经作为动画的背景。</p>
<p>要关闭隐式动画需要用到动画事务CATransaction，在事务内将隐式动画关闭，例如上面的代码可以改为：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然上面的动画还显得有些生硬，因为落花飘散的时候可能不仅仅是自由落体运动，本身由于空气阻力、外界风力还会造成落花在空中的旋转、摇摆等，这里不妨给图层添加一个旋转的动画。对于图层的旋转通过key path设置图层旋转的内容，在这里需要强调一下，图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.anchorPoint=<span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.6</span>);<span class="comment">//设置锚点</span></span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation.delegate=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWithCGPoint:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 旋转动画</span></span><br><span class="line">-(<span class="keyword">void</span>)rotationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">6.0</span>;</span><br><span class="line">    basicAnimation.autoreverses=<span class="literal">true</span>;<span class="comment">//旋转后再旋转到原来的位置</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Rotation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 动画代理方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面代码中结合两种动画操作，需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>
<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>
<p>下面的代码演示了移动动画结束后旋转动画暂停，并且当再次点击动画时旋转恢复的过程(注意在移动过程中如果再次点击屏幕可以暂停移动和旋转动画，再次点击可以恢复两种动画。但是当移动结束后触发了移动动画的完成事件如果再次点击屏幕则只能恢复旋转动画，因为此时移动动画已经结束而不是暂停，无法再恢复)。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.anchorPoint=<span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.6</span>);<span class="comment">//设置锚点</span></span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    basicAnimation.removedOnCompletion=<span class="literal">NO</span>;<span class="comment">//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation.delegate=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWithCGPoint:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 旋转动画</span></span><br><span class="line">-(<span class="keyword">void</span>)rotationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line">    <span class="comment">//basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span></span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation.duration=<span class="number">6.0</span>;</span><br><span class="line">    basicAnimation.autoreverses=<span class="literal">true</span>;<span class="comment">//旋转后在旋转到原来的位置</span></span><br><span class="line">    basicAnimation.repeatCount=HUGE_VALF;<span class="comment">//设置无限循环</span></span><br><span class="line">    basicAnimation.removedOnCompletion=<span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//basicAnimation.delegate=self;</span></span><br><span class="line">    <span class="comment">//4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Rotation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//判断是否已经创建过动画，如果已经创建则不再创建动画</span></span><br><span class="line">    <span class="built_in">CAAnimation</span> *animation= [_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">    <span class="keyword">if</span>(animation)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_layer.speed==<span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> animationResume];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [<span class="keyword">self</span> animationPause];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//创建并开始动画</span></span><br><span class="line">        [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画暂停</span></span><br><span class="line">-(<span class="keyword">void</span>)animationPause&#123;</span><br><span class="line">    <span class="comment">//取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> interval=[_layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//设置时间偏移量，保证暂停时停留在旋转的位置</span></span><br><span class="line">    [_layer setTimeOffset:interval];</span><br><span class="line">    <span class="comment">//速度设置为0，暂停动画</span></span><br><span class="line">    _layer.speed=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画恢复</span></span><br><span class="line">-(<span class="keyword">void</span>)animationResume&#123;</span><br><span class="line">    <span class="comment">//获得暂停的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> beginTime= <span class="built_in">CACurrentMediaTime</span>()- _layer.timeOffset;</span><br><span class="line">    <span class="comment">//设置偏移量</span></span><br><span class="line">    _layer.timeOffset=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置开始时间</span></span><br><span class="line">    _layer.beginTime=beginTime;</span><br><span class="line">    <span class="comment">//设置动画速度，开始运动</span></span><br><span class="line">    _layer.speed=<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 动画代理方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer.frame));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停动画</span></span><br><span class="line">    [<span class="keyword">self</span> animationPause];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-f627e183ce0a4381.gif?imageMogr2/auto-orient/strip" alt></p>
<blockquote>
<p>注意：<br>动画暂停针对的是图层而不是图层中的某个动画。<br>要做无限循环的动画，动画的removedOnCompletion属性必须设置为NO，否则运行一次动画就会销毁。</p>
</blockquote>
<h2 id="二、关键帧动画"><a href="#二、关键帧动画" class="headerlink" title="二、关键帧动画"></a>二、关键帧动画</h2><p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>
<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>
<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。假设下落过程如图：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-c4ffa126403764fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>在这里需要设置四个关键帧（如图中四个关键点），具体代码如下（动画创建过程同基本动画基本完全一致）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 关键帧动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建关键帧动画并设置动画属性</span></span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置关键帧,这里有四个关键帧</span></span><br><span class="line">    <span class="built_in">NSValue</span> *key1=[<span class="built_in">NSValue</span> valueWithCGPoint:_layer.position];<span class="comment">//对于关键帧动画初始值不能省略</span></span><br><span class="line">    <span class="built_in">NSValue</span> *key2=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">80</span>, <span class="number">220</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *key3=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">45</span>, <span class="number">300</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *key4=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">55</span>, <span class="number">400</span>)];</span><br><span class="line">    <span class="built_in">NSArray</span> *values=@[key1,key2,key3,key4];</span><br><span class="line">    keyframeAnimation.values=values;</span><br><span class="line">    <span class="comment">//设置其他属性</span></span><br><span class="line">    keyframeAnimation.duration=<span class="number">8.0</span>;</span><br><span class="line">    keyframeAnimation.beginTime=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">2</span>;<span class="comment">//设置延迟2秒执行</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，添加动画后就会执行动画</span></span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:<span class="string">@"KCKeyframeAnimation_Position"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-941247dd1569c6df.gif?imageMogr2/auto-orient/strip" alt><br>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着下面的曲线路径飘落：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b4e8e00aa8a85236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>当然，这是一条贝塞尔曲线，学习了前篇文章之后相信对于这类曲线应该并不陌生，下面是具体实现代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 关键帧动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建关键帧动画并设置动画属性</span></span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置路径</span></span><br><span class="line">    <span class="comment">//绘制贝塞尔曲线</span></span><br><span class="line">    <span class="built_in">CGPathRef</span> path=<span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, _layer.position.x, _layer.position.y);<span class="comment">//移动到起始点</span></span><br><span class="line">    <span class="built_in">CGPathAddCurveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">160</span>, <span class="number">280</span>, <span class="number">-30</span>, <span class="number">300</span>, <span class="number">55</span>, <span class="number">400</span>);<span class="comment">//绘制二次贝塞尔曲线</span></span><br><span class="line"></span><br><span class="line">    keyframeAnimation.path=path;<span class="comment">//设置path属性</span></span><br><span class="line">    <span class="built_in">CGPathRelease</span>(path);<span class="comment">//释放路径对象</span></span><br><span class="line">    <span class="comment">//设置其他属性</span></span><br><span class="line">    keyframeAnimation.duration=<span class="number">8.0</span>;</span><br><span class="line">    keyframeAnimation.beginTime=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">5</span>;<span class="comment">//设置延迟2秒执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，添加动画后就会执行动画</span></span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:<span class="string">@"KCKeyframeAnimation_Position"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-2d9d35fbcc89e9a8.gif?imageMogr2/auto-orient/strip" alt></p>
<p>看起来动画不会那么生硬了，但是这里需要注意，对于路径类型的关键帧动画系统是从描绘路径的位置开始路径，直到路径结束。如果上面的路径不是贝塞尔曲线而是矩形路径那么它会从矩形的左上角开始运行，顺时针一周回到左上角；如果指定的路径是一个椭圆，那么动画运行的路径是从椭圆右侧开始（0度）顺时针一周回到右侧。</p>
<h3 id="补充–其他属性"><a href="#补充–其他属性" class="headerlink" title="补充–其他属性"></a>补充–其他属性</h3><p>在关键帧动画中还有一些动画属性初学者往往比较容易混淆，这里专门针对这些属性做一下介绍。</p>
<p>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</p>
<p>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</p>
<p>下图描绘出了几种动画模式的关系（横坐标是运行时间，纵坐标是动画属性[例如位置、透明度等]）：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-dd25d87f7b76f972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="三、动画组"><a href="#三、动画组" class="headerlink" title="三、动画组"></a>三、动画组</h2><p>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>
<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>
<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>].CGImage;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> groupAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 基础旋转动画</span></span><br><span class="line">-(<span class="built_in">CABasicAnimation</span> *)rotationAnimation&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> toValue=M_PI_2*<span class="number">3</span>;</span><br><span class="line">    basicAnimation.toValue=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//basicAnimation.duration=6.0;</span></span><br><span class="line">    basicAnimation.autoreverses=<span class="literal">true</span>;</span><br><span class="line">    basicAnimation.repeatCount=HUGE_VALF;</span><br><span class="line">    basicAnimation.removedOnCompletion=<span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSNumber</span> numberWithFloat:toValue] forKey:<span class="string">@"KCBasicAnimationProperty_ToValue"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> basicAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 关键帧移动动画</span></span><br><span class="line">-(<span class="built_in">CAKeyframeAnimation</span> *)translationAnimation&#123;</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> endPoint= <span class="built_in">CGPointMake</span>(<span class="number">55</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="built_in">CGPathRef</span> path=<span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, _layer.position.x, _layer.position.y);</span><br><span class="line">    <span class="built_in">CGPathAddCurveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">160</span>, <span class="number">280</span>, <span class="number">-30</span>, <span class="number">300</span>, endPoint.x, endPoint.y);</span><br><span class="line">    </span><br><span class="line">    keyframeAnimation.path=path;</span><br><span class="line">    <span class="built_in">CGPathRelease</span>(path);</span><br><span class="line"></span><br><span class="line">    [keyframeAnimation setValue:[<span class="built_in">NSValue</span> valueWithCGPoint:endPoint] forKey:<span class="string">@"KCKeyframeAnimationProperty_EndPosition"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> keyframeAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 创建动画组</span></span><br><span class="line">-(<span class="keyword">void</span>)groupAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画组</span></span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *animationGroup=[<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置组中的动画和其他属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="keyword">self</span> translationAnimation];</span><br><span class="line">    animationGroup.animations=@[basicAnimation,keyframeAnimation];</span><br><span class="line">    </span><br><span class="line">    animationGroup.delegate=<span class="keyword">self</span>;</span><br><span class="line">    animationGroup.duration=<span class="number">10.0</span>;<span class="comment">//设置动画时间，如果动画组中动画已经设置过动画属性则不再生效</span></span><br><span class="line">    animationGroup.beginTime=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">5</span>;<span class="comment">//延迟五秒执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.给图层添加动画</span></span><br><span class="line">    [_layer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 代理方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 动画完成</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *animationGroup=(<span class="built_in">CAAnimationGroup</span> *)anim;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=animationGroup.animations[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=animationGroup.animations[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> toValue=[[basicAnimation valueForKey:<span class="string">@"KCBasicAnimationProperty_ToValue"</span>] floatValue];</span><br><span class="line">    <span class="built_in">CGPoint</span> endPoint=[[keyframeAnimation valueForKey:<span class="string">@"KCKeyframeAnimationProperty_EndPosition"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置动画最终状态</span></span><br><span class="line">    _layer.position=endPoint;</span><br><span class="line">    _layer.transform=<span class="built_in">CATransform3DMakeRotation</span>(toValue, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-f92b3b46d64b191c.gif?imageMogr2/auto-orient/strip" alt></p>
<h2 id="四、转场动画"><a href="#四、转场动画" class="headerlink" title="四、转场动画"></a>四、转场动画</h2><p>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>
<ol>
<li><p>创建转场动画</p>
</li>
<li><p>设置转场类型、子类型（可选）及其他属性</p>
</li>
<li><p>设置转场后的新视图并添加动画到图层</p>
</li>
</ol>
<p>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<table>
<thead>
<tr>
<th>动画类型</th>
<th align="center">说明</th>
<th align="center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody><tr>
<td>公开API</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>fade</td>
<td align="center">淡出效果</td>
<td align="center">kCATransitionFade</td>
<td>是</td>
</tr>
<tr>
<td>movein</td>
<td align="center">新视图移动到旧视图上</td>
<td align="center">kCATransitionMoveIn</td>
<td>是</td>
</tr>
<tr>
<td>push</td>
<td align="center">新视图推出旧视图</td>
<td align="center">kCATransitionPush</td>
<td>是</td>
</tr>
<tr>
<td>reveal</td>
<td align="center">移开旧视图显示新视图</td>
<td align="center">kCATransitionReveal</td>
<td>是</td>
</tr>
<tr>
<td>私有API</td>
<td align="center"></td>
<td align="center">私有API只能通过字符串访问</td>
<td></td>
</tr>
<tr>
<td>cube</td>
<td align="center">立方体翻转效果</td>
<td align="center">无</td>
<td>是</td>
</tr>
<tr>
<td>oglFlip</td>
<td align="center">翻转效果</td>
<td align="center">无</td>
<td>是</td>
</tr>
<tr>
<td>suckEffect</td>
<td align="center">收缩效果</td>
<td align="center">无</td>
<td>否</td>
</tr>
<tr>
<td>rippleEffect</td>
<td align="center">水滴波纹效果</td>
<td align="center">无</td>
<td>否</td>
</tr>
<tr>
<td>pageCurl</td>
<td align="center">向上翻页效果</td>
<td align="center">无</td>
<td>是</td>
</tr>
<tr>
<td>pageUnCurl</td>
<td align="center">向下翻页效果</td>
<td align="center">无</td>
<td>是</td>
</tr>
<tr>
<td>cameralIrisHollowOpen</td>
<td align="center">摄像头打开效果</td>
<td align="center">无</td>
<td>否</td>
</tr>
<tr>
<td>cameraIrisHollowClose</td>
<td align="center">摄像头关闭效果</td>
<td align="center">无</td>
<td>否</td>
</tr>
</tbody></table>
<p>另外对于支持方向设置的动画类型还包含子类型：</p>
<table>
<thead>
<tr>
<th align="left">动画子类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">kCATransitionFromRight</td>
<td align="center">从右侧转场</td>
</tr>
<tr>
<td align="left">kCATransitionFromLeft</td>
<td align="center">从左侧转场</td>
</tr>
<tr>
<td align="left">kCATransitionFromTop</td>
<td align="center">从顶部转场</td>
</tr>
<tr>
<td align="left">kCATransitionFromBottom</td>
<td align="center">从底部转场</td>
</tr>
<tr>
<td align="left">使用转场动画利用一个UIImageView实现一个漂亮的无限循环图片浏览器:</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">    <span class="keyword">int</span> _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义图片控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    _imageView.frame=[<span class="built_in">UIScreen</span> mainScreen].bounds;</span><br><span class="line">    _imageView.contentMode=<span class="built_in">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">    _imageView.image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"0.jpg"</span>];<span class="comment">//默认图片</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</span><br><span class="line">    <span class="comment">//添加手势</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *leftSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture.direction=<span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *rightSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture.direction=<span class="built_in">UISwipeGestureRecognizerDirectionRight</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 向左滑动浏览下一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)leftSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 向右滑动浏览上一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)rightSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 转场动画</span></span><br><span class="line">-(<span class="keyword">void</span>)transitionAnimation:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="comment">//1.创建转场动画对象</span></span><br><span class="line">    <span class="built_in">CATransition</span> *transition=[[<span class="built_in">CATransition</span> alloc]init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画类型,注意对于苹果官方没公开的动画类型只能使用字符串，并没有对应的常量定义</span></span><br><span class="line">    transition.type=<span class="string">@"cube"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置子类型</span></span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        transition.subtype=kCATransitionFromRight;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        transition.subtype=kCATransitionFromLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置动画时常</span></span><br><span class="line">    transition.duration=<span class="number">1.0</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置转场后的新视图添加转场动画</span></span><br><span class="line">    _imageView.image=[<span class="keyword">self</span> getImage:isNext];</span><br><span class="line">    [_imageView.layer addAnimation:transition forKey:<span class="string">@"KCTransitionAnimation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 取得当前图片</span></span><br><span class="line">-(<span class="built_in">UIImage</span> *)getImage:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _currentIndex=(_currentIndex<span class="number">-1</span>+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%i.jpg"</span>,_currentIndex];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-ba1b6c3e258a2592.gif?imageMogr2/auto-orient/strip" alt></p>
<p>代码十分简单，但是效果和性能却很惊人。当然演示代码有限，其他动画类型大家可以自己实现，效果都很绚丽。</p>
<h2 id="五、逐帧动画"><a href="#五、逐帧动画" class="headerlink" title="五、逐帧动画"></a>五、逐帧动画</h2><p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。当然，也许有朋友会想到利用iOS的定时器NSTimer定时更新图片来达到逐帧动画的效果。这种方式确实可以解决UIImageView一次性加载大量图片的问题，而且让播放过程可控，唯一的缺点就是定时器方法调用有时可能会因为当前系统执行某种比较占用时间的任务造成动画连续性出现问题。</p>
<p>虽然在核心动画没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>
<p>iOS程序在运行后就进入一个消息循环中（这个消息循环称为“主运行循环”），整个程序相当于进入一个死循环中，始终等待用户输入。将CADisplayLink加入到主运行循环队列后，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>
<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_COUNT 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="keyword">self</span>.view.layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bg.png"</span>].CGImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图像显示图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">87</span>, <span class="number">32</span>);</span><br><span class="line">    _layer.position=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">284</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于鱼的图片在循环中会不断创建，而10张鱼的照片相对都很小</span></span><br><span class="line">    <span class="comment">//与其在循环中不断创建UIImage不如直接将10张图片缓存起来</span></span><br><span class="line">    _images=[<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fish%i.png"</span>,i];</span><br><span class="line">        <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">        [_images addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义时钟对象</span></span><br><span class="line">    <span class="built_in">CADisplayLink</span> *displayLink=[<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(step)];</span><br><span class="line">    <span class="comment">//添加时钟对象到主运行循环</span></span><br><span class="line">    [displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 每次屏幕刷新就会执行一次此方法(每秒接近60次)</span></span><br><span class="line">-(<span class="keyword">void</span>)step&#123;</span><br><span class="line">    <span class="comment">//定义一个变量记录执行次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每秒执行6次</span></span><br><span class="line">    <span class="keyword">if</span> (++s%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image=_images[_index];</span><br><span class="line">        _layer.contents=(<span class="keyword">id</span>)image.CGImage;<span class="comment">//更新图片</span></span><br><span class="line">        _index=(_index+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-9e8bf685bb3c9e6a.gif?imageMogr2/auto-orient/strip" alt></p>
<p>注意：上面仅仅演示了逐帧动画的过程，事实上结合其他动画类型可以让整条鱼游动起来，这里不再赘述。</p>
<h2 id="六、UIView动画封装"><a href="#六、UIView动画封装" class="headerlink" title="六、UIView动画封装"></a>六、UIView动画封装</h2><p>有了前面核心动画的知识，相信大家开发出一般的动画效果应该不在话下。在核心动画开篇也给大家说过，其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。由于前面核心动画内容已经进行过详细介绍，学习UIView的封装方法根本是小菜一碟，这里对于一些细节就不再赘述了。</p>
<h3 id="6-1、基础动画"><a href="#6-1、基础动画" class="headerlink" title="6.1、基础动画"></a>6.1、基础动画</h3><p>基础动画部分和前面的基础动画演示相对应，演示点击屏幕落叶飘落到鼠标点击位置的过程。注意根据前面介绍的隐式动画知识其实非根图层直接设置终点位置不需要使用UIView的动画方法也可以实现动画效果，因此这里落花不再放到图层中而是放到了一个UIImageView中。</p>
<p>下面的代码演示了通过block和静态方法实现动画控制的过程：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]];</span><br><span class="line">    _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//方法1：block方式</span></span><br><span class="line">    <span class="comment">/*开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理</span></span><br><span class="line"><span class="comment">     duration:执行时间</span></span><br><span class="line"><span class="comment">     delay:延迟时间</span></span><br><span class="line"><span class="comment">     options:动画设置，例如自动恢复、匀速运动等</span></span><br><span class="line"><span class="comment">     completion:动画完成回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//    [UIView animateWithDuration:5.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^&#123;</span></span><br><span class="line">    <span class="comment">//        _imageView.center=location;</span></span><br><span class="line">    <span class="comment">//    &#125; completion:^(BOOL finished) &#123;</span></span><br><span class="line">    <span class="comment">//        NSLog(@"Animation end.");</span></span><br><span class="line">    <span class="comment">//    &#125;];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：静态方法,较方法1好些</span></span><br><span class="line">    <span class="comment">//开始动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="string">@"KCBasicAnimation"</span> context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">5.0</span>];</span><br><span class="line">    <span class="comment">//[UIView setAnimationDelay:1.0];//设置延迟</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationRepeatAutoreverses:NO];//是否回复</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationRepeatCount:10];//重复次数</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationStartDate:(NSDate *)];//设置动画开始运行的时间</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationDelegate:self];//设置代理</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法</span></span><br><span class="line">    </span><br><span class="line">    _imageView.center=location;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2、弹簧动画效果"><a href="#6-2、弹簧动画效果" class="headerlink" title="6.2、弹簧动画效果"></a>6.2、弹簧动画效果</h3><p>由于在iOS开发中弹性动画使用很普遍，所以在iOS7苹果官方直接提供了一个方法用于弹性动画开发，下面简单的演示一下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ball.png"</span>]];</span><br><span class="line">    _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">50</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches.anyObject;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">/*创建弹性动画</span></span><br><span class="line"><span class="comment">     damping:阻尼，范围0-1，值越小阻尼越小，阻尼越接近于0，弹性效果越明显</span></span><br><span class="line"><span class="comment">     velocity:弹性复位的速度，越大速度越快</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">5.0</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.1</span> initialSpringVelocity:<span class="number">1.0</span> options:<span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">        _imageView.center=location; <span class="comment">//CGPointMake(160, 284);</span></span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-b62d4a6cfeaa9344.gif?imageMogr2/auto-orient/strip" alt></p>
<p><strong>补充–动画设置参数</strong></p>
<p>在动画方法中有一个option参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，可以组合使用：</p>
<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>
<blockquote>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。<br>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。<br>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
</blockquote>
</li>
<li><p>动画速度控制（可从其中选择一个设置）</p>
<blockquote>
<p>UIViewAnimationOptionCurveEaseInOut：动画开始缓慢，中间快，结束慢。<br>UIViewAnimationOptionCurveEaseIn ：动画开始慢，之后逐渐加速。<br>UIViewAnimationOptionCurveEaseOut：动画开始快，之后逐渐变慢。<br>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</p>
</blockquote>
</li>
<li><p>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）</p>
<blockquote>
<p>UIViewAnimationOptionTransitionNone：没有转场动画效果。<br>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。<br>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。<br>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。<br>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。<br>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</p>
</blockquote>
</li>
</ol>
<h3 id="6-3、关键帧动画"><a href="#6-3、关键帧动画" class="headerlink" title="6.3、关键帧动画"></a>6.3、关键帧动画</h3><p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]];</span><br><span class="line">    _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="comment">//UITouch *touch=touches.anyObject;</span></span><br><span class="line">    <span class="comment">//CGPoint location= [touch locationInView:self.view];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*关键帧动画</span></span><br><span class="line"><span class="comment">     options:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">5.0</span> delay:<span class="number">0</span> options: <span class="built_in">UIViewKeyframeAnimationOptionCalculationModeLinear</span> animations:^&#123;</span><br><span class="line">        <span class="comment">//第二个关键帧（准确的说第一个关键帧是开始位置）:从0秒开始持续50%的时间，也就是5.0*0.5=2.5秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.0</span> relativeDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">            _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">80.0</span>, <span class="number">220.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//第三个关键帧，从0.5*5.0秒开始，持续5.0*0.25=1.25秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.5</span> relativeDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">            _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">45.0</span>, <span class="number">300.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//第四个关键帧：从0.75*5.0秒开始，持所需5.0*0.25=1.25秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.75</span> relativeDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">            _imageView.center=<span class="built_in">CGPointMake</span>(<span class="number">55.0</span>, <span class="number">400.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Animation end."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>补充–动画设置参数</strong></p>
<p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>
<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>
<blockquote>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
</blockquote>
</li>
<li><p>动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>
<blockquote>
<p>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeDiscrete ：离散运算模式。<br>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</p>
</blockquote>
</li>
</ol>
<p><strong>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</strong></p>
<h3 id="6-4、转场动画"><a href="#6-4、转场动画" class="headerlink" title="6.4、转场动画"></a>6.4、转场动画</h3><p>从iOS4.0开始，UIView直接封装了转场动画，使用起来同样很简单。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">    <span class="keyword">int</span> _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义图片控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    _imageView.frame=[<span class="built_in">UIScreen</span> mainScreen].bounds;</span><br><span class="line">    _imageView.contentMode=<span class="built_in">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">    _imageView.image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"0.jpg"</span>];<span class="comment">//默认图片</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</span><br><span class="line">    <span class="comment">//添加手势</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *leftSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture.direction=<span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *rightSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture.direction=<span class="built_in">UISwipeGestureRecognizerDirectionRight</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 向左滑动浏览下一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)leftSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 向右滑动浏览上一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)rightSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 转场动画</span></span><br><span class="line">-(<span class="keyword">void</span>)transitionAnimation:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationOptions</span> option;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        option=<span class="built_in">UIViewAnimationOptionCurveLinear</span>|<span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        option=<span class="built_in">UIViewAnimationOptionCurveLinear</span>|<span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> transitionWithView:_imageView duration:<span class="number">1.0</span> options:option animations:^&#123;</span><br><span class="line">        _imageView.image=[<span class="keyword">self</span> getImage:isNext];</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 取得当前图片</span></span><br><span class="line">-(<span class="built_in">UIImage</span> *)getImage:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _currentIndex=(_currentIndex<span class="number">-1</span>+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%i.jpg"</span>,_currentIndex];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的转场动画演示中，其实仅仅有一个视图UIImageView做转场动画，每次转场通过切换UIImageView的内容而已。如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span>*)fromView toView:(<span class="built_in">UIView</span>*)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0)</span><br></pre></td></tr></table></figure>
<p>方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过UIViewAnimationOptionShowHideTransitionViews参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>
<p><strong>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</strong></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>layer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发系列-让你的应用“动”起来--CALayer</title>
    <url>/iOS%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97-%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%9C%E5%8A%A8%E2%80%9D%E8%B5%B7%E6%9D%A5-CALayer.html</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>在iOS中随处都可以看到绚丽的动画效果，实现这些动画的过程并不复杂，今天将带大家一窥iOS动画全貌。在这里你可以看到iOS中如何使用图层精简非交互式绘图，如何通过核心动画创建基础动画、关键帧动画、动画组、转场动画，如何通过UIView的装饰方法对这些动画操作进行简化等。在今天的文章里您可以看到动画操作在iOS中是如何简单和高效，很多原来想做但是苦于没有思路的动画在iOS中将变得越发简单：</p>
<blockquote>
<ul>
<li>CALayer:<ul>
<li>CALayer简介</li>
<li>CALayer常用属性</li>
<li>CALayer绘图</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h1><h2 id="1-CALayer简介"><a href="#1-CALayer简介" class="headerlink" title="1. CALayer简介"></a>1. CALayer简介</h2><p>在介绍动画操作之前我们必须先来了解一个动画中常用的对象CALayer。CALayer包含在QuartzCore框架中，这是一个跨平台的框架，既可以用在iOS中又可以用在Mac OS X中。在使用Core Animation开发动画的本质就是将CALayer中的内容转化为位图从而供硬件操作，所以要熟练掌握动画操作必须先来熟悉CALayer。</p>
<p>使用Quartz 2D绘图时大家其实已经用到了CALayer，当利用drawRect:方法绘图的本质就是绘制到了UIView的layer（属性）中，可是这个过程大家在上一节中根本体会不到。但是在Core Animation中我们操作更多的则不再是UIView而是直接面对CALayer。下图描绘了CALayer和UIView的关系，在UIView中有一个layer属性作为根图层，根图层上可以放其他子图层，在UIView中所有能够看到的内容都包含在layer中：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-1436b711fc0fd157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h2 id="2-CALayer常用属性"><a href="#2-CALayer常用属性" class="headerlink" title="2. CALayer常用属性"></a>2. CALayer常用属性</h2><p>在iOS中CALayer的设计主要是了为了内容展示和动画操作，CALayer本身并不包含在UIKit中，它不能响应事件。由于CALayer在设计之初就考虑它的动画操作功能，CALayer很多属性在修改时都能形成动画效果，这种属性称为“隐式动画属性”。但是对于UIView的根图层而言属性的修改并不形成动画效果，因为很多情况下根图层更多的充当容器的做用，如果它的属性变动形成动画效果会直接影响子图层。另外，UIView的根图层创建工作完全由iOS负责完成，无法重新创建，但是可以往根图层中添加子图层或移除子图层。</p>
<p>下表列出了CALayer常用的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th>说明</th>
<th align="center">是否支持隐式动画</th>
</tr>
</thead>
<tbody><tr>
<td align="center">anchorPoint</td>
<td>和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">backgroundColor</td>
<td>图层背景颜色</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">borderColor</td>
<td>边框颜色</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">borderWidth</td>
<td>边框宽度</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">bounds</td>
<td>图层大小</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">contents</td>
<td>图层显示内容，例如可以将图片作为图层内容显示</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">contentsRect</td>
<td>图层显示内容的大小和位置</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">cornerRadius</td>
<td>圆角半径</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">doubleSided</td>
<td>图层背面是否显示，默认为YES</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">frame</td>
<td>图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">hidden</td>
<td>是否隐藏</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">mask</td>
<td>图层蒙版</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">maskToBounds</td>
<td>子图层是否剪切图层边界，默认为NO</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">opacity</td>
<td>透明度 ，类似于UIView的alpha</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">position</td>
<td>图层中心点位置，类似于UIView的center</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">shadowColor</td>
<td>阴影颜色</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">shadowOffset</td>
<td>阴影偏移量</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">shadowOpacity</td>
<td>阴影透明度，注意默认为0，如果设置阴影必须设置此属性</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">shadowPath</td>
<td>阴影的形状</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">shadowRadius</td>
<td>阴影模糊半径</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">sublayers</td>
<td>子图层</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">sublayerTransform</td>
<td>子图层形变</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">transform</td>
<td>图层形变</td>
<td align="center">是</td>
</tr>
</tbody></table>
<ul>
<li>隐式属性动画的本质是这些属性的变动默认隐含了CABasicAnimation动画实现，详情大家可以参照Xcode帮助文档中“Animatable Properties”一节。</li>
<li>在CALayer中很少使用frame属性，因为frame本身不支持动画效果，通常使用bounds和position代替。</li>
<li>CALayer中透明度使用opacity表示而不是alpha；中心点使用position表示而不是center。</li>
<li>anchorPoint属性是图层的锚点，范围在（0<del>1,0</del>1）表示在x、y轴的比例，这个点永远可以同position（中心点）重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合）</li>
</ul>
<p>为了进一步说明anchorPoint的作用，假设有一个层大小100*100，现在中心点位置（50,50），由此可以得出frame（0,0,100,100）。上面说过anchorPoint默认为（0.5,0.5），同中心点position重合，此时使用图形描述如图1；当修改anchorPoint为（0,0），此时锚点处于图层左上角，但是中心点poition并不会改变，因此图层会向右下角移动，如图2；然后修改anchorPoint为（1,1,），position还是保持位置不变，锚点处于图层右下角，此时图层如图3。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-cab9986817414c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>下面通过一个简单的例子演示一下上面几个属性，程序初始化阶段我们定义一个正方形，但是圆角路径调整为正方形边长的一半，使其看起来是一个圆形，在点击屏幕的时候修改图层的属性形成动画效果（注意在程序中没有直接修改UIView的layer属性，因为根图层无法形成动画效果）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 50</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	[<span class="keyword">self</span> drawMyLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 绘制图层</span></span><br><span class="line">-(<span class="keyword">void</span>)drawMyLayer&#123;</span><br><span class="line">	<span class="built_in">CGSize</span> size=[<span class="built_in">UIScreen</span> mainScreen].bounds.size;</span><br><span class="line">	<span class="comment">//获得根图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	<span class="comment">//设置背景颜色,由于QuartzCore是跨平台框架，无法直接使用UIColor</span></span><br><span class="line">	layer.backgroundColor=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span> green:<span class="number">146</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">	<span class="comment">//设置中心点</span></span><br><span class="line">	layer.position=<span class="built_in">CGPointMake</span>(size.width/<span class="number">2</span>, size.height/<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//设置大小</span></span><br><span class="line">	layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, WIDTH,WIDTH);</span><br><span class="line">	<span class="comment">//设置圆角,当圆角半径等于矩形的一半时看起来就是一个圆形</span></span><br><span class="line">	layer.cornerRadius=WIDTH/<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//设置阴影</span></span><br><span class="line">	layer.shadowColor=[<span class="built_in">UIColor</span> grayColor].CGColor;</span><br><span class="line">	layer.shadowOffset=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	layer.shadowOpacity=<span class="number">.9</span>;</span><br><span class="line">	<span class="comment">//设置边框</span></span><br><span class="line">	<span class="comment">//    layer.borderColor=[UIColor whiteColor].CGColor;</span></span><br><span class="line">	<span class="comment">//    layer.borderWidth=1;</span></span><br><span class="line">	<span class="comment">//   设置锚点</span></span><br><span class="line">	<span class="comment">//    layer.anchorPoint=CGPointZero;</span></span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 点击放大</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">UITouch</span> *touch=[touches anyObject];</span><br><span class="line">	<span class="built_in">CALayer</span> *layer=<span class="keyword">self</span>.view.layer.sublayers[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">CGFloat</span> width=layer.bounds.size.width;</span><br><span class="line">	<span class="keyword">if</span> (width==WIDTH) &#123;</span><br><span class="line">	width=WIDTH*<span class="number">4</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	width=WIDTH;</span><br><span class="line">	&#125;</span><br><span class="line">	layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, width);</span><br><span class="line">	layer.position=[touch locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">	layer.cornerRadius=width/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b3a99537419dce31.gif?imageMogr2/auto-orient/strip" alt></p>
<hr>
<h2 id="3-CALayer绘图"><a href="#3-CALayer绘图" class="headerlink" title="3. CALayer绘图"></a>3. CALayer绘图</h2><p>在使用Quartz 2D绘图时，当调用了UIView的drawRect:方法绘制图形、图像，这种方式本质还是在图层中绘制，但是这里会着重介绍一下如何直接在图层中绘图。在图层中绘图的方式跟原来基本没有区别，只是drawRect:方法是由UIKit组件进行调用，因此里面可以使用一些UIKit封装的方法进行绘图，而直接绘制到图层的方法由于并非UIKit直接调用因此只能用原生的Core Graphics方法绘制。</p>
<p>图层绘图有两种方法，不管使用哪种方法绘制完必须调用图层的setNeedDisplay方法（注意是图层的方法，不是UIView的方法，前面我们介绍过UIView也有此方法）</p>
<ol>
<li>通过图层代理drawLayer: inContext:方法绘制</li>
<li>通过自定义图层drawInContext:方法绘制</li>
</ol>
<h3 id="3-1、使用代理方法绘图"><a href="#3-1、使用代理方法绘图" class="headerlink" title="3.1、使用代理方法绘图"></a>3.1、使用代理方法绘图</h3><p>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写<strong>-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</strong>方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>
<p>下面的代码演示了在一个自定义图层绘制一张图像并将图像设置成圆形，这种效果在很多应用中很常见，如最新版的手机QQ头像就是这种效果：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHOTO_HEIGHT 150</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">//自定义图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">	layer.position=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">	layer.backgroundColor=[<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">	layer.cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//注意仅仅设置圆角，对于图形而言可以正常显示，但是对于图层中绘制的图片无法正确显示</span></span><br><span class="line">	<span class="comment">//如果想要正确显示则必须设置masksToBounds=YES，剪切子图层</span></span><br><span class="line">	layer.masksToBounds=<span class="literal">YES</span>;</span><br><span class="line">	<span class="comment">//阴影效果无法和masksToBounds同时使用，因为masksToBounds的目的就是剪切外边框，而阴影效果刚好在外边框</span></span><br><span class="line">	<span class="comment">//    layer.shadowColor=[UIColor grayColor].CGColor;</span></span><br><span class="line">	<span class="comment">//    layer.shadowOffset=CGSizeMake(2, 2);</span></span><br><span class="line">	<span class="comment">//    layer.shadowOpacity=1;</span></span><br><span class="line">	<span class="comment">//设置边框</span></span><br><span class="line">	layer.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layer.borderWidth=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//设置图层代理</span></span><br><span class="line">	layer.delegate=<span class="keyword">self</span>;</span><br><span class="line">	<span class="comment">//添加图层到根图层</span></span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">	<span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">	[layer setNeedsDisplay];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">	-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">	<span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">	<span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line">	<span class="comment">//图形上下文形变，解决图片倒立的问题</span></span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">0</span>, -PHOTO_HEIGHT);</span><br><span class="line">	<span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.png"</span>];</span><br><span class="line">	<span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">	<span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">	<span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line">	<span class="comment">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span></span><br><span class="line">	<span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-983f8fbeb04c3dea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>使用代理方法绘制图形、图像时在drawLayer:inContext:方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文。</p>
<p>需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>
<h4 id="3-1-1、扩展1–带阴影效果的圆形图片裁切"><a href="#3-1-1、扩展1–带阴影效果的圆形图片裁切" class="headerlink" title="3.1.1、扩展1–带阴影效果的圆形图片裁切"></a>3.1.1、扩展1–带阴影效果的圆形图片裁切</h4><p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHOTO_HEIGHT 150</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">	<span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//阴影图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layerShadow.bounds=bounds;</span><br><span class="line">	layerShadow.position=position;</span><br><span class="line">	layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">	layerShadow.shadowColor=[<span class="built_in">UIColor</span> grayColor].CGColor;</span><br><span class="line">	layerShadow.shadowOffset=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	layerShadow.shadowOpacity=<span class="number">1</span>;</span><br><span class="line">	layerShadow.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layerShadow.borderWidth=borderWidth;</span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layerShadow];</span><br><span class="line">	<span class="comment">//容器图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layer.bounds=bounds;</span><br><span class="line">	layer.position=position;</span><br><span class="line">	layer.backgroundColor=[<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">	layer.cornerRadius=cornerRadius;</span><br><span class="line">	layer.masksToBounds=<span class="literal">YES</span>;</span><br><span class="line">	layer.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layer.borderWidth=borderWidth;</span><br><span class="line">	<span class="comment">//设置图层代理</span></span><br><span class="line">	layer.delegate=<span class="keyword">self</span>;</span><br><span class="line">	<span class="comment">//添加图层到根图层</span></span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">	<span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">	[layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">	<span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">	<span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line">	<span class="comment">//图形上下文形变，解决图片倒立的问题</span></span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">0</span>, -PHOTO_HEIGHT);</span><br><span class="line">	<span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line">	<span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">	<span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">	<span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line">	<span class="comment">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span></span><br><span class="line">	<span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-0ce398f485925bea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="3-1-2、扩展2–图层的形变"><a href="#3-1-2、扩展2–图层的形变" class="headerlink" title="3.1.2、扩展2–图层的形变"></a>3.1.2、扩展2–图层的形变</h4><p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。在前一篇文章中也采用了类似的方法去解决这个问题，但是在那篇文章中也提到过如果直接让图像沿着x轴旋转180度同样可以达到正确显示的目的，只是当时的旋转靠图形上下文还无法绕x轴旋转。今天学习了图层之后，其实可以控制图层直接旋转而不用借助于图形上下文的形变操作，而且这么操作起来会更加简单和直观。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，使用方法和前面介绍的二维形变是类似的，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。下面的代码通过CATransform3DMakeRotation()方法在x轴旋转180度解决倒立问题：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  形变演示</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHOTO_HEIGHT 150</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">	<span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//阴影图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layerShadow.bounds=bounds;</span><br><span class="line">	layerShadow.position=position;</span><br><span class="line">	layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">	layerShadow.shadowColor=[<span class="built_in">UIColor</span> grayColor].CGColor;</span><br><span class="line">	layerShadow.shadowOffset=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	layerShadow.shadowOpacity=<span class="number">1</span>;</span><br><span class="line">	layerShadow.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layerShadow.borderWidth=borderWidth;</span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layerShadow];</span><br><span class="line">	<span class="comment">//容器图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layer.bounds=bounds;</span><br><span class="line">	layer.position=position;</span><br><span class="line">	layer.backgroundColor=[<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">	layer.cornerRadius=cornerRadius;</span><br><span class="line">	layer.masksToBounds=<span class="literal">YES</span>;</span><br><span class="line">	layer.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layer.borderWidth=borderWidth;</span><br><span class="line">	<span class="comment">//利用图层形变解决图像倒立问题</span></span><br><span class="line">	layer.transform=<span class="built_in">CATransform3DMakeRotation</span>(M_PI, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置图层代理</span></span><br><span class="line">	layer.delegate=<span class="keyword">self</span>;</span><br><span class="line">	<span class="comment">//添加图层到根图层</span></span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">	<span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">	[layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 绘制图形、图像到图层，注意参数中的ctx时图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">	<span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line">	<span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">	<span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  图层内容设置</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHOTO_HEIGHT 150</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">	<span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//阴影图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layerShadow.bounds=bounds;</span><br><span class="line">	layerShadow.position=position;</span><br><span class="line">	layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">	layerShadow.shadowColor=[<span class="built_in">UIColor</span> grayColor].CGColor;</span><br><span class="line">	layerShadow.shadowOffset=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	layerShadow.shadowOpacity=<span class="number">1</span>;</span><br><span class="line">	layerShadow.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layerShadow.borderWidth=borderWidth;</span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layerShadow];</span><br><span class="line">	<span class="comment">//容器图层</span></span><br><span class="line">	<span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">	layer.bounds=bounds;</span><br><span class="line">	layer.position=position;</span><br><span class="line">	layer.backgroundColor=[<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">	layer.cornerRadius=cornerRadius;</span><br><span class="line">	layer.masksToBounds=<span class="literal">YES</span>;</span><br><span class="line">	layer.borderColor=[<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">	layer.borderWidth=borderWidth;</span><br><span class="line">	<span class="comment">//设置内容（注意这里一定要转换为CGImage）</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line">	<span class="comment">//    layer.contents=(id)image.CGImage;</span></span><br><span class="line">	[layer setContents:(<span class="keyword">id</span>)image.CGImage];</span><br><span class="line">	<span class="comment">//添加图层到根图层</span></span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>既然如此为什么还大费周章的说形变呢，因为形变对于动画有特殊的意义。在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>
<blockquote>
<p>[layer setValue:@M_PI forKeyPath:@”transform.rotation.x”];</p>
</blockquote>
<p>当然，通过key path设置形变参数就需要了解有哪些key path可以设置，这里就不再一一列举，大家可以参照Xcode帮助文档中“CATransform3D Key Paths”一节，里面描述的很详细。</p>
<h3 id="3-2、使用自定义图层绘图"><a href="#3-2、使用自定义图层绘图" class="headerlink" title="3.2、使用自定义图层绘图"></a>3.2、使用自定义图层绘图</h3><p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在drawInContext:中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用。</p>
<p>在使用Quartz 2D在UIView中绘制图形的本质也是绘制到图层中，为了说明这个问题下面演示自定义图层绘图时没有直接在视图控制器中调用自定义图层，而是在一个UIView将自定义图层添加到UIView的根图层中（例子中的UIView跟自定义图层绘图没有直接关系）。从下面的代码中可以看到：UIView在显示时其根图层会自动创建一个CGContextRef（CALayer本质使用的是位图上下文），同时调用图层代理（UIView创建图层会自动设置图层代理为其自身）的<strong>draw: inContext:</strong>方法并将图形上下文作为参数传递给这个方法。而在UIView的<strong>draw:inContext:</strong>方法中会调用其drawRect:方法，在<strong>drawRect:</strong>方法中使用<strong>UIGraphicsGetCurrentContext()</strong>方法得到的上下文正是前面创建的上下文。<br>KCLayer.m</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCLayer.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"KCLayer.h"</span></span><br><span class="line">@implementation KCLayer</span><br><span class="line">-(<span class="built_in">void</span>)drawInContext:(CGContextRef)ctx&#123;</span><br><span class="line">	NSLog(@<span class="string">"3-drawInContext:"</span>);</span><br><span class="line">	NSLog(@<span class="string">"CGContext:%@"</span>,ctx);</span><br><span class="line">	<span class="comment">//    CGContextRotateCTM(ctx, M_PI_4);</span></span><br><span class="line">	CGContextSetRGBFillColor(ctx, <span class="number">135.0</span>/<span class="number">255.0</span>, <span class="number">232.0</span>/<span class="number">255.0</span>, <span class="number">84.0</span>/<span class="number">255.0</span>, <span class="number">1</span>);</span><br><span class="line">	CGContextSetRGBStrokeColor(ctx, <span class="number">135.0</span>/<span class="number">255.0</span>, <span class="number">232.0</span>/<span class="number">255.0</span>, <span class="number">84.0</span>/<span class="number">255.0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line">	<span class="comment">//    CGContextFillEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));</span></span><br><span class="line">	CGContextMoveToPoint(ctx, <span class="number">94.5</span>, <span class="number">33.5</span>);</span><br><span class="line">	<span class="comment">//// Star Drawing</span></span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">104.02</span>, <span class="number">47.39</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">120.18</span>, <span class="number">52.16</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">109.91</span>, <span class="number">65.51</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">110.37</span>, <span class="number">82.34</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">94.5</span>, <span class="number">76.7</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">78.63</span>, <span class="number">82.34</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">79.09</span>, <span class="number">65.51</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">68.82</span>, <span class="number">52.16</span>);</span><br><span class="line">	CGContextAddLineToPoint(ctx,<span class="number">84.98</span>, <span class="number">47.39</span>);</span><br><span class="line">	CGContextClosePath(ctx);</span><br><span class="line">	CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>KCView.m</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCView.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCView.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCLayer.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCView</span></span></span><br><span class="line">-(<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"initWithFrame:"</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> initWithFrame:frame]) </span><br><span class="line">	&#123;</span><br><span class="line">		KCLayer *layer=[[KCLayer alloc]init];</span><br><span class="line">		layer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">185</span>, <span class="number">185</span>);</span><br><span class="line">		layer.position=<span class="built_in">CGPointMake</span>(<span class="number">160</span>,<span class="number">284</span>);</span><br><span class="line">		layer.backgroundColor=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span> green:<span class="number">146</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">		<span class="comment">//显示图层</span></span><br><span class="line">		[layer setNeedsDisplay];</span><br><span class="line">		[<span class="keyword">self</span>.layer addSublayer:layer];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"2-drawRect:"</span>);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"CGContext:%@"</span>,<span class="built_in">UIGraphicsGetCurrentContext</span>());<span class="comment">//得到的当前图形上下文正是drawLayer中传递的</span></span><br><span class="line">	[<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"1-drawLayer:inContext:"</span>);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"CGContext:%@"</span>,ctx);</span><br><span class="line">	[<span class="keyword">super</span> drawLayer:layer inContext:ctx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>KCMainViewController.m</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  CALayer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"KCView.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	KCView *view=[[KCView alloc]initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">	view.backgroundColor=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">249.0</span>/<span class="number">255.0</span> green:<span class="number">249.0</span>/<span class="number">255.0</span> blue:<span class="number">249.0</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</span><br><span class="line">	[<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-37d68836198e596b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>layer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发常用数学函数</title>
    <url>/iOS%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h3 id="1-三角函数"><a href="#1-三角函数" class="headerlink" title="1.  三角函数"></a>1.  三角函数</h3><p>　　double sin (double);正弦<br>　　double cos (double);余弦<br>　　double tan (double);正切 </p>
<h3 id="2-反三角函数"><a href="#2-反三角函数" class="headerlink" title="2.  反三角函数"></a>2.  反三角函数</h3><p>　　double asin (double); 结果介于[-PI/2, PI/2]<br>　　double acos (double); 结果介于[0, PI]<br>　　double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2]<br>　　double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] </p>
<h3 id="3-双曲三角函数"><a href="#3-双曲三角函数" class="headerlink" title="3.  双曲三角函数"></a>3.  双曲三角函数</h3><p>　　double sinh (double);<br>　　double cosh (double);<br>　　double tanh (double); </p>
<h3 id="4-指数与对数"><a href="#4-指数与对数" class="headerlink" title="4. 指数与对数"></a>4. 指数与对数</h3><p>　　double exp (double);求取自然数e的幂<br>　　double sqrt (double);开平方<br>　　double log (double); 以e为底的对数<br>　　double log10 (double);以10为底的对数<br>　　double pow(double x, double y）;计算以x为底数的y次幂<br>　　float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 </p>
<h3 id="5-取整"><a href="#5-取整" class="headerlink" title="5. 取整"></a>5. 取整</h3><p>　　double ceil (double); 取上整<br>　　double floor (double); 取下整 </p>
<h3 id="6-绝对值"><a href="#6-绝对值" class="headerlink" title="6. 绝对值"></a>6. 绝对值</h3><p>　　double fabs (double);求绝对值<br>　　double cabs(struct complex znum) ;求复数的绝对值 </p>
<h3 id="7-标准化浮点数"><a href="#7-标准化浮点数" class="headerlink" title="7.  标准化浮点数"></a>7.  标准化浮点数</h3><p>　　double frexp (double f, int *p); 标准化浮点数, f = x * 2^p, 已知f求x, p ( x介于[0.5, 1] )<br>　　double ldexp (double x, int p); 与frexp相反, 已知x, p求f </p>
<h3 id="8-取整与取余"><a href="#8-取整与取余" class="headerlink" title="8. 取整与取余"></a>8. 取整与取余</h3><p>　　double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分<br>　　double fmod (double, double); 返回两参数相除的余数 </p>
<h3 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h3><p>　　double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度<br>　　double ldexp(double x, int exponent);计算x*(2的exponent次幂)<br>　　double poly(double x, int degree, double coeffs [] );计算多项式<br>　　nt matherr(struct exception *e);数学错误计算处理程序</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>数学函数</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-画虚线的几种方式</title>
    <url>/iOS-%E7%94%BB%E8%99%9A%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="一、重写drawRect方法"><a href="#一、重写drawRect方法" class="headerlink" title="一、重写drawRect方法"></a>一、重写drawRect方法</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> - (void)drawRect:(CGRect)rect</span><br><span class="line">&#123; </span><br><span class="line">	<span class="literal">[<span class="identifier">super</span> <span class="identifier">drawRect</span>:<span class="identifier">rect</span>]</span>;</span><br><span class="line">	 CGContextRef currentContext = <span class="constructor">UIGraphicsGetCurrentContext()</span>; </span><br><span class="line">	 <span class="comment">//设置虚线颜色 </span></span><br><span class="line">	 <span class="constructor">CGContextSetStrokeColorWithColor(<span class="params">currentContext</span>, [UIColor BlackColor].CGColor)</span>; </span><br><span class="line">	 <span class="comment">//设置虚线宽度 </span></span><br><span class="line">	 <span class="constructor">CGContextSetLineWidth(<span class="params">currentContext</span>, 1)</span>; </span><br><span class="line">	 <span class="comment">//设置虚线绘制起点 </span></span><br><span class="line">	 <span class="constructor">CGContextMoveToPoint(<span class="params">currentContext</span>, 0, 0)</span>; </span><br><span class="line">	 <span class="comment">//设置虚线绘制终点 </span></span><br><span class="line">	 <span class="constructor">CGContextAddLineToPoint(<span class="params">currentContext</span>, <span class="params">self</span>.<span class="params">frame</span>.<span class="params">origin</span>.<span class="params">x</span> + <span class="params">self</span>.<span class="params">frame</span>.<span class="params">size</span>.<span class="params">width</span>, 0)</span>; <span class="comment">//设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点 </span></span><br><span class="line">	 CGFloat arr<span class="literal">[]</span> = &#123;<span class="number">3</span>,<span class="number">1</span>&#125;; </span><br><span class="line">	 <span class="comment">//下面最后一个参数“2”代表排列的个数。 </span></span><br><span class="line">	 <span class="constructor">CGContextSetLineDash(<span class="params">currentContext</span>, 0, <span class="params">arr</span>, 2)</span>; </span><br><span class="line">	 <span class="constructor">CGContextDrawPath(<span class="params">currentContext</span>, <span class="params">kCGPathStroke</span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着这些代码肯定有一部分人头疼，因为一般开发绘图部分用的比较少，特别是很少接触这些东西的人，甚至对绘图这部分的只是已经忘光了，所以在这里自己也脑补一下。<strong>以下来自转载</strong><br>iOS的绘图操作是在UIView类的drawRect方法中完成的，所以如果我们要想在一个UIView中绘图，需要写一个扩展UIView 的类，并重写drawRect方法，在这里进行绘图操作，程序会自动调用此方法进行绘图。下面先说明一下绘图，比如，你想绘制一个方块，你需要写一个类来扩展UIView并在drawRect方法中填入如下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123; </span><br><span class="line">	<span class="comment">// Drawing code. </span></span><br><span class="line">	<span class="comment">//获得处理的上下文 </span></span><br><span class="line">	CGContextRef context = <span class="constructor">UIGraphicsGetCurrentContext()</span>; </span><br><span class="line">	<span class="comment">//设置线条样式 </span></span><br><span class="line">	<span class="constructor">CGContextSetLineCap(<span class="params">context</span>, <span class="params">kCGLineCapSquare</span>)</span>; </span><br><span class="line">	<span class="comment">//设置线条粗细宽度 </span></span><br><span class="line">	<span class="constructor">CGContextSetLineWidth(<span class="params">context</span>, 1.0)</span>; </span><br><span class="line">	<span class="comment">//设置颜色 </span></span><br><span class="line">	<span class="constructor">CGContextSetRGBStrokeColor(<span class="params">context</span>, 1.0, 0.0, 0.0, 1.0)</span>; </span><br><span class="line">	<span class="comment">//开始一个起始路径 </span></span><br><span class="line">	<span class="constructor">CGContextBeginPath(<span class="params">context</span>)</span>; </span><br><span class="line">	<span class="comment">//起始点设置为(0,0):注意这是上下文对应区域中的相对坐标 </span></span><br><span class="line">	<span class="constructor">CGContextMoveToPoint(<span class="params">context</span>, 0, 0)</span>; </span><br><span class="line">	<span class="comment">//设置下一个坐标点 </span></span><br><span class="line">	<span class="constructor">CGContextAddLineToPoint(<span class="params">context</span>, 100, 100)</span>; </span><br><span class="line">	/设置下一个坐标点 </span><br><span class="line">	<span class="constructor">CGContextAddLineToPoint(<span class="params">context</span>, 0, 150)</span>; </span><br><span class="line">	<span class="comment">//设置下一个坐标点 CGContextAddLineToPoint(context, 50, 180); </span></span><br><span class="line">	<span class="comment">//连接上面定义的坐标点 </span></span><br><span class="line">	<span class="constructor">CGContextStrokePath(<span class="params">context</span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再说明一下重绘，重绘操作仍然在drawRect方法中完成，但是苹果不建议直接调用drawRect方法，当然如果你强行直接调用此方法，当然是没有效果的。苹果要求我们调用UIView类中的setNeedsDisplay方法，则程序会自动调用drawRect方法进行重绘（调用setNeedsDisplay会自动调用drawRect）。<br>在UIView中,重写drawRect: (CGRect)aRect方法,可以自己定义想要画的图案.且此方法一般情况下只会画一次.也就是说这个drawRect方法一般情况下只会被掉用一次。当某些情况下想要手动重画这个View,只需要掉用<strong>[self setNeedsDisplay]</strong>方法即可.<br>drawRect的执行顺序及注意<br><strong>drawRect调是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的</strong>.<br>如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。<br>该方法在调用sizeThatFits后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0.</p>
<blockquote>
<p>以上1,2推荐；而3,4不提倡<br>若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect ，让系统自动调该方法。若使用calayer绘图，只能在drawInContext:中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法。若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕转载地址：<a href="http://blog.csdn.net/fww330666557/article/details/8647608" target="_blank" rel="noopener">http://blog.csdn.net/fww330666557/article/details/8647608</a></p>
</blockquote>
<h2 id="二、通过UIImage的绘图方法来绘制"><a href="#二、通过UIImage的绘图方法来绘制" class="headerlink" title="二、通过UIImage的绘图方法来绘制"></a>二、通过UIImage的绘图方法来绘制</h2><p>// 画虚线// 创建一个imageView 高度是你想要的虚线的高度 一般设为2<br>_lineImg = [[UIImageView alloc] initWithFrame:CGRectMake(0, 20, kScreenWidth, 2)];<br>// 调用方法 返回的iamge就是虚线<br>_lineImg.image = [self drawLineByImageView:_lineImg];<br>// 添加到控制器的view上<br>[self.view addSubview:_lineImg];<br>// 返回虚线image的方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (UIImage *)drawLineByImageView:(UIImageView *)imageView</span><br><span class="line">&#123; </span><br><span class="line">	<span class="constructor">UIGraphicsBeginImageContext(<span class="params">imageView</span>.<span class="params">frame</span>.<span class="params">size</span>)</span>;</span><br><span class="line">	<span class="comment">//开始画线 划线的frame </span></span><br><span class="line">	<span class="literal">[<span class="identifier">imageView</span>.<span class="identifier">image</span> <span class="identifier">drawInRect</span>:CGR<span class="identifier">ectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="identifier">imageView</span>.<span class="identifier">frame</span>.<span class="identifier">size</span>.<span class="identifier">width</span>, <span class="identifier">imageView</span>.<span class="identifier">frame</span>.<span class="identifier">size</span>.<span class="identifier">height</span>)]</span>; </span><br><span class="line">	<span class="comment">//设置线条终点形状 </span></span><br><span class="line">	<span class="constructor">CGContextSetLineCap(UIGraphicsGetCurrentContext()</span>, kCGLineCapRound); </span><br><span class="line">	<span class="comment">// 5是每个虚线的长度 1是高度 </span></span><br><span class="line">	<span class="built_in">float</span> lengths<span class="literal">[]</span> = &#123;<span class="number">5</span>,<span class="number">1</span>&#125;; </span><br><span class="line">	CGContextRef line = <span class="constructor">UIGraphicsGetCurrentContext()</span>; </span><br><span class="line">	<span class="comment">// 设置颜色 </span></span><br><span class="line">	<span class="constructor">CGContextSetStrokeColorWithColor(<span class="params">line</span>, [UIColor <span class="params">colorWithWhite</span>:0.408 <span class="params">alpha</span>:1.000].CGColor)</span>; </span><br><span class="line">	<span class="constructor">CGContextSetLineDash(<span class="params">line</span>, 0, <span class="params">lengths</span>, 2)</span>; </span><br><span class="line">	<span class="comment">//画虚线 </span></span><br><span class="line">	<span class="constructor">CGContextMoveToPoint(<span class="params">line</span>, 0.0, 2.0)</span>; </span><br><span class="line">	<span class="comment">//开始画线 CGContextAddLineToPoint(line, kScreenWidth - 10, 2.0); </span></span><br><span class="line">	<span class="constructor">CGContextStrokePath(<span class="params">line</span>)</span>;</span><br><span class="line">	<span class="constructor">UIGraphicsGetImageFromCurrentImageContext()</span></span><br><span class="line">	<span class="comment">//返回的就是image</span></span><br><span class="line">	return <span class="constructor">UIGraphicsGetImageFromCurrentImageContext()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、通过CAShapeLayer方式绘制虚线"><a href="#三、通过CAShapeLayer方式绘制虚线" class="headerlink" title="三、通过CAShapeLayer方式绘制虚线"></a>三、通过CAShapeLayer方式绘制虚线</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">** lineView: 需要绘制成虚线的view </span></span><br><span class="line"><span class="comment">** lineLength: 虚线的宽度 </span></span><br><span class="line"><span class="comment">** lineSpacing: 虚线的间距 </span></span><br><span class="line"><span class="comment">** lineColor: 虚线的颜色 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">+ (<span class="keyword">void</span>)drawDashLine:(<span class="built_in">UIView</span> *)lineView lineLength:(<span class="keyword">int</span>)lineLength lineSpacing:(<span class="keyword">int</span>)lineSpacing lineColor:(<span class="built_in">UIColor</span> *)lineColor</span><br><span class="line">&#123; </span><br><span class="line">	<span class="built_in">CAShapeLayer</span> *shapeLayer = [<span class="built_in">CAShapeLayer</span> layer]; </span><br><span class="line">	[shapeLayer setBounds:lineView.bounds]; </span><br><span class="line">	[shapeLayer setPosition:<span class="built_in">CGPointMake</span>(<span class="built_in">CGRectGetWidth</span>(lineView.frame) / <span class="number">2</span>, <span class="built_in">CGRectGetHeight</span>(lineView.frame))];</span><br><span class="line">	[shapeLayer setFillColor:[<span class="built_in">UIColor</span> clearColor].CGColor]; </span><br><span class="line">	<span class="comment">// 设置虚线颜色为blackColor </span></span><br><span class="line">	[shapeLayer setStrokeColor:lineColor.CGColor]; </span><br><span class="line">	<span class="comment">// 设置虚线宽度 </span></span><br><span class="line">	[shapeLayer setLineWidth:<span class="built_in">CGRectGetHeight</span>(lineView.frame)]; </span><br><span class="line">	[shapeLayer setLineJoin:kCALineJoinRound]; </span><br><span class="line">	<span class="comment">// 设置线宽，线间距 </span></span><br><span class="line">	[shapeLayer setLineDashPattern:[<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSNumber</span> numberWithInt:lineLength], [<span class="built_in">NSNumber</span> numberWithInt:lineSpacing], <span class="literal">nil</span>]]; </span><br><span class="line">	<span class="comment">// 设置路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0);</span></span><br><span class="line">	<span class="built_in">CGPathAddLineToPoint</span>(path, <span class="literal">NULL</span>,<span class="built_in">CGRectGetWidth</span>(lineView.frame), <span class="number">0</span>); </span><br><span class="line">	[shapeLayer setPath:path]; <span class="built_in">CGPathRelease</span>(path); </span><br><span class="line">	<span class="comment">// 把绘制好的虚线添加上来 </span></span><br><span class="line">	[lineView.layer addSublayer:shapeLayer]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码，有一个注意点：就是position和anchorPoint的区别，这点有兴趣的可以去脑补一下。当然layer上的绘图，我也感觉自己很low了，因为形式没用过，所以基本上快忘光了，所以自己也需要花时间去脑补一下。链接：<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="noopener">http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/</a></p>
<h2 id="四、图片平铺（简单暴力）"><a href="#四、图片平铺（简单暴力）" class="headerlink" title="四、图片平铺（简单暴力）"></a>四、图片平铺（简单暴力）</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imgDashLineView =[[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">15</span>, <span class="number">200</span>, <span class="keyword">self</span>.view.frame.size.width - <span class="number">30</span>, <span class="number">1</span>)];</span><br><span class="line">[imgDashLineView setBackgroundColor:[<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xuxian.png"</span>]]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imgDashLineView];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>画虚线</tag>
      </tags>
  </entry>
</search>
