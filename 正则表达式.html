<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.ericlife.top').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: true,
    lazyload: true,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="几乎涵盖了所有的正则表达形式。">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="https://www.ericlife.top/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">
<meta property="og:site_name" content="时光书馆">
<meta property="og:description" content="几乎涵盖了所有的正则表达形式。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-05-27T07:01:50.000Z">
<meta property="article:modified_time" content="2019-05-27T07:01:50.000Z">
<meta property="article:author" content="Eric">
<meta property="article:tag" content="正则">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.ericlife.top/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>正则表达式 | 时光书馆</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="时光书馆" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时光书馆</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">将来的自己,会感谢现在努力的自己!</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ericlife.top/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eric">
      <meta itemprop="description" content="记录开发过程中技术点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时光书馆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          正则表达式
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-27 15:01:50" itemprop="dateCreated datePublished" datetime="2019-05-27T15:01:50+08:00">2019-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础知识</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>
            <div class="post-description">几乎涵盖了所有的正则表达形式。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、为什么使用正则表达式？"><a href="#一、为什么使用正则表达式？" class="headerlink" title="一、为什么使用正则表达式？"></a>一、为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。<br>通过使用正则表达式，可以：</p>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
<p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p>
<h2 id="二、发展历史"><a href="#二、发展历史" class="headerlink" title="二、发展历史"></a>二、发展历史</h2><p>正则表达式的”祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。<br>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为”神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为”正则集的代数”的表达式，因此采用”正则表达式”这个术语。<br>随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。<br>如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。</p>
<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><h3 id="3-1、普通字符"><a href="#3-1、普通字符" class="headerlink" title="3.1、普通字符"></a>3.1、普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h3 id="3-2、非打印字符"><a href="#3-2、非打印字符" class="headerlink" title="3.2、非打印字符"></a>3.2、非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="3-3、特殊字符"><a href="#3-3、特殊字符" class="headerlink" title="3.3、特殊字符"></a>3.3、特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo<em>b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 : runo\</em>ob 匹配 runo*ob。<br>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">特别字符        描述 </span><br><span class="line">$              匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '<span class="symbol">\n</span>' 或 '<span class="symbol">\r</span>'。要匹配 $ 字符本身，请使用 <span class="symbol">\$</span>。</span><br><span class="line">( )            标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <span class="symbol">\(</span> 和 <span class="symbol">\)</span>。</span><br><span class="line">*              匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 <span class="symbol">\*</span>。</span><br><span class="line">+              匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <span class="symbol">\+</span>。</span><br><span class="line">.              匹配除换行符 <span class="symbol">\n</span> 之外的任何单字符。要匹配 . ，请使用 <span class="symbol">\.</span> 。</span><br><span class="line">[              标记一个中括号表达式的开始。要匹配 [，请使用 <span class="symbol">\[</span>。</span><br><span class="line">?              匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 <span class="symbol">\?</span>。 |</span><br><span class="line"><span class="symbol">\ </span>             将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'<span class="symbol">\n</span>' 匹配换行符。序列 '<span class="symbol">\\</span>' 匹配 "<span class="symbol">\"</span>，而 '<span class="symbol">\(</span>' 则匹配 "("。</span><br><span class="line">^              匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <span class="symbol">\^</span>。</span><br><span class="line">&#123;              标记限定符表达式的开始。要匹配 &#123;，请使用 <span class="symbol">\&#123;</span>。</span><br><span class="line">|              指明两项之间的一个选择。要匹配 |，请使用 <span class="symbol">\|</span>。</span><br></pre></td></tr></table></figure>

<h3 id="3-4、限定符"><a href="#3-4、限定符" class="headerlink" title="3.4、限定符"></a>3.4、限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p>由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]*/</span><br></pre></td></tr></table></figure>
<p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。<br>这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。<br>如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。<br>/Chapter [0-9]{1,2}/<br>上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]?/</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;/</span><br></pre></td></tr></table></figure>
<p>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。<br>例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>Chapter 1 - 介绍正则表达式<span class="tag">&lt;/<span class="name">H1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">.*</span>&gt;</span>/</span><br></pre></td></tr></table></figure>
<p><strong>非贪婪</strong>：如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 H1 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">.*?</span>&gt;</span>/</span><br></pre></td></tr></table></figure>

<p>如果只想匹配开始的 H1 标签，表达式则是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">\w+?</span>&gt;</span>/</span><br></pre></td></tr></table></figure>
<p>通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>
<h3 id="3-5、定位符"><a href="#3-5、定位符" class="headerlink" title="3.5、定位符"></a>3.5、定位符</h3><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。<br>定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。<br>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配。</td>
</tr>
</tbody></table>
<p>注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。<br>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。<br>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。<br>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;/</span><br></pre></td></tr></table></figure>
<p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^Chapter [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
<p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/\bCha/</span></span><br></pre></td></tr></table></figure>
<p><strong>\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/ter\b/</span></span><br></pre></td></tr></table></figure>
<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/\Bapt/</span></span><br></pre></td></tr></table></figure>
<p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>
<h3 id="3-6、选择"><a href="#3-6、选择" class="headerlink" title="3.6、选择"></a>3.6、选择</h3><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 <strong>?</strong>: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>
<h3 id="3-7、反向引用"><a href="#3-7、反向引用" class="headerlink" title="3.7、反向引用"></a>3.7、反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。<br>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>
<p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：<br>Is is the cost of of gasoline going up up?<br>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p>
<p>实例<br>查找重复的单词：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Is is the cost of of gasoline going up up"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/\b([a-z]+) \1\b/ig</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(patt1));</span><br></pre></td></tr></table></figure>

<p>捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。<br>单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。<br>正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。<br>表达式的结尾处的不区分大小写 i 标记指定不区分大小写。<br>多行标记指定换行符的两边可能出现潜在的匹配。<br>反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.runoob.com:<span class="number">80</span><span class="regexp">/html/</span>html-tutorial.html</span><br></pre></td></tr></table></figure>
<p>下面的正则表达式提供该功能：</p>
<p>实例<br>输出所有匹配的数据：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.runoob.com:80/html/html-tutorial.html"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/(\w+):\/\/([^/</span>:]+)(:<span class="string">\d*)?([^#</span> ]*)/;</span><br><span class="line">arr = str.match(patt1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(arr[i]);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。<br>第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。<br>第二个括号子表达式捕获地址的域地址部分。子表达式匹配 : 和 / 之后的一个或多个字符。<br>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。<br>最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。<br>将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：</p>
<ul>
<li>第一个括号子表达式包含 http</li>
<li>第二个括号子表达式包含 <a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a></li>
<li>第三个括号子表达式包含 :80</li>
<li>第四个括号子表达式包含 /html/html-tutorial.html</li>
</ul>
<h2 id="四、元字符"><a href="#四、元字符" class="headerlink" title="四、元字符"></a>四、元字符</h2><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">字符            描述</span><br><span class="line"><span class="string">\</span>              将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<span class="string">'n'</span> 匹配字符 <span class="string">"n"</span>。<span class="string">'\n'</span> 匹配一个换行符。序列 <span class="string">'\\'</span> 匹配 <span class="string">"\" 而 "</span><span class="string">\("</span> 则匹配 <span class="string">"("</span>。</span><br><span class="line">^              匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 <span class="string">'\n'</span> 或 <span class="string">'\r'</span> 之后的位置。</span><br><span class="line">$匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 <span class="string">'\n'</span> 或 <span class="string">'\r'</span> 之前的位置。</span><br><span class="line">*              匹配前面的子表达式零次或多次。例如，zo* 能匹配 <span class="string">"z"</span> 以及 <span class="string">"zoo"</span>。* 等价于&#123;<span class="number">0</span>,&#125;。</span><br><span class="line">+              匹配前面的子表达式一次或多次。例如，<span class="string">'zo+'</span> 能匹配 <span class="string">"zo"</span> 以及 <span class="string">"zoo"</span>，但不能匹配 <span class="string">"z"</span>。+ 等价于 &#123;<span class="number">1</span>,&#125;。</span><br><span class="line">?              匹配前面的子表达式零次或一次。例如，<span class="string">"do(es)?"</span> 可以匹配 <span class="string">"do"</span> 或 <span class="string">"does"</span> 。? 等价于 &#123;<span class="number">0</span>,<span class="number">1</span>&#125;。</span><br><span class="line">&#123;n&#125;            n 是一个非负整数。匹配确定的 n 次。例如，<span class="string">'o&#123;2&#125;'</span> 不能匹配 <span class="string">"Bob"</span> 中的 <span class="string">'o'</span>，但是能匹配 <span class="string">"food"</span> 中的两个 o。</span><br><span class="line">&#123;n,&#125;           n 是一个非负整数。至少匹配n 次。例如，<span class="string">'o&#123;2,&#125;'</span> 不能匹配 <span class="string">"Bob"</span> 中的 <span class="string">'o'</span>，但能匹配 <span class="string">"foooood"</span> 中的所有 o。<span class="string">'o&#123;1,&#125;'</span> 等价于 <span class="string">'o+'</span>。<span class="string">'o&#123;0,&#125;'</span> 则等价于 <span class="string">'o*'</span>。</span><br><span class="line">&#123;n,m&#125;          m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<span class="string">"o&#123;1,3&#125;"</span> 将匹配 <span class="string">"fooooood"</span> 中的前三个 o。<span class="string">'o&#123;0,1&#125;'</span> 等价于 <span class="string">'o?'</span>。请注意在逗号和两个数之间不能有空格。</span><br><span class="line">?              当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 <span class="string">"oooo"</span>，<span class="string">'o+?'</span> 将匹配单个 <span class="string">"o"</span>，而 <span class="string">'o+'</span> 将匹配所有 <span class="string">'o'</span>。</span><br><span class="line">.              匹配除换行符（<span class="string">\n、\r）之外的任何单个字符。要匹配包括</span> <span class="string">'\n'</span> 在内的任何字符，请使用像<span class="string">"(.|\n)"</span>的模式。</span><br><span class="line">(pattern)      匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $<span class="number">0</span>…$<span class="number">9</span> 属性。要匹配圆括号字符，请使用 <span class="string">'\('</span> 或 <span class="string">'\)'</span>。</span><br><span class="line">(?:pattern)    匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 <span class="string">"或"</span> 字符 (|) 来组合一个模式的各个部分是很有用。例如， <span class="string">'industr(?:y|ies) 就是一个比 '</span>industry|industries<span class="string">' 更简略的表达式。</span></span><br><span class="line"><span class="string">(?=pattern)    正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span></span><br><span class="line"><span class="string">(?!pattern)    正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span></span><br><span class="line"><span class="string">(?&lt;=pattern)   反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?&lt;=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。</span></span><br><span class="line"><span class="string">(?&lt;!pattern)   反向否定预查，与正向否定预查类似，只是方向相反。例如"(?&lt;!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。</span></span><br><span class="line"><span class="string">x|y            匹配 x 或 y。例如，'</span>z|food<span class="string">' 能匹配 "z" 或 "food"。'</span>(z|f)ood<span class="string">' 则匹配 "zood" 或 "food"。</span></span><br><span class="line"><span class="string">[xyz]          字符集合。匹配所包含的任意一个字符。例如， '</span>[abc]<span class="string">' 可以匹配 "plain" 中的 '</span>a<span class="string">'。</span></span><br><span class="line"><span class="string">[^xyz]         负值字符集合。匹配未包含的任意字符。例如， '</span>[^abc]<span class="string">' 可以匹配 "plain" 中的'</span>p<span class="string">'、'</span>l<span class="string">'、'</span>i<span class="string">'、'</span>n<span class="string">'。</span></span><br><span class="line"><span class="string">[a-z]          字符范围。匹配指定范围内的任意字符。例如，'</span>[a-z]<span class="string">' 可以匹配 '</span>a<span class="string">' 到 '</span>z<span class="string">' 范围内的任意小写字母字符。</span></span><br><span class="line"><span class="string">[^a-z]         负值字符范围。匹配任何不在指定范围内的任意字符。例如，'</span>[^a-z]<span class="string">' 可以匹配任何不在 '</span>a<span class="string">' 到 '</span>z<span class="string">' 范围内的任意字符。</span></span><br><span class="line"><span class="string">\b             匹配一个单词边界，也就是指单词和空格间的位置。例如， '</span>er<span class="string">\b'</span> 可以匹配<span class="string">"never"</span> 中的 <span class="string">'er'</span>，但不能匹配 <span class="string">"verb"</span> 中的 <span class="string">'er'</span>。</span><br><span class="line"><span class="string">\B</span>             匹配非单词边界。<span class="string">'er\B'</span> 能匹配 <span class="string">"verb"</span> 中的 <span class="string">'er'</span>，但不能匹配 <span class="string">"never"</span> 中的 <span class="string">'er'</span>。</span><br><span class="line"><span class="string">\cx</span>            匹配由 x 指明的控制字符。例如， <span class="string">\cM</span> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 <span class="string">'c'</span> 字符。</span><br><span class="line"><span class="string">\d</span>             匹配一个数字字符。等价于 [<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line"><span class="string">\D</span>             匹配一个非数字字符。等价于 [^<span class="number">0</span>-<span class="number">9</span>]。</span><br><span class="line"><span class="string">\f</span>             匹配一个换页符。等价于 <span class="string">\x0c</span> 和 <span class="string">\cL。</span></span><br><span class="line"><span class="string">\n</span>             匹配一个换行符。等价于 <span class="string">\x0a</span> 和 <span class="string">\cJ。</span></span><br><span class="line"><span class="string">\r</span>             匹配一个回车符。等价于 <span class="string">\x0d</span> 和 <span class="string">\cM。</span></span><br><span class="line"><span class="string">\s</span>             匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ <span class="string">\f\n\r\t\v]。</span></span><br><span class="line"><span class="string">\S</span>             匹配任何非空白字符。等价于 [^ <span class="string">\f\n\r\t\v]。</span></span><br><span class="line"><span class="string">\t</span>             匹配一个制表符。等价于 <span class="string">\x09</span> 和 <span class="string">\cI。</span></span><br><span class="line"><span class="string">\v</span>             匹配一个垂直制表符。等价于 <span class="string">\x0b</span> 和 <span class="string">\cK。</span></span><br><span class="line"><span class="string">\w</span>             匹配字母、数字、下划线。等价于<span class="string">'[A-Za-z0-9_]'</span>。</span><br><span class="line"><span class="string">\W</span>             匹配非字母、数字、下划线。等价于 <span class="string">'[^A-Za-z0-9_]'</span>。</span><br><span class="line"><span class="string">\xn</span>            匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<span class="string">'\x41'</span> 匹配 <span class="string">"A"</span>。<span class="string">'\x041'</span> 则等价于 <span class="string">'\x04'</span> &amp; <span class="string">"1"</span>。正则表达式中可以使用 ASCII 编码。</span><br><span class="line"><span class="string">\num</span>           匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<span class="string">'(.)\1'</span> 匹配两个连续的相同字符。</span><br><span class="line"><span class="string">\n</span>             标识一个八进制转义值或一个向后引用。如果 <span class="string">\n</span> 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则 n 为一个八进制转义值。</span><br><span class="line"><span class="string">\nm</span>            标识一个八进制转义值或一个向后引用。如果 <span class="string">\nm</span> 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 <span class="string">\nm</span> 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则 <span class="string">\nm</span> 将匹配八进制转义值 nm。</span><br><span class="line"><span class="string">\nml</span>           如果 n 为八进制数字 (<span class="number">0</span>-<span class="number">3</span>)，且 m 和 l 均为八进制数字 (<span class="number">0</span>-<span class="number">7</span>)，则匹配八进制转义值 nml。</span><br><span class="line"><span class="string">\un</span>            匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， <span class="string">\u00A9</span> 匹配版权符号 (?)。</span><br></pre></td></tr></table></figure>

<h2 id="五、正则表达式-运算符优先级"><a href="#五、正则表达式-运算符优先级" class="headerlink" title="五、正则表达式 - 运算符优先级"></a>五、正则表达式 - 运算符优先级</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运算符	描述</span><br><span class="line">\                            转义符</span><br><span class="line">(), (?<span class="symbol">:</span>), (?=), []           圆括号和方括号</span><br><span class="line">*, +, ?, &#123;<span class="built_in">n</span>&#125;, &#123;<span class="built_in">n</span>,&#125;, &#123;<span class="built_in">n</span>,m&#125;    限定符</span><br><span class="line">^, $, \任何元字符、任何字符     定位点和序列（即：位置和顺序）</span><br><span class="line">|                            替换，<span class="string">"或"</span>操作,字符具有高于替换运算符的优先级，使得<span class="string">"m|food"</span>匹配<span class="string">"m"</span>或<span class="string">"food"</span>。若要匹配<span class="string">"mood"</span>或<span class="string">"food"</span>，请使用括号创建子表达式，从而产生<span class="string">"(m|f)ood"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="六、正则表达式-匹配规则"><a href="#六、正则表达式-匹配规则" class="headerlink" title="六、正则表达式 - 匹配规则"></a>六、正则表达式 - 匹配规则</h2><h3 id="6-1、基本模式匹配"><a href="#6-1、基本模式匹配" class="headerlink" title="6.1、基本模式匹配"></a>6.1、基本模式匹配</h3><p>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">^once</span></span><br></pre></td></tr></table></figure>
<p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket<span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 ^ 和 $ 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">^bucket</span>$</span><br></pre></td></tr></table></figure>
<p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">once</span></span><br></pre></td></tr></table></figure>
<p>与字符串</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was <span class="keyword">a</span> man <span class="built_in">from</span> NewYork</span><br><span class="line">Who kept all <span class="keyword">of</span> his cash <span class="keyword">in</span> <span class="keyword">a</span> bucket.</span><br></pre></td></tr></table></figure>
<p>是匹配的。<br>在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是 \t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="string">\t</span></span><br></pre></td></tr></table></figure>
<p>类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>
<h3 id="6-2、字符簇"><a href="#6-2、字符簇" class="headerlink" title="6.2、字符簇"></a>6.2、字符簇</h3><p>在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。<br>所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure>
<p>这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a-z]        <span class="comment">//匹配所有的小写字母 </span></span><br><span class="line">[A-Z]        <span class="comment">//匹配所有的大写字母 </span></span><br><span class="line">[a-zA-Z]     <span class="comment">//匹配所有的字母 </span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]        <span class="comment">//匹配所有的数字 </span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>\.\-]    <span class="comment">//匹配所有的数字，句号和减号 </span></span><br><span class="line">[ \f\r\t\n]  <span class="comment">//匹配所有的白字符</span></span><br></pre></td></tr></table></figure>
<p>同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">a-z</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure>
<p>尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。<br>前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 ^ 时，它表示”非”或”排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="string">^0-9</span>][<span class="symbol">0-9</span>]$</span><br></pre></td></tr></table></figure>
<p>这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[^a-z]    <span class="comment">//除了小写字母以外的所有字符 </span></span><br><span class="line">[^\\\/\^] <span class="comment">//除了(\)(/)(^)之外的所有字符 </span></span><br><span class="line">[^\<span class="string">"\']   //除了双引号("</span>)和单引号(')之外的所有字符</span><br></pre></td></tr></table></figure>
<p>特殊字符 .(点，句号)在正则表达式中用来表示除了”新行”之外的所有字符。所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式 . 可以匹配任何字符串，除了空串和只包括一个”新行”的字符串。<br>PHP的正则表达式有一些内置的通用字符簇，列表如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字符簇	描述</span><br><span class="line"><span class="string">[[:alpha:]]</span>    任何字母</span><br><span class="line"><span class="string">[[:digit:]]</span>    任何数字</span><br><span class="line"><span class="string">[[:alnum:]]</span>    任何字母和数字</span><br><span class="line"><span class="string">[[:space:]]</span>    任何空白字符</span><br><span class="line"><span class="string">[[:upper:]]</span>    任何大写字母</span><br><span class="line"><span class="string">[[:lower:]]</span>    任何小写字母</span><br><span class="line"><span class="string">[[:punct:]]</span>    任何标点符号</span><br><span class="line"><span class="string">[[:xdigit:]]</span>   任何<span class="number">16</span>进制的数字，相当于[<span class="number">0</span><span class="number">-9</span>a-fA-F]</span><br></pre></td></tr></table></figure>

<h3 id="6-3、确定重复出现"><a href="#6-3、确定重复出现" class="headerlink" title="6.3、确定重复出现"></a>6.3、确定重复出现</h3><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字符簇	描述</span><br><span class="line">^[a-zA-Z_]$         所有的字母和下划线</span><br><span class="line">^[[:alpha:]]&#123;<span class="number">3</span>&#125;$    所有的<span class="number">3</span>个字母的单词</span><br><span class="line">^a$                 字母a</span><br><span class="line">^a&#123;<span class="number">4</span>&#125;$              aaaa</span><br><span class="line">^a&#123;<span class="number">2</span>,<span class="number">4</span>&#125;$            aa,aaa或aaaa</span><br><span class="line">^a&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$            a,aa或aaa</span><br><span class="line">^a&#123;<span class="number">2</span>,&#125;$             包含多于两个a的字符串</span><br><span class="line">^a&#123;<span class="number">2</span>,&#125;              如：aardvark和aaab，但apple不行</span><br><span class="line">a&#123;<span class="number">2</span>,&#125;               如：baad和aaa，但Nantucket不行</span><br><span class="line">\t&#123;<span class="number">2</span>&#125;               两个制表符</span><br><span class="line">.&#123;<span class="number">2</span>&#125;                所有的两个字符</span><br></pre></td></tr></table></figure>
<p>这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。我们可以把模式扩展到更多的单词或数字：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0<span class="number">-9</span>_]&#123;<span class="number">1</span>,&#125;$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">0</span>,&#125;$        <span class="comment">// 所有的正整数 </span></span><br><span class="line">^\-&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;$      <span class="comment">// 所有的整数 </span></span><br><span class="line">^[-]?[<span class="number">0</span><span class="number">-9</span>]+\.?[<span class="number">0</span><span class="number">-9</span>]+$   <span class="comment">// 所有的浮点数</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。<br>特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^\-?[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;\.?[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,&#125;$ <span class="comment">//特殊字符 * 与 &#123;0,&#125; 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 &#123;1,&#125; 是相等的，表示 1 个或多个前面的内容 ，所以上面的4个例子可以写成：</span></span><br><span class="line">^[a-zA-Z0<span class="number">-9</span>_]+$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$        <span class="comment">// 所有的正整数 </span></span><br><span class="line">^\-?[<span class="number">0</span><span class="number">-9</span>]+$          <span class="comment">// 所有的整数 </span></span><br><span class="line">^[-]?[<span class="number">0</span><span class="number">-9</span>]+(\.[<span class="number">0</span><span class="number">-9</span>]+)?$ <span class="comment">// 所有的浮点数</span></span><br></pre></td></tr></table></figure>
<p>当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。</p>
<h2 id="七、正则表达式-示例"><a href="#七、正则表达式-示例" class="headerlink" title="七、正则表达式 - 示例"></a>七、正则表达式 - 示例</h2><p>简单表达式<br>正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/a/</span></span><br><span class="line"><span class="regexp">/7/</span></span><br><span class="line"><span class="regexp">/M/</span></span><br></pre></td></tr></table></figure>
<p>可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/a7M/</span></span><br></pre></td></tr></table></figure>
<p>请注意，没有串联运算符。只须在一个字符后面键入另一个字符。</p>
<h3 id="7-1、字符匹配"><a href="#7-1、字符匹配" class="headerlink" title="7.1、字符匹配"></a>7.1、字符匹配</h3><p>句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/a.c/</span></span><br></pre></td></tr></table></figure>
<p>若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜杠 () 字符。举例来说明，下面的正则表达式匹配 filename.ext：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/filename</span>\<span class="string">.ext/</span></span><br></pre></td></tr></table></figure>
<p>这些表达式只让您匹配”任何”单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。</p>
<h3 id="7-2、中括号表达式"><a href="#7-2、中括号表达式" class="headerlink" title="7.2、中括号表达式"></a>7.2、中括号表达式</h3><p>若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为”中括号表达式”。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：<br>如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。<br>\ 字符继续作为转义符。若要匹配 \ 字符，请使用 \。<br>括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [<span class="number">12345</span>]/</span><br></pre></td></tr></table></figure>
<p>请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。<br>若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [<span class="number">1</span><span class="number">-5</span>]/</span><br></pre></td></tr></table></figure>
<p>当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。<br>若要在中括号表达式中包括连字符，请采用下列方法之一：</p>
<ul>
<li>用反斜杠将它转义：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\-]</span><br></pre></td></tr></table></figure></li>
<li>将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-a-z]</span><br><span class="line">[a-z-]</span><br></pre></td></tr></table></figure></li>
<li>创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!--]</span><br><span class="line">[!-~]</span><br></pre></td></tr></table></figure>
若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [^<span class="number">12345</span>]/</span><br></pre></td></tr></table></figure>
在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。<br>上面的表达式可以使用连字符 (-) 来表示：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Chapter [^<span class="number">1</span><span class="number">-5</span>]/</span><br></pre></td></tr></table></figure>
中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[A-Za-z0<span class="number">-9</span>]/</span><br></pre></td></tr></table></figure>
<h3 id="7-3、替换和分组"><a href="#7-3、替换和分组" class="headerlink" title="7.3、替换和分组"></a>7.3、替换和分组</h3>替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。<br>您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^Chapter|Section [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。<br>若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。<br>下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(Chapter|Section) [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的”子匹配项”。<br>在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(?:Chapter|Section) [<span class="string">1-9</span>][<span class="symbol">0-9</span>]&#123;0,1&#125;$/</span><br></pre></td></tr></table></figure>
除 ?: 元字符外，两个其他非捕获元字符创建被称为”预测先行”匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。<br>例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Windows(?=<span class="number">95</span> |<span class="number">98</span> |NT )/</span><br></pre></td></tr></table></figure>
找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。<br>其他示例<br>下面列出一些正则表达式示例：<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">正则表达式          描述</span><br><span class="line">/<span class="tag">\<span class="name">b</span></span>([a-z]+) <span class="tag">\</span>1<span class="tag">\<span class="name">b</span></span>/gi                                一个单词连续出现的位置。</span><br><span class="line">/(<span class="tag">\<span class="name">w</span></span>+):<span class="tag">\<span class="name">/</span></span><span class="tag">\<span class="name">/</span></span>([^/:]+)(:<span class="tag">\<span class="name">d*</span></span>)?([^# ]*)/                将一个URL解析为协议、域、端口及相对路径。</span><br><span class="line">/^(?:Chapter|Section) [1-9][0-9]&#123;0,1&#125;<span class="formula">$/            定位章节的位置。</span></span><br><span class="line"><span class="formula">/[-a-z]/                                           a至z共26个字母再加一个-号。</span></span><br><span class="line"><span class="formula">/ter<span class="tag">\<span class="name">b</span></span>/                                            可匹配chapter，而不能匹配terminal。</span></span><br><span class="line"><span class="formula">/<span class="tag">\<span class="name">Bapt</span></span>/                                            可匹配chapter，而不能匹配aptitude。</span></span><br><span class="line"><span class="formula">/Windows(?=95 |98 |NT )/                           可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。</span></span><br><span class="line"><span class="formula">/^<span class="tag">\<span class="name">s*</span></span>$</span>/                                            匹配空行。</span><br><span class="line">/<span class="tag">\<span class="name">d</span><span class="string">&#123;2&#125;</span></span>-<span class="tag">\<span class="name">d</span><span class="string">&#123;5&#125;</span></span>/                                      验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</span><br><span class="line">/&lt;<span class="tag">\<span class="name">s*</span></span>(<span class="tag">\<span class="name">S</span></span>+)(<span class="tag">\<span class="name">s</span><span class="string">[^&gt;]</span></span>*)?&gt;[<span class="tag">\<span class="name">s</span></span><span class="tag">\<span class="name">S</span></span>]*&lt;<span class="tag">\<span class="name">s*</span></span><span class="tag">\<span class="name">/</span></span><span class="tag">\</span>1<span class="tag">\<span class="name">s*</span></span>&gt;/          匹配 HTML 标记。</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Eric
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.ericlife.top/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" title="正则表达式">https://www.ericlife.top/正则表达式.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%AD%A3%E5%88%99/" rel="tag"># 正则</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/CGContextRef%E8%AF%A6%E8%A7%A3.html" rel="prev" title="CGContextRef详解">
      <i class="fa fa-chevron-left"></i> CGContextRef详解
    </a></div>
      <div class="post-nav-item">
    <a href="/%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" rel="next" title="最基本的几种排序算法">
      最基本的几种排序算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、为什么使用正则表达式？"><span class="nav-text">一、为什么使用正则表达式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、发展历史"><span class="nav-text">二、发展历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、语法"><span class="nav-text">三、语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1、普通字符"><span class="nav-text">3.1、普通字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2、非打印字符"><span class="nav-text">3.2、非打印字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3、特殊字符"><span class="nav-text">3.3、特殊字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4、限定符"><span class="nav-text">3.4、限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5、定位符"><span class="nav-text">3.5、定位符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6、选择"><span class="nav-text">3.6、选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7、反向引用"><span class="nav-text">3.7、反向引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、元字符"><span class="nav-text">四、元字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、正则表达式-运算符优先级"><span class="nav-text">五、正则表达式 - 运算符优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、正则表达式-匹配规则"><span class="nav-text">六、正则表达式 - 匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1、基本模式匹配"><span class="nav-text">6.1、基本模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2、字符簇"><span class="nav-text">6.2、字符簇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3、确定重复出现"><span class="nav-text">6.3、确定重复出现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、正则表达式-示例"><span class="nav-text">七、正则表达式 - 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1、字符匹配"><span class="nav-text">7.1、字符匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2、中括号表达式"><span class="nav-text">7.2、中括号表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3、替换和分组"><span class="nav-text">7.3、替换和分组</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Eric</p>
  <div class="site-description" itemprop="description">记录开发过程中技术点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">248k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:45</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
